{"ast":null,"code":"const {\n  createHash\n} = require('crypto');\n\nconst ecdhComputeSecret = require('./compute_secret');\n\nconst concat = (key, length, value) => {\n  const iterations = Math.ceil(length / 32);\n  let res;\n\n  for (let iter = 1; iter <= iterations; iter++) {\n    const buf = Buffer.allocUnsafe(4 + key.length + value.length);\n    buf.writeUInt32BE(iter, 0);\n    key.copy(buf, 4);\n    value.copy(buf, 4 + key.length);\n\n    if (!res) {\n      res = createHash('sha256').update(buf).digest();\n    } else {\n      res = Buffer.concat([res, createHash('sha256').update(buf).digest()]);\n    }\n  }\n\n  return res.slice(0, length);\n};\n\nconst uint32be = (value, buf = Buffer.allocUnsafe(4)) => {\n  buf.writeUInt32BE(value);\n  return buf;\n};\n\nconst lengthAndInput = input => Buffer.concat([uint32be(input.length), input]);\n\nmodule.exports = (alg, keyLen, privKey, pubKey, {\n  apu = Buffer.alloc(0),\n  apv = Buffer.alloc(0)\n} = {}, computeSecret = ecdhComputeSecret) => {\n  const value = Buffer.concat([lengthAndInput(Buffer.from(alg)), lengthAndInput(apu), lengthAndInput(apv), uint32be(keyLen)]);\n  const sharedSecret = computeSecret(privKey, pubKey);\n  return concat(sharedSecret, keyLen / 8, value);\n};","map":{"version":3,"sources":["/home/invidam/hamburger_calender/client/node_modules/jose/lib/jwa/ecdh/derive.js"],"names":["createHash","require","ecdhComputeSecret","concat","key","length","value","iterations","Math","ceil","res","iter","buf","Buffer","allocUnsafe","writeUInt32BE","copy","update","digest","slice","uint32be","lengthAndInput","input","module","exports","alg","keyLen","privKey","pubKey","apu","alloc","apv","computeSecret","from","sharedSecret"],"mappings":"AAAA,MAAM;AAAEA,EAAAA;AAAF,IAAiBC,OAAO,CAAC,QAAD,CAA9B;;AACA,MAAMC,iBAAiB,GAAGD,OAAO,CAAC,kBAAD,CAAjC;;AAEA,MAAME,MAAM,GAAG,CAACC,GAAD,EAAMC,MAAN,EAAcC,KAAd,KAAwB;AACrC,QAAMC,UAAU,GAAGC,IAAI,CAACC,IAAL,CAAUJ,MAAM,GAAG,EAAnB,CAAnB;AACA,MAAIK,GAAJ;;AAEA,OAAK,IAAIC,IAAI,GAAG,CAAhB,EAAmBA,IAAI,IAAIJ,UAA3B,EAAuCI,IAAI,EAA3C,EAA+C;AAC7C,UAAMC,GAAG,GAAGC,MAAM,CAACC,WAAP,CAAmB,IAAIV,GAAG,CAACC,MAAR,GAAiBC,KAAK,CAACD,MAA1C,CAAZ;AACAO,IAAAA,GAAG,CAACG,aAAJ,CAAkBJ,IAAlB,EAAwB,CAAxB;AACAP,IAAAA,GAAG,CAACY,IAAJ,CAASJ,GAAT,EAAc,CAAd;AACAN,IAAAA,KAAK,CAACU,IAAN,CAAWJ,GAAX,EAAgB,IAAIR,GAAG,CAACC,MAAxB;;AACA,QAAI,CAACK,GAAL,EAAU;AACRA,MAAAA,GAAG,GAAGV,UAAU,CAAC,QAAD,CAAV,CAAqBiB,MAArB,CAA4BL,GAA5B,EAAiCM,MAAjC,EAAN;AACD,KAFD,MAEO;AACLR,MAAAA,GAAG,GAAGG,MAAM,CAACV,MAAP,CAAc,CAACO,GAAD,EAAMV,UAAU,CAAC,QAAD,CAAV,CAAqBiB,MAArB,CAA4BL,GAA5B,EAAiCM,MAAjC,EAAN,CAAd,CAAN;AACD;AACF;;AAED,SAAOR,GAAG,CAACS,KAAJ,CAAU,CAAV,EAAad,MAAb,CAAP;AACD,CAjBD;;AAmBA,MAAMe,QAAQ,GAAG,CAACd,KAAD,EAAQM,GAAG,GAAGC,MAAM,CAACC,WAAP,CAAmB,CAAnB,CAAd,KAAwC;AACvDF,EAAAA,GAAG,CAACG,aAAJ,CAAkBT,KAAlB;AACA,SAAOM,GAAP;AACD,CAHD;;AAKA,MAAMS,cAAc,GAAGC,KAAK,IAAIT,MAAM,CAACV,MAAP,CAAc,CAACiB,QAAQ,CAACE,KAAK,CAACjB,MAAP,CAAT,EAAyBiB,KAAzB,CAAd,CAAhC;;AAEAC,MAAM,CAACC,OAAP,GAAiB,CAACC,GAAD,EAAMC,MAAN,EAAcC,OAAd,EAAuBC,MAAvB,EAA+B;AAAEC,EAAAA,GAAG,GAAGhB,MAAM,CAACiB,KAAP,CAAa,CAAb,CAAR;AAAyBC,EAAAA,GAAG,GAAGlB,MAAM,CAACiB,KAAP,CAAa,CAAb;AAA/B,IAAmD,EAAlF,EAAsFE,aAAa,GAAG9B,iBAAtG,KAA4H;AAC3I,QAAMI,KAAK,GAAGO,MAAM,CAACV,MAAP,CAAc,CAC1BkB,cAAc,CAACR,MAAM,CAACoB,IAAP,CAAYR,GAAZ,CAAD,CADY,EAE1BJ,cAAc,CAACQ,GAAD,CAFY,EAG1BR,cAAc,CAACU,GAAD,CAHY,EAI1BX,QAAQ,CAACM,MAAD,CAJkB,CAAd,CAAd;AAOA,QAAMQ,YAAY,GAAGF,aAAa,CAACL,OAAD,EAAUC,MAAV,CAAlC;AACA,SAAOzB,MAAM,CAAC+B,YAAD,EAAeR,MAAM,GAAG,CAAxB,EAA2BpB,KAA3B,CAAb;AACD,CAVD","sourcesContent":["const { createHash } = require('crypto')\nconst ecdhComputeSecret = require('./compute_secret')\n\nconst concat = (key, length, value) => {\n  const iterations = Math.ceil(length / 32)\n  let res\n\n  for (let iter = 1; iter <= iterations; iter++) {\n    const buf = Buffer.allocUnsafe(4 + key.length + value.length)\n    buf.writeUInt32BE(iter, 0)\n    key.copy(buf, 4)\n    value.copy(buf, 4 + key.length)\n    if (!res) {\n      res = createHash('sha256').update(buf).digest()\n    } else {\n      res = Buffer.concat([res, createHash('sha256').update(buf).digest()])\n    }\n  }\n\n  return res.slice(0, length)\n}\n\nconst uint32be = (value, buf = Buffer.allocUnsafe(4)) => {\n  buf.writeUInt32BE(value)\n  return buf\n}\n\nconst lengthAndInput = input => Buffer.concat([uint32be(input.length), input])\n\nmodule.exports = (alg, keyLen, privKey, pubKey, { apu = Buffer.alloc(0), apv = Buffer.alloc(0) } = {}, computeSecret = ecdhComputeSecret) => {\n  const value = Buffer.concat([\n    lengthAndInput(Buffer.from(alg)),\n    lengthAndInput(apu),\n    lengthAndInput(apv),\n    uint32be(keyLen)\n  ])\n\n  const sharedSecret = computeSecret(privKey, pubKey)\n  return concat(sharedSecret, keyLen / 8, value)\n}\n"]},"metadata":{},"sourceType":"script"}