{"ast":null,"code":"\"use strict\"; // Copyright 2015 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.JWTAccess = void 0;\n\nconst jws = require(\"jws\");\n\nconst LRU = require(\"lru-cache\");\n\nconst DEFAULT_HEADER = {\n  alg: 'RS256',\n  typ: 'JWT'\n};\n\nclass JWTAccess {\n  /**\n   * JWTAccess service account credentials.\n   *\n   * Create a new access token by using the credential to create a new JWT token\n   * that's recognized as the access token.\n   *\n   * @param email the service account email address.\n   * @param key the private key that will be used to sign the token.\n   * @param keyId the ID of the private key used to sign the token.\n   */\n  constructor(email, key, keyId, eagerRefreshThresholdMillis) {\n    this.cache = new LRU({\n      max: 500,\n      maxAge: 60 * 60 * 1000\n    });\n    this.email = email;\n    this.key = key;\n    this.keyId = keyId;\n    this.eagerRefreshThresholdMillis = eagerRefreshThresholdMillis !== null && eagerRefreshThresholdMillis !== void 0 ? eagerRefreshThresholdMillis : 5 * 60 * 1000;\n  }\n  /**\n   * Ensures that we're caching a key appropriately, giving precedence to scopes vs. url\n   *\n   * @param url The URI being authorized.\n   * @param scopes The scope or scopes being authorized\n   * @returns A string that returns the cached key.\n   */\n\n\n  getCachedKey(url, scopes) {\n    let cacheKey = url;\n\n    if (scopes && Array.isArray(scopes) && scopes.length) {\n      cacheKey = url ? `${url}_${scopes.join('_')}` : `${scopes.join('_')}`;\n    } else if (typeof scopes === 'string') {\n      cacheKey = url ? `${url}_${scopes}` : scopes;\n    }\n\n    if (!cacheKey) {\n      throw Error('Scopes or url must be provided');\n    }\n\n    return cacheKey;\n  }\n  /**\n   * Get a non-expired access token, after refreshing if necessary.\n   *\n   * @param url The URI being authorized.\n   * @param additionalClaims An object with a set of additional claims to\n   * include in the payload.\n   * @returns An object that includes the authorization header.\n   */\n\n\n  getRequestHeaders(url, additionalClaims, scopes) {\n    // Return cached authorization headers, unless we are within\n    // eagerRefreshThresholdMillis ms of them expiring:\n    const key = this.getCachedKey(url, scopes);\n    const cachedToken = this.cache.get(key);\n    const now = Date.now();\n\n    if (cachedToken && cachedToken.expiration - now > this.eagerRefreshThresholdMillis) {\n      return cachedToken.headers;\n    }\n\n    const iat = Math.floor(Date.now() / 1000);\n    const exp = JWTAccess.getExpirationTime(iat);\n    let defaultClaims; // Turn scopes into space-separated string\n\n    if (Array.isArray(scopes)) {\n      scopes = scopes.join(' ');\n    } // If scopes are specified, sign with scopes\n\n\n    if (scopes) {\n      defaultClaims = {\n        iss: this.email,\n        sub: this.email,\n        scope: scopes,\n        exp,\n        iat\n      };\n    } else {\n      defaultClaims = {\n        iss: this.email,\n        sub: this.email,\n        aud: url,\n        exp,\n        iat\n      };\n    } // if additionalClaims are provided, ensure they do not collide with\n    // other required claims.\n\n\n    if (additionalClaims) {\n      for (const claim in defaultClaims) {\n        if (additionalClaims[claim]) {\n          throw new Error(`The '${claim}' property is not allowed when passing additionalClaims. This claim is included in the JWT by default.`);\n        }\n      }\n    }\n\n    const header = this.keyId ? { ...DEFAULT_HEADER,\n      kid: this.keyId\n    } : DEFAULT_HEADER;\n    const payload = Object.assign(defaultClaims, additionalClaims); // Sign the jwt and add it to the cache\n\n    const signedJWT = jws.sign({\n      header,\n      payload,\n      secret: this.key\n    });\n    const headers = {\n      Authorization: `Bearer ${signedJWT}`\n    };\n    this.cache.set(key, {\n      expiration: exp * 1000,\n      headers\n    });\n    return headers;\n  }\n  /**\n   * Returns an expiration time for the JWT token.\n   *\n   * @param iat The issued at time for the JWT.\n   * @returns An expiration time for the JWT.\n   */\n\n\n  static getExpirationTime(iat) {\n    const exp = iat + 3600; // 3600 seconds = 1 hour\n\n    return exp;\n  }\n  /**\n   * Create a JWTAccess credentials instance using the given input options.\n   * @param json The input object.\n   */\n\n\n  fromJSON(json) {\n    if (!json) {\n      throw new Error('Must pass in a JSON object containing the service account auth settings.');\n    }\n\n    if (!json.client_email) {\n      throw new Error('The incoming JSON object does not contain a client_email field');\n    }\n\n    if (!json.private_key) {\n      throw new Error('The incoming JSON object does not contain a private_key field');\n    } // Extract the relevant information from the json key file.\n\n\n    this.email = json.client_email;\n    this.key = json.private_key;\n    this.keyId = json.private_key_id;\n    this.projectId = json.project_id;\n  }\n\n  fromStream(inputStream, callback) {\n    if (callback) {\n      this.fromStreamAsync(inputStream).then(() => callback(), callback);\n    } else {\n      return this.fromStreamAsync(inputStream);\n    }\n  }\n\n  fromStreamAsync(inputStream) {\n    return new Promise((resolve, reject) => {\n      if (!inputStream) {\n        reject(new Error('Must pass in a stream containing the service account auth settings.'));\n      }\n\n      let s = '';\n      inputStream.setEncoding('utf8').on('data', chunk => s += chunk).on('error', reject).on('end', () => {\n        try {\n          const data = JSON.parse(s);\n          this.fromJSON(data);\n          resolve();\n        } catch (err) {\n          reject(err);\n        }\n      });\n    });\n  }\n\n}\n\nexports.JWTAccess = JWTAccess;","map":{"version":3,"sources":["/home/invidam/hamburger_calender/client/node_modules/google-auth-library/build/src/auth/jwtaccess.js"],"names":["Object","defineProperty","exports","value","JWTAccess","jws","require","LRU","DEFAULT_HEADER","alg","typ","constructor","email","key","keyId","eagerRefreshThresholdMillis","cache","max","maxAge","getCachedKey","url","scopes","cacheKey","Array","isArray","length","join","Error","getRequestHeaders","additionalClaims","cachedToken","get","now","Date","expiration","headers","iat","Math","floor","exp","getExpirationTime","defaultClaims","iss","sub","scope","aud","claim","header","kid","payload","assign","signedJWT","sign","secret","Authorization","set","fromJSON","json","client_email","private_key","private_key_id","projectId","project_id","fromStream","inputStream","callback","fromStreamAsync","then","Promise","resolve","reject","s","setEncoding","on","chunk","data","JSON","parse","err"],"mappings":"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","sourcesContent":["\"use strict\";\n// Copyright 2015 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.JWTAccess = void 0;\nconst jws = require(\"jws\");\nconst LRU = require(\"lru-cache\");\nconst DEFAULT_HEADER = {\n    alg: 'RS256',\n    typ: 'JWT',\n};\nclass JWTAccess {\n    /**\n     * JWTAccess service account credentials.\n     *\n     * Create a new access token by using the credential to create a new JWT token\n     * that's recognized as the access token.\n     *\n     * @param email the service account email address.\n     * @param key the private key that will be used to sign the token.\n     * @param keyId the ID of the private key used to sign the token.\n     */\n    constructor(email, key, keyId, eagerRefreshThresholdMillis) {\n        this.cache = new LRU({\n            max: 500,\n            maxAge: 60 * 60 * 1000,\n        });\n        this.email = email;\n        this.key = key;\n        this.keyId = keyId;\n        this.eagerRefreshThresholdMillis = eagerRefreshThresholdMillis !== null && eagerRefreshThresholdMillis !== void 0 ? eagerRefreshThresholdMillis : 5 * 60 * 1000;\n    }\n    /**\n     * Ensures that we're caching a key appropriately, giving precedence to scopes vs. url\n     *\n     * @param url The URI being authorized.\n     * @param scopes The scope or scopes being authorized\n     * @returns A string that returns the cached key.\n     */\n    getCachedKey(url, scopes) {\n        let cacheKey = url;\n        if (scopes && Array.isArray(scopes) && scopes.length) {\n            cacheKey = url ? `${url}_${scopes.join('_')}` : `${scopes.join('_')}`;\n        }\n        else if (typeof scopes === 'string') {\n            cacheKey = url ? `${url}_${scopes}` : scopes;\n        }\n        if (!cacheKey) {\n            throw Error('Scopes or url must be provided');\n        }\n        return cacheKey;\n    }\n    /**\n     * Get a non-expired access token, after refreshing if necessary.\n     *\n     * @param url The URI being authorized.\n     * @param additionalClaims An object with a set of additional claims to\n     * include in the payload.\n     * @returns An object that includes the authorization header.\n     */\n    getRequestHeaders(url, additionalClaims, scopes) {\n        // Return cached authorization headers, unless we are within\n        // eagerRefreshThresholdMillis ms of them expiring:\n        const key = this.getCachedKey(url, scopes);\n        const cachedToken = this.cache.get(key);\n        const now = Date.now();\n        if (cachedToken &&\n            cachedToken.expiration - now > this.eagerRefreshThresholdMillis) {\n            return cachedToken.headers;\n        }\n        const iat = Math.floor(Date.now() / 1000);\n        const exp = JWTAccess.getExpirationTime(iat);\n        let defaultClaims;\n        // Turn scopes into space-separated string\n        if (Array.isArray(scopes)) {\n            scopes = scopes.join(' ');\n        }\n        // If scopes are specified, sign with scopes\n        if (scopes) {\n            defaultClaims = {\n                iss: this.email,\n                sub: this.email,\n                scope: scopes,\n                exp,\n                iat,\n            };\n        }\n        else {\n            defaultClaims = {\n                iss: this.email,\n                sub: this.email,\n                aud: url,\n                exp,\n                iat,\n            };\n        }\n        // if additionalClaims are provided, ensure they do not collide with\n        // other required claims.\n        if (additionalClaims) {\n            for (const claim in defaultClaims) {\n                if (additionalClaims[claim]) {\n                    throw new Error(`The '${claim}' property is not allowed when passing additionalClaims. This claim is included in the JWT by default.`);\n                }\n            }\n        }\n        const header = this.keyId\n            ? { ...DEFAULT_HEADER, kid: this.keyId }\n            : DEFAULT_HEADER;\n        const payload = Object.assign(defaultClaims, additionalClaims);\n        // Sign the jwt and add it to the cache\n        const signedJWT = jws.sign({ header, payload, secret: this.key });\n        const headers = { Authorization: `Bearer ${signedJWT}` };\n        this.cache.set(key, {\n            expiration: exp * 1000,\n            headers,\n        });\n        return headers;\n    }\n    /**\n     * Returns an expiration time for the JWT token.\n     *\n     * @param iat The issued at time for the JWT.\n     * @returns An expiration time for the JWT.\n     */\n    static getExpirationTime(iat) {\n        const exp = iat + 3600; // 3600 seconds = 1 hour\n        return exp;\n    }\n    /**\n     * Create a JWTAccess credentials instance using the given input options.\n     * @param json The input object.\n     */\n    fromJSON(json) {\n        if (!json) {\n            throw new Error('Must pass in a JSON object containing the service account auth settings.');\n        }\n        if (!json.client_email) {\n            throw new Error('The incoming JSON object does not contain a client_email field');\n        }\n        if (!json.private_key) {\n            throw new Error('The incoming JSON object does not contain a private_key field');\n        }\n        // Extract the relevant information from the json key file.\n        this.email = json.client_email;\n        this.key = json.private_key;\n        this.keyId = json.private_key_id;\n        this.projectId = json.project_id;\n    }\n    fromStream(inputStream, callback) {\n        if (callback) {\n            this.fromStreamAsync(inputStream).then(() => callback(), callback);\n        }\n        else {\n            return this.fromStreamAsync(inputStream);\n        }\n    }\n    fromStreamAsync(inputStream) {\n        return new Promise((resolve, reject) => {\n            if (!inputStream) {\n                reject(new Error('Must pass in a stream containing the service account auth settings.'));\n            }\n            let s = '';\n            inputStream\n                .setEncoding('utf8')\n                .on('data', chunk => (s += chunk))\n                .on('error', reject)\n                .on('end', () => {\n                try {\n                    const data = JSON.parse(s);\n                    this.fromJSON(data);\n                    resolve();\n                }\n                catch (err) {\n                    reject(err);\n                }\n            });\n        });\n    }\n}\nexports.JWTAccess = JWTAccess;\n//# sourceMappingURL=jwtaccess.js.map"]},"metadata":{},"sourceType":"script"}