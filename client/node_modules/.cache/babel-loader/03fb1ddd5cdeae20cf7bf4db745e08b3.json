{"ast":null,"code":"const {\n  deflateRawSync\n} = require('zlib');\n\nconst {\n  KEYOBJECT\n} = require('../help/consts');\n\nconst generateIV = require('../help/generate_iv');\n\nconst base64url = require('../help/base64url');\n\nconst getKey = require('../help/get_key');\n\nconst isObject = require('../help/is_object');\n\nconst {\n  createSecretKey\n} = require('../help/key_object');\n\nconst deepClone = require('../help/deep_clone');\n\nconst importKey = require('../jwk/import');\n\nconst {\n  JWEInvalid\n} = require('../errors');\n\nconst {\n  check,\n  keyManagementEncrypt,\n  encrypt\n} = require('../jwa');\n\nconst serializers = require('./serializers');\n\nconst generateCEK = require('./generate_cek');\n\nconst validateHeaders = require('./validate_headers');\n\nconst PROCESS_RECIPIENT = Symbol('PROCESS_RECIPIENT');\n\nclass Encrypt {\n  constructor(cleartext, protectedHeader, aad, unprotectedHeader) {\n    if (!Buffer.isBuffer(cleartext) && typeof cleartext !== 'string') {\n      throw new TypeError('cleartext argument must be a Buffer or a string');\n    }\n\n    cleartext = Buffer.from(cleartext);\n\n    if (aad !== undefined && !Buffer.isBuffer(aad) && typeof aad !== 'string') {\n      throw new TypeError('aad argument must be a Buffer or a string when provided');\n    }\n\n    aad = aad ? Buffer.from(aad) : undefined;\n\n    if (protectedHeader !== undefined && !isObject(protectedHeader)) {\n      throw new TypeError('protectedHeader argument must be a plain object when provided');\n    }\n\n    if (unprotectedHeader !== undefined && !isObject(unprotectedHeader)) {\n      throw new TypeError('unprotectedHeader argument must be a plain object when provided');\n    }\n\n    this._recipients = [];\n    this._cleartext = cleartext;\n    this._aad = aad;\n    this._unprotected = unprotectedHeader ? deepClone(unprotectedHeader) : undefined;\n    this._protected = protectedHeader ? deepClone(protectedHeader) : undefined;\n  }\n  /*\n   * @public\n   */\n\n\n  recipient(key, header) {\n    key = getKey(key);\n\n    if (header !== undefined && !isObject(header)) {\n      throw new TypeError('header argument must be a plain object when provided');\n    }\n\n    this._recipients.push({\n      key,\n      header: header ? deepClone(header) : undefined\n    });\n\n    return this;\n  }\n  /*\n   * @private\n   */\n\n\n  [PROCESS_RECIPIENT](recipient) {\n    const unprotectedHeader = this._unprotected;\n    const protectedHeader = this._protected;\n    const {\n      length: recipientCount\n    } = this._recipients;\n    const jweHeader = { ...protectedHeader,\n      ...unprotectedHeader,\n      ...recipient.header\n    };\n    const {\n      key\n    } = recipient;\n    const enc = jweHeader.enc;\n    let alg = jweHeader.alg;\n\n    if (key.use === 'sig') {\n      throw new TypeError('a key with \"use\":\"sig\" is not usable for encryption');\n    }\n\n    if (alg === 'dir') {\n      check(key, 'encrypt', enc);\n    } else if (alg) {\n      check(key, 'keyManagementEncrypt', alg);\n    } else {\n      alg = key.alg || [...key.algorithms('wrapKey')][0] || [...key.algorithms('deriveKey')][0];\n\n      if (alg === 'ECDH-ES' && recipientCount !== 1) {\n        alg = [...key.algorithms('deriveKey')][1];\n      }\n\n      if (!alg) {\n        throw new JWEInvalid('could not resolve a usable \"alg\" for a recipient');\n      }\n\n      if (recipientCount === 1) {\n        if (protectedHeader) {\n          protectedHeader.alg = alg;\n        } else {\n          this._protected = {\n            alg\n          };\n        }\n      } else {\n        if (recipient.header) {\n          recipient.header.alg = alg;\n        } else {\n          recipient.header = {\n            alg\n          };\n        }\n      }\n    }\n\n    let wrapped;\n    let generatedHeader;\n\n    if (key.kty === 'oct' && alg === 'dir') {\n      this._cek = importKey(key[KEYOBJECT], {\n        use: 'enc',\n        alg: enc\n      });\n    } else {\n      check(this._cek, 'encrypt', enc);\n      ({\n        wrapped,\n        header: generatedHeader\n      } = keyManagementEncrypt(alg, key, this._cek[KEYOBJECT].export(), {\n        enc,\n        alg\n      }));\n\n      if (alg === 'ECDH-ES') {\n        this._cek = importKey(createSecretKey(wrapped), {\n          use: 'enc',\n          alg: enc\n        });\n      }\n    }\n\n    if (alg === 'dir' || alg === 'ECDH-ES') {\n      recipient.encrypted_key = '';\n    } else {\n      recipient.encrypted_key = base64url.encodeBuffer(wrapped);\n    }\n\n    if (generatedHeader) {\n      recipient.generatedHeader = generatedHeader;\n    }\n  }\n  /*\n   * @public\n   */\n\n\n  encrypt(serialization) {\n    const serializer = serializers[serialization];\n\n    if (!serializer) {\n      throw new TypeError('serialization must be one of \"compact\", \"flattened\", \"general\"');\n    }\n\n    if (!this._recipients.length) {\n      throw new JWEInvalid('missing recipients');\n    }\n\n    serializer.validate(this._protected, this._unprotected, this._aad, this._recipients);\n    let enc = validateHeaders(this._protected, this._unprotected, this._recipients, false, this._protected ? this._protected.crit : undefined);\n\n    if (!enc) {\n      enc = 'A128CBC-HS256';\n\n      if (this._protected) {\n        this._protected.enc = enc;\n      } else {\n        this._protected = {\n          enc\n        };\n      }\n    }\n\n    const final = {};\n    this._cek = generateCEK(enc);\n\n    for (const recipient of this._recipients) {\n      this[PROCESS_RECIPIENT](recipient);\n    }\n\n    const iv = generateIV(enc);\n    final.iv = base64url.encodeBuffer(iv);\n\n    if (this._recipients.length === 1 && this._recipients[0].generatedHeader) {\n      const [{\n        generatedHeader\n      }] = this._recipients;\n      delete this._recipients[0].generatedHeader;\n      this._protected = { ...this._protected,\n        ...generatedHeader\n      };\n    }\n\n    if (this._protected) {\n      final.protected = base64url.JSON.encode(this._protected);\n    }\n\n    final.unprotected = this._unprotected;\n    let aad;\n\n    if (this._aad) {\n      final.aad = base64url.encode(this._aad);\n      aad = Buffer.concat([Buffer.from(final.protected || ''), Buffer.from('.'), Buffer.from(final.aad)]);\n    } else {\n      aad = Buffer.from(final.protected || '');\n    }\n\n    let cleartext = this._cleartext;\n\n    if (this._protected && 'zip' in this._protected) {\n      cleartext = deflateRawSync(cleartext);\n    }\n\n    const {\n      ciphertext,\n      tag\n    } = encrypt(enc, this._cek, cleartext, {\n      iv,\n      aad\n    });\n    final.tag = base64url.encodeBuffer(tag);\n    final.ciphertext = base64url.encodeBuffer(ciphertext);\n    return serializer(final, this._recipients);\n  }\n\n}\n\nmodule.exports = Encrypt;","map":{"version":3,"sources":["/home/invidam/hamburger_calender/client/node_modules/jose/lib/jwe/encrypt.js"],"names":["deflateRawSync","require","KEYOBJECT","generateIV","base64url","getKey","isObject","createSecretKey","deepClone","importKey","JWEInvalid","check","keyManagementEncrypt","encrypt","serializers","generateCEK","validateHeaders","PROCESS_RECIPIENT","Symbol","Encrypt","constructor","cleartext","protectedHeader","aad","unprotectedHeader","Buffer","isBuffer","TypeError","from","undefined","_recipients","_cleartext","_aad","_unprotected","_protected","recipient","key","header","push","length","recipientCount","jweHeader","enc","alg","use","algorithms","wrapped","generatedHeader","kty","_cek","export","encrypted_key","encodeBuffer","serialization","serializer","validate","crit","final","iv","protected","JSON","encode","unprotected","concat","ciphertext","tag","module","exports"],"mappings":"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","sourcesContent":["const { deflateRawSync } = require('zlib')\n\nconst { KEYOBJECT } = require('../help/consts')\nconst generateIV = require('../help/generate_iv')\nconst base64url = require('../help/base64url')\nconst getKey = require('../help/get_key')\nconst isObject = require('../help/is_object')\nconst { createSecretKey } = require('../help/key_object')\nconst deepClone = require('../help/deep_clone')\nconst importKey = require('../jwk/import')\nconst { JWEInvalid } = require('../errors')\nconst { check, keyManagementEncrypt, encrypt } = require('../jwa')\n\nconst serializers = require('./serializers')\nconst generateCEK = require('./generate_cek')\nconst validateHeaders = require('./validate_headers')\n\nconst PROCESS_RECIPIENT = Symbol('PROCESS_RECIPIENT')\n\nclass Encrypt {\n  constructor (cleartext, protectedHeader, aad, unprotectedHeader) {\n    if (!Buffer.isBuffer(cleartext) && typeof cleartext !== 'string') {\n      throw new TypeError('cleartext argument must be a Buffer or a string')\n    }\n    cleartext = Buffer.from(cleartext)\n\n    if (aad !== undefined && !Buffer.isBuffer(aad) && typeof aad !== 'string') {\n      throw new TypeError('aad argument must be a Buffer or a string when provided')\n    }\n    aad = aad ? Buffer.from(aad) : undefined\n\n    if (protectedHeader !== undefined && !isObject(protectedHeader)) {\n      throw new TypeError('protectedHeader argument must be a plain object when provided')\n    }\n\n    if (unprotectedHeader !== undefined && !isObject(unprotectedHeader)) {\n      throw new TypeError('unprotectedHeader argument must be a plain object when provided')\n    }\n\n    this._recipients = []\n    this._cleartext = cleartext\n    this._aad = aad\n    this._unprotected = unprotectedHeader ? deepClone(unprotectedHeader) : undefined\n    this._protected = protectedHeader ? deepClone(protectedHeader) : undefined\n  }\n\n  /*\n   * @public\n   */\n  recipient (key, header) {\n    key = getKey(key)\n\n    if (header !== undefined && !isObject(header)) {\n      throw new TypeError('header argument must be a plain object when provided')\n    }\n\n    this._recipients.push({\n      key,\n      header: header ? deepClone(header) : undefined\n    })\n\n    return this\n  }\n\n  /*\n   * @private\n   */\n  [PROCESS_RECIPIENT] (recipient) {\n    const unprotectedHeader = this._unprotected\n    const protectedHeader = this._protected\n    const { length: recipientCount } = this._recipients\n\n    const jweHeader = {\n      ...protectedHeader,\n      ...unprotectedHeader,\n      ...recipient.header\n    }\n    const { key } = recipient\n\n    const enc = jweHeader.enc\n    let alg = jweHeader.alg\n\n    if (key.use === 'sig') {\n      throw new TypeError('a key with \"use\":\"sig\" is not usable for encryption')\n    }\n\n    if (alg === 'dir') {\n      check(key, 'encrypt', enc)\n    } else if (alg) {\n      check(key, 'keyManagementEncrypt', alg)\n    } else {\n      alg = key.alg || [...key.algorithms('wrapKey')][0] || [...key.algorithms('deriveKey')][0]\n\n      if (alg === 'ECDH-ES' && recipientCount !== 1) {\n        alg = [...key.algorithms('deriveKey')][1]\n      }\n\n      if (!alg) {\n        throw new JWEInvalid('could not resolve a usable \"alg\" for a recipient')\n      }\n\n      if (recipientCount === 1) {\n        if (protectedHeader) {\n          protectedHeader.alg = alg\n        } else {\n          this._protected = { alg }\n        }\n      } else {\n        if (recipient.header) {\n          recipient.header.alg = alg\n        } else {\n          recipient.header = { alg }\n        }\n      }\n    }\n\n    let wrapped\n    let generatedHeader\n\n    if (key.kty === 'oct' && alg === 'dir') {\n      this._cek = importKey(key[KEYOBJECT], { use: 'enc', alg: enc })\n    } else {\n      check(this._cek, 'encrypt', enc)\n      ;({ wrapped, header: generatedHeader } = keyManagementEncrypt(alg, key, this._cek[KEYOBJECT].export(), { enc, alg }))\n      if (alg === 'ECDH-ES') {\n        this._cek = importKey(createSecretKey(wrapped), { use: 'enc', alg: enc })\n      }\n    }\n\n    if (alg === 'dir' || alg === 'ECDH-ES') {\n      recipient.encrypted_key = ''\n    } else {\n      recipient.encrypted_key = base64url.encodeBuffer(wrapped)\n    }\n\n    if (generatedHeader) {\n      recipient.generatedHeader = generatedHeader\n    }\n  }\n\n  /*\n   * @public\n   */\n  encrypt (serialization) {\n    const serializer = serializers[serialization]\n    if (!serializer) {\n      throw new TypeError('serialization must be one of \"compact\", \"flattened\", \"general\"')\n    }\n\n    if (!this._recipients.length) {\n      throw new JWEInvalid('missing recipients')\n    }\n\n    serializer.validate(this._protected, this._unprotected, this._aad, this._recipients)\n\n    let enc = validateHeaders(this._protected, this._unprotected, this._recipients, false, this._protected ? this._protected.crit : undefined)\n    if (!enc) {\n      enc = 'A128CBC-HS256'\n      if (this._protected) {\n        this._protected.enc = enc\n      } else {\n        this._protected = { enc }\n      }\n    }\n    const final = {}\n    this._cek = generateCEK(enc)\n\n    for (const recipient of this._recipients) {\n      this[PROCESS_RECIPIENT](recipient)\n    }\n\n    const iv = generateIV(enc)\n    final.iv = base64url.encodeBuffer(iv)\n\n    if (this._recipients.length === 1 && this._recipients[0].generatedHeader) {\n      const [{ generatedHeader }] = this._recipients\n      delete this._recipients[0].generatedHeader\n      this._protected = {\n        ...this._protected,\n        ...generatedHeader\n      }\n    }\n\n    if (this._protected) {\n      final.protected = base64url.JSON.encode(this._protected)\n    }\n    final.unprotected = this._unprotected\n\n    let aad\n    if (this._aad) {\n      final.aad = base64url.encode(this._aad)\n      aad = Buffer.concat([\n        Buffer.from(final.protected || ''),\n        Buffer.from('.'),\n        Buffer.from(final.aad)\n      ])\n    } else {\n      aad = Buffer.from(final.protected || '')\n    }\n\n    let cleartext = this._cleartext\n    if (this._protected && 'zip' in this._protected) {\n      cleartext = deflateRawSync(cleartext)\n    }\n\n    const { ciphertext, tag } = encrypt(enc, this._cek, cleartext, { iv, aad })\n    final.tag = base64url.encodeBuffer(tag)\n    final.ciphertext = base64url.encodeBuffer(ciphertext)\n\n    return serializer(final, this._recipients)\n  }\n}\n\nmodule.exports = Encrypt\n"]},"metadata":{},"sourceType":"script"}