{"ast":null,"code":"\"use strict\"; // Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fromProto3JSON = exports.fromProto3JSONToInternalRepresentation = void 0;\n\nconst assert = require(\"assert\");\n\nconst any_1 = require(\"./any\");\n\nconst bytes_1 = require(\"./bytes\");\n\nconst enum_1 = require(\"./enum\");\n\nconst value_1 = require(\"./value\");\n\nconst util_1 = require(\"./util\");\n\nconst duration_1 = require(\"./duration\");\n\nconst timestamp_1 = require(\"./timestamp\");\n\nconst wrappers_1 = require(\"./wrappers\");\n\nconst fieldmask_1 = require(\"./fieldmask\");\n\nfunction fromProto3JSONToInternalRepresentation(type, json) {\n  const fullyQualifiedTypeName = typeof type === 'string' ? type : util_1.getFullyQualifiedTypeName(type);\n\n  if (typeof type !== 'string' && 'values' in type) {\n    // type is an Enum\n    if (fullyQualifiedTypeName === '.google.protobuf.NullValue') {\n      return 'NULL_VALUE';\n    }\n\n    return enum_1.resolveEnumValueToString(type, json);\n  }\n\n  if (typeof type !== 'string') {\n    type.resolveAll();\n  }\n\n  if (typeof type === 'string') {\n    return json;\n  } // Types that require special handling according to\n  // https://developers.google.com/protocol-buffers/docs/proto3#json\n  // Types that can have meaningful \"null\" value\n\n\n  if (fullyQualifiedTypeName === '.google.protobuf.Value') {\n    return value_1.googleProtobufValueFromProto3JSON(json);\n  }\n\n  if (util_1.wrapperTypes.has(fullyQualifiedTypeName)) {\n    if (json !== null && typeof json === 'object' || Array.isArray(json)) {\n      throw new Error(`fromProto3JSONToInternalRepresentation: JSON representation for ${fullyQualifiedTypeName} expects a string, a number, or a boolean, but got ${typeof json}`);\n    }\n\n    return wrappers_1.wrapperFromProto3JSON(fullyQualifiedTypeName, json);\n  }\n\n  if (json === null) {\n    return null;\n  } // Types that cannot be \"null\"\n\n\n  if (fullyQualifiedTypeName === '.google.protobuf.Any') {\n    return any_1.googleProtobufAnyFromProto3JSON(type.root, json);\n  }\n\n  if (fullyQualifiedTypeName === '.google.protobuf.Struct') {\n    if (typeof json !== 'object') {\n      throw new Error(`fromProto3JSONToInternalRepresentation: google.protobuf.Struct must be an object but got ${typeof json}`);\n    }\n\n    if (Array.isArray(json)) {\n      throw new Error('fromProto3JSONToInternalRepresentation: google.protobuf.Struct must be an object but got an array');\n    }\n\n    return value_1.googleProtobufStructFromProto3JSON(json);\n  }\n\n  if (fullyQualifiedTypeName === '.google.protobuf.ListValue') {\n    if (!Array.isArray(json)) {\n      throw new Error(`fromProto3JSONToInternalRepresentation: google.protobuf.ListValue must be an array but got ${typeof json}`);\n    }\n\n    return value_1.googleProtobufListValueFromProto3JSON(json);\n  }\n\n  if (fullyQualifiedTypeName === '.google.protobuf.Duration') {\n    if (typeof json !== 'string') {\n      throw new Error(`fromProto3JSONToInternalRepresentation: google.protobuf.Duration must be a string but got ${typeof json}`);\n    }\n\n    return duration_1.googleProtobufDurationFromProto3JSON(json);\n  }\n\n  if (fullyQualifiedTypeName === '.google.protobuf.Timestamp') {\n    if (typeof json !== 'string') {\n      throw new Error(`fromProto3JSONToInternalRepresentation: google.protobuf.Timestamp must be a string but got ${typeof json}`);\n    }\n\n    return timestamp_1.googleProtobufTimestampFromProto3JSON(json);\n  }\n\n  if (fullyQualifiedTypeName === '.google.protobuf.FieldMask') {\n    if (typeof json !== 'string') {\n      throw new Error(`fromProto3JSONToInternalRepresentation: google.protobuf.FieldMask must be a string but got ${typeof json}`);\n    }\n\n    return fieldmask_1.googleProtobufFieldMaskFromProto3JSON(json);\n  }\n\n  const result = {};\n\n  for (const [key, value] of Object.entries(json)) {\n    const field = type.fields[key];\n\n    if (!field) {\n      continue;\n    }\n\n    const resolvedType = field.resolvedType;\n    const fieldType = field.type;\n\n    if (field.repeated) {\n      if (!Array.isArray(value)) {\n        throw new Error(`fromProto3JSONToInternalRepresentation: expected an array for field ${key}`);\n      }\n\n      result[key] = value.map(element => fromProto3JSONToInternalRepresentation(resolvedType || fieldType, element));\n    } else if (field.map) {\n      const map = {};\n\n      for (const [mapKey, mapValue] of Object.entries(value)) {\n        map[mapKey] = fromProto3JSONToInternalRepresentation(resolvedType || fieldType, mapValue);\n      }\n\n      result[key] = map;\n    } else if (fieldType.match(/^(?:(?:(?:u?int|fixed)(?:32|64))|float|double)$/)) {\n      if (typeof value !== 'number' && typeof value !== 'string') {\n        throw new Error(`fromProto3JSONToInternalRepresentation: field ${key} of type ${field.type} cannot contain value ${value}`);\n      }\n\n      result[key] = value;\n    } else if (fieldType === 'string') {\n      if (typeof value !== 'string') {\n        throw new Error(`fromProto3JSONToInternalRepresentation: field ${key} of type ${field.type} cannot contain value ${value}`);\n      }\n\n      result[key] = value;\n    } else if (fieldType === 'bool') {\n      if (typeof value !== 'boolean') {\n        throw new Error(`fromProto3JSONToInternalRepresentation: field ${key} of type ${field.type} cannot contain value ${value}`);\n      }\n\n      result[key] = value;\n    } else if (fieldType === 'bytes') {\n      if (typeof value !== 'string') {\n        throw new Error(`fromProto3JSONToInternalRepresentation: field ${key} of type ${field.type} cannot contain value ${value}`);\n      }\n\n      result[key] = bytes_1.bytesFromProto3JSON(value);\n    } else {\n      // Message type\n      assert(resolvedType, `Expected to be able to resolve type for field ${field.name}`);\n      const deserializedValue = fromProto3JSONToInternalRepresentation(resolvedType, value);\n      result[key] = deserializedValue;\n    }\n  }\n\n  return result;\n}\n\nexports.fromProto3JSONToInternalRepresentation = fromProto3JSONToInternalRepresentation;\n\nfunction fromProto3JSON(type, json) {\n  const internalRepr = fromProto3JSONToInternalRepresentation(type, json);\n\n  if (internalRepr === null) {\n    return null;\n  } // We only expect a real object here sine all special cases should be already resolved. Everything else is an internal error\n\n\n  assert(typeof internalRepr === 'object' && !Array.isArray(internalRepr), `fromProto3JSON: expected an object, not ${json}`);\n  return type.fromObject(internalRepr);\n}\n\nexports.fromProto3JSON = fromProto3JSON;","map":{"version":3,"sources":["../../typescript/src/fromproto3json.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.fromProto3JSON = exports.fromProto3JSONToInternalRepresentation = void 0;\nconst assert = require(\"assert\");\nconst any_1 = require(\"./any\");\nconst bytes_1 = require(\"./bytes\");\nconst enum_1 = require(\"./enum\");\nconst value_1 = require(\"./value\");\nconst util_1 = require(\"./util\");\nconst duration_1 = require(\"./duration\");\nconst timestamp_1 = require(\"./timestamp\");\nconst wrappers_1 = require(\"./wrappers\");\nconst fieldmask_1 = require(\"./fieldmask\");\nfunction fromProto3JSONToInternalRepresentation(type, json) {\n    const fullyQualifiedTypeName = typeof type === 'string' ? type : util_1.getFullyQualifiedTypeName(type);\n    if (typeof type !== 'string' && 'values' in type) {\n        // type is an Enum\n        if (fullyQualifiedTypeName === '.google.protobuf.NullValue') {\n            return 'NULL_VALUE';\n        }\n        return enum_1.resolveEnumValueToString(type, json);\n    }\n    if (typeof type !== 'string') {\n        type.resolveAll();\n    }\n    if (typeof type === 'string') {\n        return json;\n    }\n    // Types that require special handling according to\n    // https://developers.google.com/protocol-buffers/docs/proto3#json\n    // Types that can have meaningful \"null\" value\n    if (fullyQualifiedTypeName === '.google.protobuf.Value') {\n        return value_1.googleProtobufValueFromProto3JSON(json);\n    }\n    if (util_1.wrapperTypes.has(fullyQualifiedTypeName)) {\n        if ((json !== null && typeof json === 'object') || Array.isArray(json)) {\n            throw new Error(`fromProto3JSONToInternalRepresentation: JSON representation for ${fullyQualifiedTypeName} expects a string, a number, or a boolean, but got ${typeof json}`);\n        }\n        return wrappers_1.wrapperFromProto3JSON(fullyQualifiedTypeName, json);\n    }\n    if (json === null) {\n        return null;\n    }\n    // Types that cannot be \"null\"\n    if (fullyQualifiedTypeName === '.google.protobuf.Any') {\n        return any_1.googleProtobufAnyFromProto3JSON(type.root, json);\n    }\n    if (fullyQualifiedTypeName === '.google.protobuf.Struct') {\n        if (typeof json !== 'object') {\n            throw new Error(`fromProto3JSONToInternalRepresentation: google.protobuf.Struct must be an object but got ${typeof json}`);\n        }\n        if (Array.isArray(json)) {\n            throw new Error('fromProto3JSONToInternalRepresentation: google.protobuf.Struct must be an object but got an array');\n        }\n        return value_1.googleProtobufStructFromProto3JSON(json);\n    }\n    if (fullyQualifiedTypeName === '.google.protobuf.ListValue') {\n        if (!Array.isArray(json)) {\n            throw new Error(`fromProto3JSONToInternalRepresentation: google.protobuf.ListValue must be an array but got ${typeof json}`);\n        }\n        return value_1.googleProtobufListValueFromProto3JSON(json);\n    }\n    if (fullyQualifiedTypeName === '.google.protobuf.Duration') {\n        if (typeof json !== 'string') {\n            throw new Error(`fromProto3JSONToInternalRepresentation: google.protobuf.Duration must be a string but got ${typeof json}`);\n        }\n        return duration_1.googleProtobufDurationFromProto3JSON(json);\n    }\n    if (fullyQualifiedTypeName === '.google.protobuf.Timestamp') {\n        if (typeof json !== 'string') {\n            throw new Error(`fromProto3JSONToInternalRepresentation: google.protobuf.Timestamp must be a string but got ${typeof json}`);\n        }\n        return timestamp_1.googleProtobufTimestampFromProto3JSON(json);\n    }\n    if (fullyQualifiedTypeName === '.google.protobuf.FieldMask') {\n        if (typeof json !== 'string') {\n            throw new Error(`fromProto3JSONToInternalRepresentation: google.protobuf.FieldMask must be a string but got ${typeof json}`);\n        }\n        return fieldmask_1.googleProtobufFieldMaskFromProto3JSON(json);\n    }\n    const result = {};\n    for (const [key, value] of Object.entries(json)) {\n        const field = type.fields[key];\n        if (!field) {\n            continue;\n        }\n        const resolvedType = field.resolvedType;\n        const fieldType = field.type;\n        if (field.repeated) {\n            if (!Array.isArray(value)) {\n                throw new Error(`fromProto3JSONToInternalRepresentation: expected an array for field ${key}`);\n            }\n            result[key] = value.map(element => fromProto3JSONToInternalRepresentation(resolvedType || fieldType, element));\n        }\n        else if (field.map) {\n            const map = {};\n            for (const [mapKey, mapValue] of Object.entries(value)) {\n                map[mapKey] = fromProto3JSONToInternalRepresentation(resolvedType || fieldType, mapValue);\n            }\n            result[key] = map;\n        }\n        else if (fieldType.match(/^(?:(?:(?:u?int|fixed)(?:32|64))|float|double)$/)) {\n            if (typeof value !== 'number' && typeof value !== 'string') {\n                throw new Error(`fromProto3JSONToInternalRepresentation: field ${key} of type ${field.type} cannot contain value ${value}`);\n            }\n            result[key] = value;\n        }\n        else if (fieldType === 'string') {\n            if (typeof value !== 'string') {\n                throw new Error(`fromProto3JSONToInternalRepresentation: field ${key} of type ${field.type} cannot contain value ${value}`);\n            }\n            result[key] = value;\n        }\n        else if (fieldType === 'bool') {\n            if (typeof value !== 'boolean') {\n                throw new Error(`fromProto3JSONToInternalRepresentation: field ${key} of type ${field.type} cannot contain value ${value}`);\n            }\n            result[key] = value;\n        }\n        else if (fieldType === 'bytes') {\n            if (typeof value !== 'string') {\n                throw new Error(`fromProto3JSONToInternalRepresentation: field ${key} of type ${field.type} cannot contain value ${value}`);\n            }\n            result[key] = bytes_1.bytesFromProto3JSON(value);\n        }\n        else {\n            // Message type\n            assert(resolvedType, `Expected to be able to resolve type for field ${field.name}`);\n            const deserializedValue = fromProto3JSONToInternalRepresentation(resolvedType, value);\n            result[key] = deserializedValue;\n        }\n    }\n    return result;\n}\nexports.fromProto3JSONToInternalRepresentation = fromProto3JSONToInternalRepresentation;\nfunction fromProto3JSON(type, json) {\n    const internalRepr = fromProto3JSONToInternalRepresentation(type, json);\n    if (internalRepr === null) {\n        return null;\n    }\n    // We only expect a real object here sine all special cases should be already resolved. Everything else is an internal error\n    assert(typeof internalRepr === 'object' && !Array.isArray(internalRepr), `fromProto3JSON: expected an object, not ${json}`);\n    return type.fromObject(internalRepr);\n}\nexports.fromProto3JSON = fromProto3JSON;\n//# sourceMappingURL=fromproto3json.js.map"]},"metadata":{},"sourceType":"script"}