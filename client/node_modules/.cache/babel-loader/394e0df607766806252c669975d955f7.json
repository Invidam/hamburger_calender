{"ast":null,"code":"const {\n  createCipheriv,\n  createDecipheriv,\n  getCiphers\n} = require('crypto');\n\nconst {\n  KEYOBJECT\n} = require('../help/consts');\n\nconst {\n  asInput\n} = require('../help/key_object');\n\nconst checkInput = data => {\n  if (data !== undefined && data.length % 8 !== 0) {\n    throw new Error('invalid data length');\n  }\n};\n\nconst wrapKey = (alg, {\n  [KEYOBJECT]: keyObject\n}, payload) => {\n  const key = asInput(keyObject, false);\n  const cipher = createCipheriv(alg, key, Buffer.alloc(8, 'a6', 'hex'));\n  return {\n    wrapped: Buffer.concat([cipher.update(payload), cipher.final()])\n  };\n};\n\nconst unwrapKey = (alg, {\n  [KEYOBJECT]: keyObject\n}, payload) => {\n  const key = asInput(keyObject, false);\n  checkInput(payload);\n  const cipher = createDecipheriv(alg, key, Buffer.alloc(8, 'a6', 'hex'));\n  return Buffer.concat([cipher.update(payload), cipher.final()]);\n};\n\nmodule.exports = (JWA, JWK) => {\n  ['A128KW', 'A192KW', 'A256KW'].forEach(jwaAlg => {\n    const size = parseInt(jwaAlg.substr(1, 3), 10);\n    const alg = `aes${size}-wrap`;\n\n    if (getCiphers().includes(alg)) {\n      JWA.keyManagementEncrypt.set(jwaAlg, wrapKey.bind(undefined, alg));\n      JWA.keyManagementDecrypt.set(jwaAlg, unwrapKey.bind(undefined, alg));\n\n      JWK.oct.wrapKey[jwaAlg] = JWK.oct.unwrapKey[jwaAlg] = key => (key.use === 'enc' || key.use === undefined) && key.length === size;\n    }\n  });\n};","map":{"version":3,"sources":["/home/invidam/hamburger_calender/client/node_modules/jose/lib/jwa/aes_kw.js"],"names":["createCipheriv","createDecipheriv","getCiphers","require","KEYOBJECT","asInput","checkInput","data","undefined","length","Error","wrapKey","alg","keyObject","payload","key","cipher","Buffer","alloc","wrapped","concat","update","final","unwrapKey","module","exports","JWA","JWK","forEach","jwaAlg","size","parseInt","substr","includes","keyManagementEncrypt","set","bind","keyManagementDecrypt","oct","use"],"mappings":"AAAA,MAAM;AAAEA,EAAAA,cAAF;AAAkBC,EAAAA,gBAAlB;AAAoCC,EAAAA;AAApC,IAAmDC,OAAO,CAAC,QAAD,CAAhE;;AAEA,MAAM;AAAEC,EAAAA;AAAF,IAAgBD,OAAO,CAAC,gBAAD,CAA7B;;AACA,MAAM;AAAEE,EAAAA;AAAF,IAAcF,OAAO,CAAC,oBAAD,CAA3B;;AAEA,MAAMG,UAAU,GAAIC,IAAD,IAAU;AAC3B,MAAIA,IAAI,KAAKC,SAAT,IAAsBD,IAAI,CAACE,MAAL,GAAc,CAAd,KAAoB,CAA9C,EAAiD;AAC/C,UAAM,IAAIC,KAAJ,CAAU,qBAAV,CAAN;AACD;AACF,CAJD;;AAMA,MAAMC,OAAO,GAAG,CAACC,GAAD,EAAM;AAAE,GAACR,SAAD,GAAaS;AAAf,CAAN,EAAkCC,OAAlC,KAA8C;AAC5D,QAAMC,GAAG,GAAGV,OAAO,CAACQ,SAAD,EAAY,KAAZ,CAAnB;AACA,QAAMG,MAAM,GAAGhB,cAAc,CAACY,GAAD,EAAMG,GAAN,EAAWE,MAAM,CAACC,KAAP,CAAa,CAAb,EAAgB,IAAhB,EAAsB,KAAtB,CAAX,CAA7B;AAEA,SAAO;AAAEC,IAAAA,OAAO,EAAEF,MAAM,CAACG,MAAP,CAAc,CAACJ,MAAM,CAACK,MAAP,CAAcP,OAAd,CAAD,EAAyBE,MAAM,CAACM,KAAP,EAAzB,CAAd;AAAX,GAAP;AACD,CALD;;AAOA,MAAMC,SAAS,GAAG,CAACX,GAAD,EAAM;AAAE,GAACR,SAAD,GAAaS;AAAf,CAAN,EAAkCC,OAAlC,KAA8C;AAC9D,QAAMC,GAAG,GAAGV,OAAO,CAACQ,SAAD,EAAY,KAAZ,CAAnB;AACAP,EAAAA,UAAU,CAACQ,OAAD,CAAV;AACA,QAAME,MAAM,GAAGf,gBAAgB,CAACW,GAAD,EAAMG,GAAN,EAAWE,MAAM,CAACC,KAAP,CAAa,CAAb,EAAgB,IAAhB,EAAsB,KAAtB,CAAX,CAA/B;AAEA,SAAOD,MAAM,CAACG,MAAP,CAAc,CAACJ,MAAM,CAACK,MAAP,CAAcP,OAAd,CAAD,EAAyBE,MAAM,CAACM,KAAP,EAAzB,CAAd,CAAP;AACD,CAND;;AAQAE,MAAM,CAACC,OAAP,GAAiB,CAACC,GAAD,EAAMC,GAAN,KAAc;AAC7B,GAAC,QAAD,EAAW,QAAX,EAAqB,QAArB,EAA+BC,OAA/B,CAAwCC,MAAD,IAAY;AACjD,UAAMC,IAAI,GAAGC,QAAQ,CAACF,MAAM,CAACG,MAAP,CAAc,CAAd,EAAiB,CAAjB,CAAD,EAAsB,EAAtB,CAArB;AACA,UAAMpB,GAAG,GAAI,MAAKkB,IAAK,OAAvB;;AACA,QAAI5B,UAAU,GAAG+B,QAAb,CAAsBrB,GAAtB,CAAJ,EAAgC;AAC9Bc,MAAAA,GAAG,CAACQ,oBAAJ,CAAyBC,GAAzB,CAA6BN,MAA7B,EAAqClB,OAAO,CAACyB,IAAR,CAAa5B,SAAb,EAAwBI,GAAxB,CAArC;AACAc,MAAAA,GAAG,CAACW,oBAAJ,CAAyBF,GAAzB,CAA6BN,MAA7B,EAAqCN,SAAS,CAACa,IAAV,CAAe5B,SAAf,EAA0BI,GAA1B,CAArC;;AACAe,MAAAA,GAAG,CAACW,GAAJ,CAAQ3B,OAAR,CAAgBkB,MAAhB,IAA0BF,GAAG,CAACW,GAAJ,CAAQf,SAAR,CAAkBM,MAAlB,IAA4Bd,GAAG,IAAI,CAACA,GAAG,CAACwB,GAAJ,KAAY,KAAZ,IAAqBxB,GAAG,CAACwB,GAAJ,KAAY/B,SAAlC,KAAgDO,GAAG,CAACN,MAAJ,KAAeqB,IAA5H;AACD;AACF,GARD;AASD,CAVD","sourcesContent":["const { createCipheriv, createDecipheriv, getCiphers } = require('crypto')\n\nconst { KEYOBJECT } = require('../help/consts')\nconst { asInput } = require('../help/key_object')\n\nconst checkInput = (data) => {\n  if (data !== undefined && data.length % 8 !== 0) {\n    throw new Error('invalid data length')\n  }\n}\n\nconst wrapKey = (alg, { [KEYOBJECT]: keyObject }, payload) => {\n  const key = asInput(keyObject, false)\n  const cipher = createCipheriv(alg, key, Buffer.alloc(8, 'a6', 'hex'))\n\n  return { wrapped: Buffer.concat([cipher.update(payload), cipher.final()]) }\n}\n\nconst unwrapKey = (alg, { [KEYOBJECT]: keyObject }, payload) => {\n  const key = asInput(keyObject, false)\n  checkInput(payload)\n  const cipher = createDecipheriv(alg, key, Buffer.alloc(8, 'a6', 'hex'))\n\n  return Buffer.concat([cipher.update(payload), cipher.final()])\n}\n\nmodule.exports = (JWA, JWK) => {\n  ['A128KW', 'A192KW', 'A256KW'].forEach((jwaAlg) => {\n    const size = parseInt(jwaAlg.substr(1, 3), 10)\n    const alg = `aes${size}-wrap`\n    if (getCiphers().includes(alg)) {\n      JWA.keyManagementEncrypt.set(jwaAlg, wrapKey.bind(undefined, alg))\n      JWA.keyManagementDecrypt.set(jwaAlg, unwrapKey.bind(undefined, alg))\n      JWK.oct.wrapKey[jwaAlg] = JWK.oct.unwrapKey[jwaAlg] = key => (key.use === 'enc' || key.use === undefined) && key.length === size\n    }\n  })\n}\n"]},"metadata":{},"sourceType":"script"}