{"ast":null,"code":"const base64url = require('../help/base64url');\n\nconst isDisjoint = require('../help/is_disjoint');\n\nconst isObject = require('../help/is_object');\n\nconst deepClone = require('../help/deep_clone');\n\nconst {\n  JWSInvalid\n} = require('../errors');\n\nconst {\n  sign\n} = require('../jwa');\n\nconst getKey = require('../help/get_key');\n\nconst serializers = require('./serializers');\n\nconst PROCESS_RECIPIENT = Symbol('PROCESS_RECIPIENT');\n\nclass Sign {\n  constructor(payload) {\n    if (typeof payload === 'string') {\n      payload = base64url.encode(payload);\n    } else if (Buffer.isBuffer(payload)) {\n      payload = base64url.encodeBuffer(payload);\n      this._binary = true;\n    } else if (isObject(payload)) {\n      payload = base64url.JSON.encode(payload);\n    } else {\n      throw new TypeError('payload argument must be a Buffer, string or an object');\n    }\n\n    this._payload = payload;\n    this._recipients = [];\n  }\n  /*\n   * @public\n   */\n\n\n  recipient(key, protectedHeader, unprotectedHeader) {\n    key = getKey(key);\n\n    if (protectedHeader !== undefined && !isObject(protectedHeader)) {\n      throw new TypeError('protectedHeader argument must be a plain object when provided');\n    }\n\n    if (unprotectedHeader !== undefined && !isObject(unprotectedHeader)) {\n      throw new TypeError('unprotectedHeader argument must be a plain object when provided');\n    }\n\n    if (!isDisjoint(protectedHeader, unprotectedHeader)) {\n      throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n    }\n\n    this._recipients.push({\n      key,\n      protectedHeader: protectedHeader ? deepClone(protectedHeader) : undefined,\n      unprotectedHeader: unprotectedHeader ? deepClone(unprotectedHeader) : undefined\n    });\n\n    return this;\n  }\n  /*\n   * @private\n   */\n\n\n  [PROCESS_RECIPIENT](recipient, first) {\n    const {\n      key,\n      protectedHeader,\n      unprotectedHeader\n    } = recipient;\n\n    if (key.use === 'enc') {\n      throw new TypeError('a key with \"use\":\"enc\" is not usable for signing');\n    }\n\n    const joseHeader = {\n      protected: protectedHeader || {},\n      unprotected: unprotectedHeader || {}\n    };\n    let alg = joseHeader.protected.alg || joseHeader.unprotected.alg;\n\n    if (!alg) {\n      alg = key.alg || [...key.algorithms('sign')][0];\n\n      if (recipient.protectedHeader) {\n        joseHeader.protected.alg = recipient.protectedHeader.alg = alg;\n      } else {\n        joseHeader.protected = recipient.protectedHeader = {\n          alg\n        };\n      }\n    }\n\n    if (!alg) {\n      throw new JWSInvalid('could not resolve a usable \"alg\" for a recipient');\n    }\n\n    recipient.header = unprotectedHeader;\n    recipient.protected = Object.keys(joseHeader.protected).length ? base64url.JSON.encode(joseHeader.protected) : '';\n\n    if (first && joseHeader.protected.crit && joseHeader.protected.crit.includes('b64') && joseHeader.protected.b64 === false) {\n      if (this._binary) {\n        this._payload = base64url.decodeToBuffer(this._payload);\n      } else {\n        this._payload = base64url.decode(this._payload);\n      }\n    }\n\n    const data = Buffer.concat([Buffer.from(recipient.protected || ''), Buffer.from('.'), Buffer.from(this._payload)]);\n    recipient.signature = base64url.encodeBuffer(sign(alg, key, data));\n  }\n  /*\n   * @public\n   */\n\n\n  sign(serialization) {\n    const serializer = serializers[serialization];\n\n    if (!serializer) {\n      throw new TypeError('serialization must be one of \"compact\", \"flattened\", \"general\"');\n    }\n\n    if (!this._recipients.length) {\n      throw new JWSInvalid('missing recipients');\n    }\n\n    serializer.validate(this, this._recipients);\n\n    this._recipients.forEach((recipient, i) => {\n      this[PROCESS_RECIPIENT](recipient, i === 0);\n    });\n\n    return serializer(this._payload, this._recipients);\n  }\n\n}\n\nmodule.exports = Sign;","map":{"version":3,"sources":["/home/invidam/hamburger_calender/client/node_modules/jose/lib/jws/sign.js"],"names":["base64url","require","isDisjoint","isObject","deepClone","JWSInvalid","sign","getKey","serializers","PROCESS_RECIPIENT","Symbol","Sign","constructor","payload","encode","Buffer","isBuffer","encodeBuffer","_binary","JSON","TypeError","_payload","_recipients","recipient","key","protectedHeader","unprotectedHeader","undefined","push","first","use","joseHeader","protected","unprotected","alg","algorithms","header","Object","keys","length","crit","includes","b64","decodeToBuffer","decode","data","concat","from","signature","serialization","serializer","validate","forEach","i","module","exports"],"mappings":"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","sourcesContent":["const base64url = require('../help/base64url')\nconst isDisjoint = require('../help/is_disjoint')\nconst isObject = require('../help/is_object')\nconst deepClone = require('../help/deep_clone')\nconst { JWSInvalid } = require('../errors')\nconst { sign } = require('../jwa')\nconst getKey = require('../help/get_key')\n\nconst serializers = require('./serializers')\n\nconst PROCESS_RECIPIENT = Symbol('PROCESS_RECIPIENT')\n\nclass Sign {\n  constructor (payload) {\n    if (typeof payload === 'string') {\n      payload = base64url.encode(payload)\n    } else if (Buffer.isBuffer(payload)) {\n      payload = base64url.encodeBuffer(payload)\n      this._binary = true\n    } else if (isObject(payload)) {\n      payload = base64url.JSON.encode(payload)\n    } else {\n      throw new TypeError('payload argument must be a Buffer, string or an object')\n    }\n\n    this._payload = payload\n    this._recipients = []\n  }\n\n  /*\n   * @public\n   */\n  recipient (key, protectedHeader, unprotectedHeader) {\n    key = getKey(key)\n\n    if (protectedHeader !== undefined && !isObject(protectedHeader)) {\n      throw new TypeError('protectedHeader argument must be a plain object when provided')\n    }\n\n    if (unprotectedHeader !== undefined && !isObject(unprotectedHeader)) {\n      throw new TypeError('unprotectedHeader argument must be a plain object when provided')\n    }\n\n    if (!isDisjoint(protectedHeader, unprotectedHeader)) {\n      throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint')\n    }\n\n    this._recipients.push({\n      key,\n      protectedHeader: protectedHeader ? deepClone(protectedHeader) : undefined,\n      unprotectedHeader: unprotectedHeader ? deepClone(unprotectedHeader) : undefined\n    })\n\n    return this\n  }\n\n  /*\n   * @private\n   */\n  [PROCESS_RECIPIENT] (recipient, first) {\n    const { key, protectedHeader, unprotectedHeader } = recipient\n\n    if (key.use === 'enc') {\n      throw new TypeError('a key with \"use\":\"enc\" is not usable for signing')\n    }\n\n    const joseHeader = {\n      protected: protectedHeader || {},\n      unprotected: unprotectedHeader || {}\n    }\n\n    let alg = joseHeader.protected.alg || joseHeader.unprotected.alg\n\n    if (!alg) {\n      alg = key.alg || [...key.algorithms('sign')][0]\n      if (recipient.protectedHeader) {\n        joseHeader.protected.alg = recipient.protectedHeader.alg = alg\n      } else {\n        joseHeader.protected = recipient.protectedHeader = { alg }\n      }\n    }\n\n    if (!alg) {\n      throw new JWSInvalid('could not resolve a usable \"alg\" for a recipient')\n    }\n\n    recipient.header = unprotectedHeader\n    recipient.protected = Object.keys(joseHeader.protected).length ? base64url.JSON.encode(joseHeader.protected) : ''\n\n    if (first && joseHeader.protected.crit && joseHeader.protected.crit.includes('b64') && joseHeader.protected.b64 === false) {\n      if (this._binary) {\n        this._payload = base64url.decodeToBuffer(this._payload)\n      } else {\n        this._payload = base64url.decode(this._payload)\n      }\n    }\n\n    const data = Buffer.concat([\n      Buffer.from(recipient.protected || ''),\n      Buffer.from('.'),\n      Buffer.from(this._payload)\n    ])\n\n    recipient.signature = base64url.encodeBuffer(sign(alg, key, data))\n  }\n\n  /*\n   * @public\n   */\n  sign (serialization) {\n    const serializer = serializers[serialization]\n    if (!serializer) {\n      throw new TypeError('serialization must be one of \"compact\", \"flattened\", \"general\"')\n    }\n\n    if (!this._recipients.length) {\n      throw new JWSInvalid('missing recipients')\n    }\n\n    serializer.validate(this, this._recipients)\n\n    this._recipients.forEach((recipient, i) => {\n      this[PROCESS_RECIPIENT](recipient, i === 0)\n    })\n\n    return serializer(this._payload, this._recipients)\n  }\n}\n\nmodule.exports = Sign\n"]},"metadata":{},"sourceType":"script"}