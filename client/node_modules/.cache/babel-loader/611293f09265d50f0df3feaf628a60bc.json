{"ast":null,"code":"const {\n  randomBytes\n} = require('crypto');\n\nconst base64url = require('./base64url');\n\nconst errors = require('../errors');\n\nconst ZERO = BigInt(0);\nconst ONE = BigInt(1);\nconst TWO = BigInt(2);\n\nconst toJWKParameter = n => {\n  const hex = n.toString(16);\n  return base64url.encodeBuffer(Buffer.from(hex.length % 2 ? `0${hex}` : hex, 'hex'));\n};\n\nconst fromBuffer = buf => BigInt(`0x${buf.toString('hex')}`);\n\nconst bitLength = n => n.toString(2).length;\n\nconst eGcdX = (a, b) => {\n  let x = ZERO;\n  let y = ONE;\n  let u = ONE;\n  let v = ZERO;\n\n  while (a !== ZERO) {\n    const q = b / a;\n    const r = b % a;\n    const m = x - u * q;\n    const n = y - v * q;\n    b = a;\n    a = r;\n    x = u;\n    y = v;\n    u = m;\n    v = n;\n  }\n\n  return x;\n};\n\nconst gcd = (a, b) => {\n  let shift = ZERO;\n\n  while (!((a | b) & ONE)) {\n    a >>= ONE;\n    b >>= ONE;\n    shift++;\n  }\n\n  while (!(a & ONE)) {\n    a >>= ONE;\n  }\n\n  do {\n    while (!(b & ONE)) {\n      b >>= ONE;\n    }\n\n    if (a > b) {\n      const x = a;\n      a = b;\n      b = x;\n    }\n\n    b -= a;\n  } while (b);\n\n  return a << shift;\n};\n\nconst modPow = (a, b, n) => {\n  a = toZn(a, n);\n  let result = ONE;\n  let x = a;\n\n  while (b > 0) {\n    const leastSignificantBit = b % TWO;\n    b = b / TWO;\n\n    if (leastSignificantBit === ONE) {\n      result = result * x;\n      result = result % n;\n    }\n\n    x = x * x;\n    x = x % n;\n  }\n\n  return result;\n};\n\nconst randBetween = (min, max) => {\n  const interval = max - min;\n  const bitLen = bitLength(interval);\n  let rnd;\n\n  do {\n    rnd = fromBuffer(randBits(bitLen));\n  } while (rnd > interval);\n\n  return rnd + min;\n};\n\nconst randBits = bitLength => {\n  const byteLength = Math.ceil(bitLength / 8);\n  const rndBytes = randomBytes(byteLength); // Fill with 0's the extra bits\n\n  rndBytes[0] = rndBytes[0] & 2 ** (bitLength % 8) - 1;\n  return rndBytes;\n};\n\nconst toZn = (a, n) => {\n  a = a % n;\n  return a < 0 ? a + n : a;\n};\n\nconst odd = n => {\n  let r = n;\n\n  while (r % TWO === ZERO) {\n    r = r / TWO;\n  }\n\n  return r;\n}; // not sold on these values\n\n\nconst maxCountWhileNoY = 30;\nconst maxCountWhileInot0 = 22;\n\nconst getPrimeFactors = (e, d, n) => {\n  const r = odd(e * d - ONE);\n  let countWhileNoY = 0;\n  let y;\n\n  do {\n    countWhileNoY++;\n\n    if (countWhileNoY === maxCountWhileNoY) {\n      throw new errors.JWKImportFailed('failed to calculate missing primes');\n    }\n\n    let countWhileInot0 = 0;\n    let i = modPow(randBetween(TWO, n), r, n);\n    let o = ZERO;\n\n    while (i !== ONE) {\n      countWhileInot0++;\n\n      if (countWhileInot0 === maxCountWhileInot0) {\n        throw new errors.JWKImportFailed('failed to calculate missing primes');\n      }\n\n      o = i;\n      i = i * i % n;\n    }\n\n    if (o !== n - ONE) {\n      y = o;\n    }\n  } while (!y);\n\n  const p = gcd(y - ONE, n);\n  const q = n / p;\n  return p > q ? {\n    p,\n    q\n  } : {\n    p: q,\n    q: p\n  };\n};\n\nmodule.exports = jwk => {\n  const e = fromBuffer(base64url.decodeToBuffer(jwk.e));\n  const d = fromBuffer(base64url.decodeToBuffer(jwk.d));\n  const n = fromBuffer(base64url.decodeToBuffer(jwk.n));\n\n  if (d >= n) {\n    throw new errors.JWKInvalid('invalid RSA private exponent');\n  }\n\n  const {\n    p,\n    q\n  } = getPrimeFactors(e, d, n);\n  const dp = d % (p - ONE);\n  const dq = d % (q - ONE);\n  const qi = toZn(eGcdX(toZn(q, p), p), p);\n  return { ...jwk,\n    p: toJWKParameter(p),\n    q: toJWKParameter(q),\n    dp: toJWKParameter(dp),\n    dq: toJWKParameter(dq),\n    qi: toJWKParameter(qi)\n  };\n};","map":{"version":3,"sources":["/home/invidam/hamburger_calender/client/node_modules/jose/lib/help/rsa_primes.js"],"names":["randomBytes","require","base64url","errors","ZERO","BigInt","ONE","TWO","toJWKParameter","n","hex","toString","encodeBuffer","Buffer","from","length","fromBuffer","buf","bitLength","eGcdX","a","b","x","y","u","v","q","r","m","gcd","shift","modPow","toZn","result","leastSignificantBit","randBetween","min","max","interval","bitLen","rnd","randBits","byteLength","Math","ceil","rndBytes","odd","maxCountWhileNoY","maxCountWhileInot0","getPrimeFactors","e","d","countWhileNoY","JWKImportFailed","countWhileInot0","i","o","p","module","exports","jwk","decodeToBuffer","JWKInvalid","dp","dq","qi"],"mappings":"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","sourcesContent":["const { randomBytes } = require('crypto')\n\nconst base64url = require('./base64url')\nconst errors = require('../errors')\n\nconst ZERO = BigInt(0)\nconst ONE = BigInt(1)\nconst TWO = BigInt(2)\n\nconst toJWKParameter = (n) => {\n  const hex = n.toString(16)\n  return base64url.encodeBuffer(Buffer.from(hex.length % 2 ? `0${hex}` : hex, 'hex'))\n}\nconst fromBuffer = buf => BigInt(`0x${buf.toString('hex')}`)\nconst bitLength = n => n.toString(2).length\n\nconst eGcdX = (a, b) => {\n  let x = ZERO\n  let y = ONE\n  let u = ONE\n  let v = ZERO\n\n  while (a !== ZERO) {\n    const q = b / a\n    const r = b % a\n    const m = x - (u * q)\n    const n = y - (v * q)\n    b = a\n    a = r\n    x = u\n    y = v\n    u = m\n    v = n\n  }\n  return x\n}\n\nconst gcd = (a, b) => {\n  let shift = ZERO\n  while (!((a | b) & ONE)) {\n    a >>= ONE\n    b >>= ONE\n    shift++\n  }\n  while (!(a & ONE)) {\n    a >>= ONE\n  }\n  do {\n    while (!(b & ONE)) {\n      b >>= ONE\n    }\n    if (a > b) {\n      const x = a\n      a = b\n      b = x\n    }\n    b -= a\n  } while (b)\n\n  return a << shift\n}\n\nconst modPow = (a, b, n) => {\n  a = toZn(a, n)\n  let result = ONE\n  let x = a\n  while (b > 0) {\n    const leastSignificantBit = b % TWO\n    b = b / TWO\n    if (leastSignificantBit === ONE) {\n      result = result * x\n      result = result % n\n    }\n    x = x * x\n    x = x % n\n  }\n  return result\n}\n\nconst randBetween = (min, max) => {\n  const interval = max - min\n  const bitLen = bitLength(interval)\n  let rnd\n  do {\n    rnd = fromBuffer(randBits(bitLen))\n  } while (rnd > interval)\n  return rnd + min\n}\n\nconst randBits = (bitLength) => {\n  const byteLength = Math.ceil(bitLength / 8)\n  const rndBytes = randomBytes(byteLength)\n  // Fill with 0's the extra bits\n  rndBytes[0] = rndBytes[0] & (2 ** (bitLength % 8) - 1)\n  return rndBytes\n}\n\nconst toZn = (a, n) => {\n  a = a % n\n  return (a < 0) ? a + n : a\n}\n\nconst odd = (n) => {\n  let r = n\n  while (r % TWO === ZERO) {\n    r = r / TWO\n  }\n  return r\n}\n\n// not sold on these values\nconst maxCountWhileNoY = 30\nconst maxCountWhileInot0 = 22\n\nconst getPrimeFactors = (e, d, n) => {\n  const r = odd(e * d - ONE)\n\n  let countWhileNoY = 0\n  let y\n  do {\n    countWhileNoY++\n    if (countWhileNoY === maxCountWhileNoY) {\n      throw new errors.JWKImportFailed('failed to calculate missing primes')\n    }\n\n    let countWhileInot0 = 0\n    let i = modPow(randBetween(TWO, n), r, n)\n    let o = ZERO\n    while (i !== ONE) {\n      countWhileInot0++\n      if (countWhileInot0 === maxCountWhileInot0) {\n        throw new errors.JWKImportFailed('failed to calculate missing primes')\n      }\n      o = i\n      i = (i * i) % n\n    }\n    if (o !== (n - ONE)) {\n      y = o\n    }\n  } while (!y)\n\n  const p = gcd(y - ONE, n)\n  const q = n / p\n\n  return p > q ? { p, q } : { p: q, q: p }\n}\n\nmodule.exports = (jwk) => {\n  const e = fromBuffer(base64url.decodeToBuffer(jwk.e))\n  const d = fromBuffer(base64url.decodeToBuffer(jwk.d))\n  const n = fromBuffer(base64url.decodeToBuffer(jwk.n))\n\n  if (d >= n) {\n    throw new errors.JWKInvalid('invalid RSA private exponent')\n  }\n\n  const { p, q } = getPrimeFactors(e, d, n)\n  const dp = d % (p - ONE)\n  const dq = d % (q - ONE)\n  const qi = toZn(eGcdX(toZn(q, p), p), p)\n\n  return {\n    ...jwk,\n    p: toJWKParameter(p),\n    q: toJWKParameter(q),\n    dp: toJWKParameter(dp),\n    dq: toJWKParameter(dq),\n    qi: toJWKParameter(qi)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}