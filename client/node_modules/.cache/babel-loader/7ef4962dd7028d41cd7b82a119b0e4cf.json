{"ast":null,"code":"const MAX_OCTET = 0x80;\nconst CLASS_UNIVERSAL = 0;\nconst PRIMITIVE_BIT = 0x20;\nconst TAG_SEQ = 0x10;\nconst TAG_INT = 0x02;\nconst ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6;\nconst ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;\n\nconst getParamSize = keySize => (keySize / 8 | 0) + (keySize % 8 === 0 ? 0 : 1);\n\nconst paramBytesForAlg = {\n  ES256: getParamSize(256),\n  ES256K: getParamSize(256),\n  ES384: getParamSize(384),\n  ES512: getParamSize(521)\n};\n\nconst countPadding = (buf, start, stop) => {\n  let padding = 0;\n\n  while (start + padding < stop && buf[start + padding] === 0) {\n    ++padding;\n  }\n\n  const needsSign = buf[start + padding] >= MAX_OCTET;\n\n  if (needsSign) {\n    --padding;\n  }\n\n  return padding;\n};\n\nmodule.exports.derToJose = (signature, alg) => {\n  if (!Buffer.isBuffer(signature)) {\n    throw new TypeError('ECDSA signature must be a Buffer');\n  }\n\n  if (!paramBytesForAlg[alg]) {\n    throw new Error(`Unknown algorithm \"${alg}\"`);\n  }\n\n  const paramBytes = paramBytesForAlg[alg]; // the DER encoded param should at most be the param size, plus a padding\n  // zero, since due to being a signed integer\n\n  const maxEncodedParamLength = paramBytes + 1;\n  const inputLength = signature.length;\n  let offset = 0;\n\n  if (signature[offset++] !== ENCODED_TAG_SEQ) {\n    throw new Error('Could not find expected \"seq\"');\n  }\n\n  let seqLength = signature[offset++];\n\n  if (seqLength === (MAX_OCTET | 1)) {\n    seqLength = signature[offset++];\n  }\n\n  if (inputLength - offset < seqLength) {\n    throw new Error(`\"seq\" specified length of ${seqLength}\", only ${inputLength - offset}\" remaining`);\n  }\n\n  if (signature[offset++] !== ENCODED_TAG_INT) {\n    throw new Error('Could not find expected \"int\" for \"r\"');\n  }\n\n  const rLength = signature[offset++];\n\n  if (inputLength - offset - 2 < rLength) {\n    throw new Error(`\"r\" specified length of \"${rLength}\", only \"${inputLength - offset - 2}\" available`);\n  }\n\n  if (maxEncodedParamLength < rLength) {\n    throw new Error(`\"r\" specified length of \"${rLength}\", max of \"${maxEncodedParamLength}\" is acceptable`);\n  }\n\n  const rOffset = offset;\n  offset += rLength;\n\n  if (signature[offset++] !== ENCODED_TAG_INT) {\n    throw new Error('Could not find expected \"int\" for \"s\"');\n  }\n\n  const sLength = signature[offset++];\n\n  if (inputLength - offset !== sLength) {\n    throw new Error(`\"s\" specified length of \"${sLength}\", expected \"${inputLength - offset}\"`);\n  }\n\n  if (maxEncodedParamLength < sLength) {\n    throw new Error(`\"s\" specified length of \"${sLength}\", max of \"${maxEncodedParamLength}\" is acceptable`);\n  }\n\n  const sOffset = offset;\n  offset += sLength;\n\n  if (offset !== inputLength) {\n    throw new Error(`Expected to consume entire buffer, but \"${inputLength - offset}\" bytes remain`);\n  }\n\n  const rPadding = paramBytes - rLength;\n  const sPadding = paramBytes - sLength;\n  const dst = Buffer.allocUnsafe(rPadding + rLength + sPadding + sLength);\n\n  for (offset = 0; offset < rPadding; ++offset) {\n    dst[offset] = 0;\n  }\n\n  signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);\n  offset = paramBytes;\n\n  for (const o = offset; offset < o + sPadding; ++offset) {\n    dst[offset] = 0;\n  }\n\n  signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);\n  return dst;\n};\n\nmodule.exports.joseToDer = (signature, alg) => {\n  if (!Buffer.isBuffer(signature)) {\n    throw new TypeError('ECDSA signature must be a Buffer');\n  }\n\n  if (!paramBytesForAlg[alg]) {\n    throw new TypeError(`Unknown algorithm \"${alg}\"`);\n  }\n\n  const paramBytes = paramBytesForAlg[alg];\n  const signatureBytes = signature.length;\n\n  if (signatureBytes !== paramBytes * 2) {\n    throw new Error(`\"${alg}\" signatures must be \"${paramBytes * 2}\" bytes, saw \"${signatureBytes}\"`);\n  }\n\n  const rPadding = countPadding(signature, 0, paramBytes);\n  const sPadding = countPadding(signature, paramBytes, signature.length);\n  const rLength = paramBytes - rPadding;\n  const sLength = paramBytes - sPadding;\n  const rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;\n  const shortLength = rsBytes < MAX_OCTET;\n  const dst = Buffer.allocUnsafe((shortLength ? 2 : 3) + rsBytes);\n  let offset = 0;\n  dst[offset++] = ENCODED_TAG_SEQ;\n\n  if (shortLength) {\n    // Bit 8 has value \"0\"\n    // bits 7-1 give the length.\n    dst[offset++] = rsBytes;\n  } else {\n    // Bit 8 of first octet has value \"1\"\n    // bits 7-1 give the number of additional length octets.\n    dst[offset++] = MAX_OCTET | 1; // eslint-disable-line no-tabs\n    // length, base 256\n\n    dst[offset++] = rsBytes & 0xff;\n  }\n\n  dst[offset++] = ENCODED_TAG_INT;\n  dst[offset++] = rLength;\n\n  if (rPadding < 0) {\n    dst[offset++] = 0;\n    offset += signature.copy(dst, offset, 0, paramBytes);\n  } else {\n    offset += signature.copy(dst, offset, rPadding, paramBytes);\n  }\n\n  dst[offset++] = ENCODED_TAG_INT;\n  dst[offset++] = sLength;\n\n  if (sPadding < 0) {\n    dst[offset++] = 0;\n    signature.copy(dst, offset, paramBytes);\n  } else {\n    signature.copy(dst, offset, paramBytes + sPadding);\n  }\n\n  return dst;\n};","map":{"version":3,"sources":["/home/invidam/hamburger_calender/client/node_modules/jose/lib/help/ecdsa_signatures.js"],"names":["MAX_OCTET","CLASS_UNIVERSAL","PRIMITIVE_BIT","TAG_SEQ","TAG_INT","ENCODED_TAG_SEQ","ENCODED_TAG_INT","getParamSize","keySize","paramBytesForAlg","ES256","ES256K","ES384","ES512","countPadding","buf","start","stop","padding","needsSign","module","exports","derToJose","signature","alg","Buffer","isBuffer","TypeError","Error","paramBytes","maxEncodedParamLength","inputLength","length","offset","seqLength","rLength","rOffset","sLength","sOffset","rPadding","sPadding","dst","allocUnsafe","copy","Math","max","o","joseToDer","signatureBytes","rsBytes","shortLength"],"mappings":"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","sourcesContent":["const MAX_OCTET = 0x80\nconst CLASS_UNIVERSAL = 0\nconst PRIMITIVE_BIT = 0x20\nconst TAG_SEQ = 0x10\nconst TAG_INT = 0x02\nconst ENCODED_TAG_SEQ = (TAG_SEQ | PRIMITIVE_BIT) | (CLASS_UNIVERSAL << 6)\nconst ENCODED_TAG_INT = TAG_INT | (CLASS_UNIVERSAL << 6)\n\nconst getParamSize = keySize => ((keySize / 8) | 0) + (keySize % 8 === 0 ? 0 : 1)\n\nconst paramBytesForAlg = {\n  ES256: getParamSize(256),\n  ES256K: getParamSize(256),\n  ES384: getParamSize(384),\n  ES512: getParamSize(521)\n}\n\nconst countPadding = (buf, start, stop) => {\n  let padding = 0\n  while (start + padding < stop && buf[start + padding] === 0) {\n    ++padding\n  }\n\n  const needsSign = buf[start + padding] >= MAX_OCTET\n  if (needsSign) {\n    --padding\n  }\n\n  return padding\n}\n\nmodule.exports.derToJose = (signature, alg) => {\n  if (!Buffer.isBuffer(signature)) {\n    throw new TypeError('ECDSA signature must be a Buffer')\n  }\n\n  if (!paramBytesForAlg[alg]) {\n    throw new Error(`Unknown algorithm \"${alg}\"`)\n  }\n\n  const paramBytes = paramBytesForAlg[alg]\n\n  // the DER encoded param should at most be the param size, plus a padding\n  // zero, since due to being a signed integer\n  const maxEncodedParamLength = paramBytes + 1\n\n  const inputLength = signature.length\n\n  let offset = 0\n  if (signature[offset++] !== ENCODED_TAG_SEQ) {\n    throw new Error('Could not find expected \"seq\"')\n  }\n\n  let seqLength = signature[offset++]\n  if (seqLength === (MAX_OCTET | 1)) {\n    seqLength = signature[offset++]\n  }\n\n  if (inputLength - offset < seqLength) {\n    throw new Error(`\"seq\" specified length of ${seqLength}\", only ${inputLength - offset}\" remaining`)\n  }\n\n  if (signature[offset++] !== ENCODED_TAG_INT) {\n    throw new Error('Could not find expected \"int\" for \"r\"')\n  }\n\n  const rLength = signature[offset++]\n\n  if (inputLength - offset - 2 < rLength) {\n    throw new Error(`\"r\" specified length of \"${rLength}\", only \"${inputLength - offset - 2}\" available`)\n  }\n\n  if (maxEncodedParamLength < rLength) {\n    throw new Error(`\"r\" specified length of \"${rLength}\", max of \"${maxEncodedParamLength}\" is acceptable`)\n  }\n\n  const rOffset = offset\n  offset += rLength\n\n  if (signature[offset++] !== ENCODED_TAG_INT) {\n    throw new Error('Could not find expected \"int\" for \"s\"')\n  }\n\n  const sLength = signature[offset++]\n\n  if (inputLength - offset !== sLength) {\n    throw new Error(`\"s\" specified length of \"${sLength}\", expected \"${inputLength - offset}\"`)\n  }\n\n  if (maxEncodedParamLength < sLength) {\n    throw new Error(`\"s\" specified length of \"${sLength}\", max of \"${maxEncodedParamLength}\" is acceptable`)\n  }\n\n  const sOffset = offset\n  offset += sLength\n\n  if (offset !== inputLength) {\n    throw new Error(`Expected to consume entire buffer, but \"${inputLength - offset}\" bytes remain`)\n  }\n\n  const rPadding = paramBytes - rLength\n\n  const sPadding = paramBytes - sLength\n\n  const dst = Buffer.allocUnsafe(rPadding + rLength + sPadding + sLength)\n\n  for (offset = 0; offset < rPadding; ++offset) {\n    dst[offset] = 0\n  }\n  signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength)\n\n  offset = paramBytes\n\n  for (const o = offset; offset < o + sPadding; ++offset) {\n    dst[offset] = 0\n  }\n  signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength)\n\n  return dst\n}\n\nmodule.exports.joseToDer = (signature, alg) => {\n  if (!Buffer.isBuffer(signature)) {\n    throw new TypeError('ECDSA signature must be a Buffer')\n  }\n\n  if (!paramBytesForAlg[alg]) {\n    throw new TypeError(`Unknown algorithm \"${alg}\"`)\n  }\n\n  const paramBytes = paramBytesForAlg[alg]\n\n  const signatureBytes = signature.length\n  if (signatureBytes !== paramBytes * 2) {\n    throw new Error(`\"${alg}\" signatures must be \"${paramBytes * 2}\" bytes, saw \"${signatureBytes}\"`)\n  }\n\n  const rPadding = countPadding(signature, 0, paramBytes)\n  const sPadding = countPadding(signature, paramBytes, signature.length)\n  const rLength = paramBytes - rPadding\n  const sLength = paramBytes - sPadding\n\n  const rsBytes = 1 + 1 + rLength + 1 + 1 + sLength\n\n  const shortLength = rsBytes < MAX_OCTET\n\n  const dst = Buffer.allocUnsafe((shortLength ? 2 : 3) + rsBytes)\n\n  let offset = 0\n  dst[offset++] = ENCODED_TAG_SEQ\n  if (shortLength) {\n    // Bit 8 has value \"0\"\n    // bits 7-1 give the length.\n    dst[offset++] = rsBytes\n  } else {\n    // Bit 8 of first octet has value \"1\"\n    // bits 7-1 give the number of additional length octets.\n    dst[offset++] = MAX_OCTET\t| 1 // eslint-disable-line no-tabs\n    // length, base 256\n    dst[offset++] = rsBytes & 0xff\n  }\n  dst[offset++] = ENCODED_TAG_INT\n  dst[offset++] = rLength\n  if (rPadding < 0) {\n    dst[offset++] = 0\n    offset += signature.copy(dst, offset, 0, paramBytes)\n  } else {\n    offset += signature.copy(dst, offset, rPadding, paramBytes)\n  }\n  dst[offset++] = ENCODED_TAG_INT\n  dst[offset++] = sLength\n  if (sPadding < 0) {\n    dst[offset++] = 0\n    signature.copy(dst, offset, paramBytes)\n  } else {\n    signature.copy(dst, offset, paramBytes + sPadding)\n  }\n\n  return dst\n}\n"]},"metadata":{},"sourceType":"script"}