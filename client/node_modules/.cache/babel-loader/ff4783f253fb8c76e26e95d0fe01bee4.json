{"ast":null,"code":"const {\n  JOSECritNotUnderstood,\n  JWSInvalid\n} = require('../errors');\n\nconst DEFINED = new Set(['alg', 'jku', 'jwk', 'kid', 'x5u', 'x5c', 'x5t', 'x5t#S256', 'typ', 'cty', 'crit', 'enc', 'zip', 'epk', 'apu', 'apv', 'iv', 'tag', 'p2s', 'p2c']);\n\nmodule.exports = function validateCrit(Err, protectedHeader, unprotectedHeader, understood) {\n  if (protectedHeader && 'crit' in protectedHeader) {\n    if (!Array.isArray(protectedHeader.crit) || protectedHeader.crit.length === 0 || protectedHeader.crit.some(s => typeof s !== 'string' || !s)) {\n      throw new Err('\"crit\" Header Parameter MUST be an array of non-empty strings when present');\n    }\n\n    const whitelisted = new Set(understood);\n    const combined = { ...protectedHeader,\n      ...unprotectedHeader\n    };\n    protectedHeader.crit.forEach(parameter => {\n      if (DEFINED.has(parameter)) {\n        throw new Err(`The critical list contains a non-extension Header Parameter ${parameter}`);\n      }\n\n      if (!whitelisted.has(parameter)) {\n        throw new JOSECritNotUnderstood(`critical \"${parameter}\" is not understood`);\n      }\n\n      if (parameter === 'b64') {\n        if (!('b64' in protectedHeader)) {\n          throw new JWSInvalid('\"b64\" critical parameter must be integrity protected');\n        }\n\n        if (typeof protectedHeader.b64 !== 'boolean') {\n          throw new JWSInvalid('\"b64\" critical parameter must be a boolean');\n        }\n      } else if (!(parameter in combined)) {\n        throw new Err(`critical parameter \"${parameter}\" is missing`);\n      }\n    });\n  }\n\n  if (unprotectedHeader && 'crit' in unprotectedHeader) {\n    throw new Err('\"crit\" Header Parameter MUST be integrity protected when present');\n  }\n};","map":{"version":3,"sources":["/home/invidam/hamburger_calender/client/node_modules/jose/lib/help/validate_crit.js"],"names":["JOSECritNotUnderstood","JWSInvalid","require","DEFINED","Set","module","exports","validateCrit","Err","protectedHeader","unprotectedHeader","understood","Array","isArray","crit","length","some","s","whitelisted","combined","forEach","parameter","has","b64"],"mappings":"AAAA,MAAM;AAAEA,EAAAA,qBAAF;AAAyBC,EAAAA;AAAzB,IAAwCC,OAAO,CAAC,WAAD,CAArD;;AAEA,MAAMC,OAAO,GAAG,IAAIC,GAAJ,CAAQ,CACtB,KADsB,EACf,KADe,EACR,KADQ,EACD,KADC,EACM,KADN,EACa,KADb,EACoB,KADpB,EAC2B,UAD3B,EACuC,KADvC,EAC8C,KAD9C,EAEtB,MAFsB,EAEd,KAFc,EAEP,KAFO,EAEA,KAFA,EAEO,KAFP,EAEc,KAFd,EAEqB,IAFrB,EAE2B,KAF3B,EAEkC,KAFlC,EAEyC,KAFzC,CAAR,CAAhB;;AAKAC,MAAM,CAACC,OAAP,GAAiB,SAASC,YAAT,CAAuBC,GAAvB,EAA4BC,eAA5B,EAA6CC,iBAA7C,EAAgEC,UAAhE,EAA4E;AAC3F,MAAIF,eAAe,IAAI,UAAUA,eAAjC,EAAkD;AAChD,QACE,CAACG,KAAK,CAACC,OAAN,CAAcJ,eAAe,CAACK,IAA9B,CAAD,IACAL,eAAe,CAACK,IAAhB,CAAqBC,MAArB,KAAgC,CADhC,IAEAN,eAAe,CAACK,IAAhB,CAAqBE,IAArB,CAA0BC,CAAC,IAAI,OAAOA,CAAP,KAAa,QAAb,IAAyB,CAACA,CAAzD,CAHF,EAIE;AACA,YAAM,IAAIT,GAAJ,CAAQ,4EAAR,CAAN;AACD;;AACD,UAAMU,WAAW,GAAG,IAAId,GAAJ,CAAQO,UAAR,CAApB;AACA,UAAMQ,QAAQ,GAAG,EAAE,GAAGV,eAAL;AAAsB,SAAGC;AAAzB,KAAjB;AACAD,IAAAA,eAAe,CAACK,IAAhB,CAAqBM,OAArB,CAA8BC,SAAD,IAAe;AAC1C,UAAIlB,OAAO,CAACmB,GAAR,CAAYD,SAAZ,CAAJ,EAA4B;AAC1B,cAAM,IAAIb,GAAJ,CAAS,+DAA8Da,SAAU,EAAjF,CAAN;AACD;;AACD,UAAI,CAACH,WAAW,CAACI,GAAZ,CAAgBD,SAAhB,CAAL,EAAiC;AAC/B,cAAM,IAAIrB,qBAAJ,CAA2B,aAAYqB,SAAU,qBAAjD,CAAN;AACD;;AACD,UAAIA,SAAS,KAAK,KAAlB,EAAyB;AACvB,YAAI,EAAE,SAASZ,eAAX,CAAJ,EAAiC;AAC/B,gBAAM,IAAIR,UAAJ,CAAe,sDAAf,CAAN;AACD;;AACD,YAAI,OAAOQ,eAAe,CAACc,GAAvB,KAA+B,SAAnC,EAA8C;AAC5C,gBAAM,IAAItB,UAAJ,CAAe,4CAAf,CAAN;AACD;AACF,OAPD,MAOO,IAAI,EAAEoB,SAAS,IAAIF,QAAf,CAAJ,EAA8B;AACnC,cAAM,IAAIX,GAAJ,CAAS,uBAAsBa,SAAU,cAAzC,CAAN;AACD;AACF,KAjBD;AAkBD;;AACD,MAAIX,iBAAiB,IAAI,UAAUA,iBAAnC,EAAsD;AACpD,UAAM,IAAIF,GAAJ,CAAQ,kEAAR,CAAN;AACD;AACF,CAjCD","sourcesContent":["const { JOSECritNotUnderstood, JWSInvalid } = require('../errors')\n\nconst DEFINED = new Set([\n  'alg', 'jku', 'jwk', 'kid', 'x5u', 'x5c', 'x5t', 'x5t#S256', 'typ', 'cty',\n  'crit', 'enc', 'zip', 'epk', 'apu', 'apv', 'iv', 'tag', 'p2s', 'p2c'\n])\n\nmodule.exports = function validateCrit (Err, protectedHeader, unprotectedHeader, understood) {\n  if (protectedHeader && 'crit' in protectedHeader) {\n    if (\n      !Array.isArray(protectedHeader.crit) ||\n      protectedHeader.crit.length === 0 ||\n      protectedHeader.crit.some(s => typeof s !== 'string' || !s)\n    ) {\n      throw new Err('\"crit\" Header Parameter MUST be an array of non-empty strings when present')\n    }\n    const whitelisted = new Set(understood)\n    const combined = { ...protectedHeader, ...unprotectedHeader }\n    protectedHeader.crit.forEach((parameter) => {\n      if (DEFINED.has(parameter)) {\n        throw new Err(`The critical list contains a non-extension Header Parameter ${parameter}`)\n      }\n      if (!whitelisted.has(parameter)) {\n        throw new JOSECritNotUnderstood(`critical \"${parameter}\" is not understood`)\n      }\n      if (parameter === 'b64') {\n        if (!('b64' in protectedHeader)) {\n          throw new JWSInvalid('\"b64\" critical parameter must be integrity protected')\n        }\n        if (typeof protectedHeader.b64 !== 'boolean') {\n          throw new JWSInvalid('\"b64\" critical parameter must be a boolean')\n        }\n      } else if (!(parameter in combined)) {\n        throw new Err(`critical parameter \"${parameter}\" is missing`)\n      }\n    })\n  }\n  if (unprotectedHeader && 'crit' in unprotectedHeader) {\n    throw new Err('\"crit\" Header Parameter MUST be integrity protected when present')\n  }\n}\n"]},"metadata":{},"sourceType":"script"}