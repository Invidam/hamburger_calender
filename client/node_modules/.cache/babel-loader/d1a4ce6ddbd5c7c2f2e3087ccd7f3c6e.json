{"ast":null,"code":"const isObject = require('../help/is_object');\n\nlet validateCrit = require('../help/validate_crit');\n\nconst {\n  JWEInvalid\n} = require('../errors');\n\nvalidateCrit = validateCrit.bind(undefined, JWEInvalid);\n\nconst compactSerializer = (final, [recipient]) => {\n  return `${final.protected}.${recipient.encrypted_key}.${final.iv}.${final.ciphertext}.${final.tag}`;\n};\n\ncompactSerializer.validate = (protectedHeader, unprotectedHeader, aad, {\n  0: {\n    header\n  },\n  length\n}) => {\n  if (length !== 1 || aad || unprotectedHeader || header) {\n    throw new JWEInvalid('JWE Compact Serialization doesn\\'t support multiple recipients, JWE unprotected headers or AAD');\n  }\n\n  validateCrit(protectedHeader, unprotectedHeader, protectedHeader ? protectedHeader.crit : undefined);\n};\n\nconst flattenedSerializer = (final, [recipient]) => {\n  const {\n    header,\n    encrypted_key: encryptedKey\n  } = recipient;\n  return { ...(final.protected ? {\n      protected: final.protected\n    } : undefined),\n    ...(final.unprotected ? {\n      unprotected: final.unprotected\n    } : undefined),\n    ...(header ? {\n      header\n    } : undefined),\n    ...(encryptedKey ? {\n      encrypted_key: encryptedKey\n    } : undefined),\n    ...(final.aad ? {\n      aad: final.aad\n    } : undefined),\n    iv: final.iv,\n    ciphertext: final.ciphertext,\n    tag: final.tag\n  };\n};\n\nflattenedSerializer.validate = (protectedHeader, unprotectedHeader, aad, {\n  0: {\n    header\n  },\n  length\n}) => {\n  if (length !== 1) {\n    throw new JWEInvalid('Flattened JWE JSON Serialization doesn\\'t support multiple recipients');\n  }\n\n  validateCrit(protectedHeader, { ...unprotectedHeader,\n    ...header\n  }, protectedHeader ? protectedHeader.crit : undefined);\n};\n\nconst generalSerializer = (final, recipients) => {\n  const result = { ...(final.protected ? {\n      protected: final.protected\n    } : undefined),\n    ...(final.unprotected ? {\n      unprotected: final.unprotected\n    } : undefined),\n    recipients: recipients.map(({\n      header,\n      encrypted_key: encryptedKey,\n      generatedHeader\n    }) => {\n      if (!header && !encryptedKey && !generatedHeader) {\n        return false;\n      }\n\n      return { ...(header || generatedHeader ? {\n          header: { ...header,\n            ...generatedHeader\n          }\n        } : undefined),\n        ...(encryptedKey ? {\n          encrypted_key: encryptedKey\n        } : undefined)\n      };\n    }).filter(Boolean),\n    ...(final.aad ? {\n      aad: final.aad\n    } : undefined),\n    iv: final.iv,\n    ciphertext: final.ciphertext,\n    tag: final.tag\n  };\n\n  if (!result.recipients.length) {\n    delete result.recipients;\n  }\n\n  return result;\n};\n\ngeneralSerializer.validate = (protectedHeader, unprotectedHeader, aad, recipients) => {\n  recipients.forEach(({\n    header\n  }) => {\n    validateCrit(protectedHeader, { ...header,\n      ...unprotectedHeader\n    }, protectedHeader ? protectedHeader.crit : undefined);\n  });\n};\n\nconst isJSON = input => {\n  return isObject(input) && typeof input.ciphertext === 'string' && typeof input.iv === 'string' && typeof input.tag === 'string' && (input.unprotected === undefined || isObject(input.unprotected)) && (input.protected === undefined || typeof input.protected === 'string') && (input.aad === undefined || typeof input.aad === 'string');\n};\n\nconst isSingleRecipient = input => {\n  return (input.encrypted_key === undefined || typeof input.encrypted_key === 'string') && (input.header === undefined || isObject(input.header));\n};\n\nconst isValidRecipient = recipient => {\n  return isObject(recipient) && typeof recipient.encrypted_key === 'string' && (recipient.header === undefined || isObject(recipient.header));\n};\n\nconst isMultiRecipient = input => {\n  if (Array.isArray(input.recipients) && input.recipients.every(isValidRecipient)) {\n    return true;\n  }\n\n  return false;\n};\n\nconst detect = input => {\n  if (typeof input === 'string' && input.split('.').length === 5) {\n    return 'compact';\n  }\n\n  if (isJSON(input)) {\n    if (isMultiRecipient(input)) {\n      return 'general';\n    }\n\n    if (isSingleRecipient(input)) {\n      return 'flattened';\n    }\n  }\n\n  throw new JWEInvalid('JWE malformed or invalid serialization');\n};\n\nmodule.exports = {\n  compact: compactSerializer,\n  flattened: flattenedSerializer,\n  general: generalSerializer,\n  detect\n};","map":{"version":3,"sources":["/home/invidam/hamburger_calender/client/node_modules/jose/lib/jwe/serializers.js"],"names":["isObject","require","validateCrit","JWEInvalid","bind","undefined","compactSerializer","final","recipient","protected","encrypted_key","iv","ciphertext","tag","validate","protectedHeader","unprotectedHeader","aad","header","length","crit","flattenedSerializer","encryptedKey","unprotected","generalSerializer","recipients","result","map","generatedHeader","filter","Boolean","forEach","isJSON","input","isSingleRecipient","isValidRecipient","isMultiRecipient","Array","isArray","every","detect","split","module","exports","compact","flattened","general"],"mappings":"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","sourcesContent":["const isObject = require('../help/is_object')\nlet validateCrit = require('../help/validate_crit')\n\nconst { JWEInvalid } = require('../errors')\n\nvalidateCrit = validateCrit.bind(undefined, JWEInvalid)\n\nconst compactSerializer = (final, [recipient]) => {\n  return `${final.protected}.${recipient.encrypted_key}.${final.iv}.${final.ciphertext}.${final.tag}`\n}\ncompactSerializer.validate = (protectedHeader, unprotectedHeader, aad, { 0: { header }, length }) => {\n  if (length !== 1 || aad || unprotectedHeader || header) {\n    throw new JWEInvalid('JWE Compact Serialization doesn\\'t support multiple recipients, JWE unprotected headers or AAD')\n  }\n  validateCrit(protectedHeader, unprotectedHeader, protectedHeader ? protectedHeader.crit : undefined)\n}\n\nconst flattenedSerializer = (final, [recipient]) => {\n  const { header, encrypted_key: encryptedKey } = recipient\n\n  return {\n    ...(final.protected ? { protected: final.protected } : undefined),\n    ...(final.unprotected ? { unprotected: final.unprotected } : undefined),\n    ...(header ? { header } : undefined),\n    ...(encryptedKey ? { encrypted_key: encryptedKey } : undefined),\n    ...(final.aad ? { aad: final.aad } : undefined),\n    iv: final.iv,\n    ciphertext: final.ciphertext,\n    tag: final.tag\n  }\n}\nflattenedSerializer.validate = (protectedHeader, unprotectedHeader, aad, { 0: { header }, length }) => {\n  if (length !== 1) {\n    throw new JWEInvalid('Flattened JWE JSON Serialization doesn\\'t support multiple recipients')\n  }\n  validateCrit(protectedHeader, { ...unprotectedHeader, ...header }, protectedHeader ? protectedHeader.crit : undefined)\n}\n\nconst generalSerializer = (final, recipients) => {\n  const result = {\n    ...(final.protected ? { protected: final.protected } : undefined),\n    ...(final.unprotected ? { unprotected: final.unprotected } : undefined),\n    recipients: recipients.map(({ header, encrypted_key: encryptedKey, generatedHeader }) => {\n      if (!header && !encryptedKey && !generatedHeader) {\n        return false\n      }\n\n      return {\n        ...(header || generatedHeader ? { header: { ...header, ...generatedHeader } } : undefined),\n        ...(encryptedKey ? { encrypted_key: encryptedKey } : undefined)\n      }\n    }).filter(Boolean),\n    ...(final.aad ? { aad: final.aad } : undefined),\n    iv: final.iv,\n    ciphertext: final.ciphertext,\n    tag: final.tag\n  }\n\n  if (!result.recipients.length) {\n    delete result.recipients\n  }\n\n  return result\n}\ngeneralSerializer.validate = (protectedHeader, unprotectedHeader, aad, recipients) => {\n  recipients.forEach(({ header }) => {\n    validateCrit(protectedHeader, { ...header, ...unprotectedHeader }, protectedHeader ? protectedHeader.crit : undefined)\n  })\n}\n\nconst isJSON = (input) => {\n  return isObject(input) &&\n    typeof input.ciphertext === 'string' &&\n    typeof input.iv === 'string' &&\n    typeof input.tag === 'string' &&\n    (input.unprotected === undefined || isObject(input.unprotected)) &&\n    (input.protected === undefined || typeof input.protected === 'string') &&\n    (input.aad === undefined || typeof input.aad === 'string')\n}\n\nconst isSingleRecipient = (input) => {\n  return (input.encrypted_key === undefined || typeof input.encrypted_key === 'string') &&\n    (input.header === undefined || isObject(input.header))\n}\n\nconst isValidRecipient = (recipient) => {\n  return isObject(recipient) && typeof recipient.encrypted_key === 'string' && (recipient.header === undefined || isObject(recipient.header))\n}\n\nconst isMultiRecipient = (input) => {\n  if (Array.isArray(input.recipients) && input.recipients.every(isValidRecipient)) {\n    return true\n  }\n\n  return false\n}\n\nconst detect = (input) => {\n  if (typeof input === 'string' && input.split('.').length === 5) {\n    return 'compact'\n  }\n\n  if (isJSON(input)) {\n    if (isMultiRecipient(input)) {\n      return 'general'\n    }\n\n    if (isSingleRecipient(input)) {\n      return 'flattened'\n    }\n  }\n\n  throw new JWEInvalid('JWE malformed or invalid serialization')\n}\n\nmodule.exports = {\n  compact: compactSerializer,\n  flattened: flattenedSerializer,\n  general: generalSerializer,\n  detect\n}\n"]},"metadata":{},"sourceType":"script"}