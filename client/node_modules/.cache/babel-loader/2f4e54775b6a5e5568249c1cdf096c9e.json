{"ast":null,"code":"const {\n  keyObjectSupported\n} = require('./runtime_support');\n\nlet createPublicKey;\nlet createPrivateKey;\nlet createSecretKey;\nlet KeyObject;\nlet asInput;\n\nif (keyObjectSupported) {\n  ({\n    createPublicKey,\n    createPrivateKey,\n    createSecretKey,\n    KeyObject\n  } = require('crypto'));\n\n  asInput = input => input;\n} else {\n  const {\n    EOL\n  } = require('os');\n\n  const errors = require('../errors');\n\n  const isObject = require('./is_object');\n\n  const asn1 = require('./asn1');\n\n  const toInput = Symbol('toInput');\n  const namedCurve = Symbol('namedCurve');\n\n  asInput = (keyObject, needsPublic) => {\n    if (keyObject instanceof KeyObject) {\n      return keyObject[toInput](needsPublic);\n    }\n\n    return createSecretKey(keyObject)[toInput](needsPublic);\n  };\n\n  const pemToDer = pem => Buffer.from(pem.replace(/(?:-----(?:BEGIN|END)(?: (?:RSA|EC))? (?:PRIVATE|PUBLIC) KEY-----|\\s)/g, ''), 'base64');\n\n  const derToPem = (der, label) => `-----BEGIN ${label}-----${EOL}${(der.toString('base64').match(/.{1,64}/g) || []).join(EOL)}${EOL}-----END ${label}-----`;\n\n  const unsupported = input => {\n    const label = typeof input === 'string' ? input : `OID ${input.join('.')}`;\n    throw new errors.JOSENotSupported(`${label} is not supported in your Node.js runtime version`);\n  };\n\n  KeyObject = class KeyObject {\n    export({\n      cipher,\n      passphrase,\n      type,\n      format\n    } = {}) {\n      if (this._type === 'secret') {\n        return this._buffer;\n      }\n\n      if (this._type === 'public') {\n        if (this.asymmetricKeyType === 'rsa') {\n          switch (type) {\n            case 'pkcs1':\n              if (format === 'pem') {\n                return this._pem;\n              }\n\n              return pemToDer(this._pem);\n\n            case 'spki':\n              {\n                const PublicKeyInfo = asn1.get('PublicKeyInfo');\n                const pem = PublicKeyInfo.encode({\n                  algorithm: {\n                    algorithm: 'rsaEncryption',\n                    parameters: {\n                      type: 'null'\n                    }\n                  },\n                  publicKey: {\n                    unused: 0,\n                    data: pemToDer(this._pem)\n                  }\n                }, 'pem', {\n                  label: 'PUBLIC KEY'\n                });\n                return format === 'pem' ? pem : pemToDer(pem);\n              }\n\n            default:\n              throw new TypeError(`The value ${type} is invalid for option \"type\"`);\n          }\n        }\n\n        if (this.asymmetricKeyType === 'ec') {\n          if (type !== 'spki') {\n            throw new TypeError(`The value ${type} is invalid for option \"type\"`);\n          }\n\n          if (format === 'pem') {\n            return this._pem;\n          }\n\n          return pemToDer(this._pem);\n        }\n      }\n\n      if (this._type === 'private') {\n        if (passphrase !== undefined || cipher !== undefined) {\n          throw new errors.JOSENotSupported('encrypted private keys are not supported in your Node.js runtime version');\n        }\n\n        if (type === 'pkcs8') {\n          if (this._pkcs8) {\n            if (format === 'der' && typeof this._pkcs8 === 'string') {\n              return pemToDer(this._pkcs8);\n            }\n\n            if (format === 'pem' && Buffer.isBuffer(this._pkcs8)) {\n              return derToPem(this._pkcs8, 'PRIVATE KEY');\n            }\n\n            return this._pkcs8;\n          }\n\n          if (this.asymmetricKeyType === 'rsa') {\n            const parsed = this._asn1;\n            const RSAPrivateKey = asn1.get('RSAPrivateKey');\n            const privateKey = RSAPrivateKey.encode(parsed);\n            const PrivateKeyInfo = asn1.get('PrivateKeyInfo');\n            const pkcs8 = PrivateKeyInfo.encode({\n              version: 0,\n              privateKey,\n              algorithm: {\n                algorithm: 'rsaEncryption',\n                parameters: {\n                  type: 'null'\n                }\n              }\n            });\n            this._pkcs8 = pkcs8;\n            return this.export({\n              type,\n              format\n            });\n          }\n\n          if (this.asymmetricKeyType === 'ec') {\n            const parsed = this._asn1;\n            const ECPrivateKey = asn1.get('ECPrivateKey');\n            const privateKey = ECPrivateKey.encode({\n              version: parsed.version,\n              privateKey: parsed.privateKey,\n              publicKey: parsed.publicKey\n            });\n            const PrivateKeyInfo = asn1.get('PrivateKeyInfo');\n            const pkcs8 = PrivateKeyInfo.encode({\n              version: 0,\n              privateKey,\n              algorithm: {\n                algorithm: 'ecPublicKey',\n                parameters: this._asn1.parameters\n              }\n            });\n            this._pkcs8 = pkcs8;\n            return this.export({\n              type,\n              format\n            });\n          }\n        }\n\n        if (this.asymmetricKeyType === 'rsa' && type === 'pkcs1') {\n          if (format === 'pem') {\n            return this._pem;\n          }\n\n          return pemToDer(this._pem);\n        } else if (this.asymmetricKeyType === 'ec' && type === 'sec1') {\n          if (format === 'pem') {\n            return this._pem;\n          }\n\n          return pemToDer(this._pem);\n        } else {\n          throw new TypeError(`The value ${type} is invalid for option \"type\"`);\n        }\n      }\n    }\n\n    get type() {\n      return this._type;\n    }\n\n    get asymmetricKeyType() {\n      return this._asymmetricKeyType;\n    }\n\n    get symmetricKeySize() {\n      return this._symmetricKeySize;\n    }\n\n    [toInput](needsPublic) {\n      switch (this._type) {\n        case 'secret':\n          return this._buffer;\n\n        case 'public':\n          return this._pem;\n\n        default:\n          if (needsPublic) {\n            if (!('_pub' in this)) {\n              this._pub = createPublicKey(this);\n            }\n\n            return this._pub[toInput](false);\n          }\n\n          return this._pem;\n      }\n    }\n\n  };\n\n  createSecretKey = buffer => {\n    if (!Buffer.isBuffer(buffer) || !buffer.length) {\n      throw new TypeError('input must be a non-empty Buffer instance');\n    }\n\n    const keyObject = new KeyObject();\n    keyObject._buffer = Buffer.from(buffer);\n    keyObject._symmetricKeySize = buffer.length;\n    keyObject._type = 'secret';\n    return keyObject;\n  };\n\n  createPublicKey = input => {\n    if (input instanceof KeyObject) {\n      if (input.type !== 'private') {\n        throw new TypeError(`Invalid key object type ${input.type}, expected private.`);\n      }\n\n      switch (input.asymmetricKeyType) {\n        case 'ec':\n          {\n            const PublicKeyInfo = asn1.get('PublicKeyInfo');\n            const key = PublicKeyInfo.encode({\n              algorithm: {\n                algorithm: 'ecPublicKey',\n                parameters: input._asn1.parameters\n              },\n              publicKey: input._asn1.publicKey\n            });\n            return createPublicKey({\n              key,\n              format: 'der',\n              type: 'spki'\n            });\n          }\n\n        case 'rsa':\n          {\n            const RSAPublicKey = asn1.get('RSAPublicKey');\n            const key = RSAPublicKey.encode(input._asn1);\n            return createPublicKey({\n              key,\n              format: 'der',\n              type: 'pkcs1'\n            });\n          }\n      }\n    }\n\n    if (typeof input === 'string' || Buffer.isBuffer(input)) {\n      input = {\n        key: input,\n        format: 'pem'\n      };\n    }\n\n    if (!isObject(input)) {\n      throw new TypeError('input must be a string, Buffer or an object');\n    }\n\n    const {\n      format,\n      passphrase\n    } = input;\n    let {\n      key,\n      type\n    } = input;\n\n    if (typeof key !== 'string' && !Buffer.isBuffer(key)) {\n      throw new TypeError('key must be a string or Buffer');\n    }\n\n    if (format !== 'pem' && format !== 'der') {\n      throw new TypeError('format must be one of \"pem\" or \"der\"');\n    }\n\n    let label;\n\n    if (format === 'pem') {\n      key = key.toString();\n\n      switch (key.split(/\\r?\\n/g)[0].toString()) {\n        case '-----BEGIN PUBLIC KEY-----':\n          type = 'spki';\n          label = 'PUBLIC KEY';\n          break;\n\n        case '-----BEGIN RSA PUBLIC KEY-----':\n          type = 'pkcs1';\n          label = 'RSA PUBLIC KEY';\n          break;\n\n        case '-----BEGIN CERTIFICATE-----':\n          throw new errors.JOSENotSupported('X.509 certificates are not supported in your Node.js runtime version');\n\n        case '-----BEGIN PRIVATE KEY-----':\n        case '-----BEGIN EC PRIVATE KEY-----':\n        case '-----BEGIN RSA PRIVATE KEY-----':\n          return createPublicKey(createPrivateKey(key));\n\n        default:\n          throw new TypeError('unknown/unsupported PEM type');\n      }\n    }\n\n    switch (type) {\n      case 'spki':\n        {\n          const PublicKeyInfo = asn1.get('PublicKeyInfo');\n          const parsed = PublicKeyInfo.decode(key, format, {\n            label\n          });\n          let type, keyObject;\n\n          switch (parsed.algorithm.algorithm) {\n            case 'ecPublicKey':\n              {\n                keyObject = new KeyObject();\n                keyObject._asn1 = parsed;\n                keyObject._asymmetricKeyType = 'ec';\n                keyObject._type = 'public';\n                keyObject._pem = PublicKeyInfo.encode(parsed, 'pem', {\n                  label: 'PUBLIC KEY'\n                });\n                break;\n              }\n\n            case 'rsaEncryption':\n              {\n                type = 'pkcs1';\n                keyObject = createPublicKey({\n                  type,\n                  key: parsed.publicKey.data,\n                  format: 'der'\n                });\n                break;\n              }\n\n            default:\n              unsupported(parsed.algorithm.algorithm);\n          }\n\n          return keyObject;\n        }\n\n      case 'pkcs1':\n        {\n          const RSAPublicKey = asn1.get('RSAPublicKey');\n          const parsed = RSAPublicKey.decode(key, format, {\n            label\n          }); // special case when private pkcs1 PEM / DER is used with createPublicKey\n\n          if (parsed.n === BigInt(0)) {\n            return createPublicKey(createPrivateKey({\n              key,\n              format,\n              type,\n              passphrase\n            }));\n          }\n\n          const keyObject = new KeyObject();\n          keyObject._asn1 = parsed;\n          keyObject._asymmetricKeyType = 'rsa';\n          keyObject._type = 'public';\n          keyObject._pem = RSAPublicKey.encode(parsed, 'pem', {\n            label: 'RSA PUBLIC KEY'\n          });\n          return keyObject;\n        }\n\n      case 'pkcs8':\n      case 'sec1':\n        return createPublicKey(createPrivateKey({\n          format,\n          key,\n          type,\n          passphrase\n        }));\n\n      default:\n        throw new TypeError(`The value ${type} is invalid for option \"type\"`);\n    }\n  };\n\n  createPrivateKey = (input, hints) => {\n    if (typeof input === 'string' || Buffer.isBuffer(input)) {\n      input = {\n        key: input,\n        format: 'pem'\n      };\n    }\n\n    if (!isObject(input)) {\n      throw new TypeError('input must be a string, Buffer or an object');\n    }\n\n    const {\n      format,\n      passphrase\n    } = input;\n    let {\n      key,\n      type\n    } = input;\n\n    if (typeof key !== 'string' && !Buffer.isBuffer(key)) {\n      throw new TypeError('key must be a string or Buffer');\n    }\n\n    if (passphrase !== undefined) {\n      throw new errors.JOSENotSupported('encrypted private keys are not supported in your Node.js runtime version');\n    }\n\n    if (format !== 'pem' && format !== 'der') {\n      throw new TypeError('format must be one of \"pem\" or \"der\"');\n    }\n\n    let label;\n\n    if (format === 'pem') {\n      key = key.toString();\n\n      switch (key.split(/\\r?\\n/g)[0].toString()) {\n        case '-----BEGIN PRIVATE KEY-----':\n          type = 'pkcs8';\n          label = 'PRIVATE KEY';\n          break;\n\n        case '-----BEGIN EC PRIVATE KEY-----':\n          type = 'sec1';\n          label = 'EC PRIVATE KEY';\n          break;\n\n        case '-----BEGIN RSA PRIVATE KEY-----':\n          type = 'pkcs1';\n          label = 'RSA PRIVATE KEY';\n          break;\n\n        default:\n          throw new TypeError('unknown/unsupported PEM type');\n      }\n    }\n\n    switch (type) {\n      case 'pkcs8':\n        {\n          const PrivateKeyInfo = asn1.get('PrivateKeyInfo');\n          const parsed = PrivateKeyInfo.decode(key, format, {\n            label\n          });\n          let type, keyObject;\n\n          switch (parsed.algorithm.algorithm) {\n            case 'ecPublicKey':\n              {\n                type = 'sec1';\n                keyObject = createPrivateKey({\n                  type,\n                  key: parsed.privateKey,\n                  format: 'der'\n                }, {\n                  [namedCurve]: parsed.algorithm.parameters.value\n                });\n                break;\n              }\n\n            case 'rsaEncryption':\n              {\n                type = 'pkcs1';\n                keyObject = createPrivateKey({\n                  type,\n                  key: parsed.privateKey,\n                  format: 'der'\n                });\n                break;\n              }\n\n            default:\n              unsupported(parsed.algorithm.algorithm);\n          }\n\n          keyObject._pkcs8 = key;\n          return keyObject;\n        }\n\n      case 'pkcs1':\n        {\n          const RSAPrivateKey = asn1.get('RSAPrivateKey');\n          const parsed = RSAPrivateKey.decode(key, format, {\n            label\n          });\n          const keyObject = new KeyObject();\n          keyObject._asn1 = parsed;\n          keyObject._asymmetricKeyType = 'rsa';\n          keyObject._type = 'private';\n          keyObject._pem = RSAPrivateKey.encode(parsed, 'pem', {\n            label: 'RSA PRIVATE KEY'\n          });\n          return keyObject;\n        }\n\n      case 'sec1':\n        {\n          const ECPrivateKey = asn1.get('ECPrivateKey');\n          let parsed = ECPrivateKey.decode(key, format, {\n            label\n          });\n\n          if (!('parameters' in parsed) && !hints[namedCurve]) {\n            throw new Error('invalid sec1');\n          } else if (!('parameters' in parsed)) {\n            parsed = { ...parsed,\n              parameters: {\n                type: 'namedCurve',\n                value: hints[namedCurve]\n              }\n            };\n          }\n\n          const keyObject = new KeyObject();\n          keyObject._asn1 = parsed;\n          keyObject._asymmetricKeyType = 'ec';\n          keyObject._type = 'private';\n          keyObject._pem = ECPrivateKey.encode(parsed, 'pem', {\n            label: 'EC PRIVATE KEY'\n          });\n          return keyObject;\n        }\n\n      default:\n        throw new TypeError(`The value ${type} is invalid for option \"type\"`);\n    }\n  };\n}\n\nmodule.exports = {\n  createPublicKey,\n  createPrivateKey,\n  createSecretKey,\n  KeyObject,\n  asInput\n};","map":{"version":3,"sources":["/home/invidam/hamburger_calender/client/node_modules/jose/lib/help/key_object.js"],"names":["keyObjectSupported","require","createPublicKey","createPrivateKey","createSecretKey","KeyObject","asInput","input","EOL","errors","isObject","asn1","toInput","Symbol","namedCurve","keyObject","needsPublic","pemToDer","pem","Buffer","from","replace","derToPem","der","label","toString","match","join","unsupported","JOSENotSupported","export","cipher","passphrase","type","format","_type","_buffer","asymmetricKeyType","_pem","PublicKeyInfo","get","encode","algorithm","parameters","publicKey","unused","data","TypeError","undefined","_pkcs8","isBuffer","parsed","_asn1","RSAPrivateKey","privateKey","PrivateKeyInfo","pkcs8","version","ECPrivateKey","_asymmetricKeyType","symmetricKeySize","_symmetricKeySize","_pub","buffer","length","key","RSAPublicKey","split","decode","n","BigInt","hints","value","Error","module","exports"],"mappings":"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","sourcesContent":["const { keyObjectSupported } = require('./runtime_support')\n\nlet createPublicKey\nlet createPrivateKey\nlet createSecretKey\nlet KeyObject\nlet asInput\n\nif (keyObjectSupported) {\n  ({ createPublicKey, createPrivateKey, createSecretKey, KeyObject } = require('crypto'))\n  asInput = (input) => input\n} else {\n  const { EOL } = require('os')\n\n  const errors = require('../errors')\n  const isObject = require('./is_object')\n  const asn1 = require('./asn1')\n  const toInput = Symbol('toInput')\n\n  const namedCurve = Symbol('namedCurve')\n\n  asInput = (keyObject, needsPublic) => {\n    if (keyObject instanceof KeyObject) {\n      return keyObject[toInput](needsPublic)\n    }\n\n    return createSecretKey(keyObject)[toInput](needsPublic)\n  }\n\n  const pemToDer = pem => Buffer.from(pem.replace(/(?:-----(?:BEGIN|END)(?: (?:RSA|EC))? (?:PRIVATE|PUBLIC) KEY-----|\\s)/g, ''), 'base64')\n  const derToPem = (der, label) => `-----BEGIN ${label}-----${EOL}${(der.toString('base64').match(/.{1,64}/g) || []).join(EOL)}${EOL}-----END ${label}-----`\n  const unsupported = (input) => {\n    const label = typeof input === 'string' ? input : `OID ${input.join('.')}`\n    throw new errors.JOSENotSupported(`${label} is not supported in your Node.js runtime version`)\n  }\n\n  KeyObject = class KeyObject {\n    export ({ cipher, passphrase, type, format } = {}) {\n      if (this._type === 'secret') {\n        return this._buffer\n      }\n\n      if (this._type === 'public') {\n        if (this.asymmetricKeyType === 'rsa') {\n          switch (type) {\n            case 'pkcs1':\n              if (format === 'pem') {\n                return this._pem\n              }\n\n              return pemToDer(this._pem)\n            case 'spki': {\n              const PublicKeyInfo = asn1.get('PublicKeyInfo')\n              const pem = PublicKeyInfo.encode({\n                algorithm: {\n                  algorithm: 'rsaEncryption',\n                  parameters: { type: 'null' }\n                },\n                publicKey: {\n                  unused: 0,\n                  data: pemToDer(this._pem)\n                }\n              }, 'pem', { label: 'PUBLIC KEY' })\n\n              return format === 'pem' ? pem : pemToDer(pem)\n            }\n            default:\n              throw new TypeError(`The value ${type} is invalid for option \"type\"`)\n          }\n        }\n\n        if (this.asymmetricKeyType === 'ec') {\n          if (type !== 'spki') {\n            throw new TypeError(`The value ${type} is invalid for option \"type\"`)\n          }\n\n          if (format === 'pem') {\n            return this._pem\n          }\n\n          return pemToDer(this._pem)\n        }\n      }\n\n      if (this._type === 'private') {\n        if (passphrase !== undefined || cipher !== undefined) {\n          throw new errors.JOSENotSupported('encrypted private keys are not supported in your Node.js runtime version')\n        }\n\n        if (type === 'pkcs8') {\n          if (this._pkcs8) {\n            if (format === 'der' && typeof this._pkcs8 === 'string') {\n              return pemToDer(this._pkcs8)\n            }\n\n            if (format === 'pem' && Buffer.isBuffer(this._pkcs8)) {\n              return derToPem(this._pkcs8, 'PRIVATE KEY')\n            }\n\n            return this._pkcs8\n          }\n\n          if (this.asymmetricKeyType === 'rsa') {\n            const parsed = this._asn1\n            const RSAPrivateKey = asn1.get('RSAPrivateKey')\n            const privateKey = RSAPrivateKey.encode(parsed)\n            const PrivateKeyInfo = asn1.get('PrivateKeyInfo')\n            const pkcs8 = PrivateKeyInfo.encode({\n              version: 0,\n              privateKey,\n              algorithm: {\n                algorithm: 'rsaEncryption',\n                parameters: { type: 'null' }\n              }\n            })\n\n            this._pkcs8 = pkcs8\n\n            return this.export({ type, format })\n          }\n\n          if (this.asymmetricKeyType === 'ec') {\n            const parsed = this._asn1\n            const ECPrivateKey = asn1.get('ECPrivateKey')\n            const privateKey = ECPrivateKey.encode({\n              version: parsed.version,\n              privateKey: parsed.privateKey,\n              publicKey: parsed.publicKey\n            })\n            const PrivateKeyInfo = asn1.get('PrivateKeyInfo')\n            const pkcs8 = PrivateKeyInfo.encode({\n              version: 0,\n              privateKey,\n              algorithm: {\n                algorithm: 'ecPublicKey',\n                parameters: this._asn1.parameters\n              }\n            })\n\n            this._pkcs8 = pkcs8\n\n            return this.export({ type, format })\n          }\n        }\n\n        if (this.asymmetricKeyType === 'rsa' && type === 'pkcs1') {\n          if (format === 'pem') {\n            return this._pem\n          }\n\n          return pemToDer(this._pem)\n        } else if (this.asymmetricKeyType === 'ec' && type === 'sec1') {\n          if (format === 'pem') {\n            return this._pem\n          }\n\n          return pemToDer(this._pem)\n        } else {\n          throw new TypeError(`The value ${type} is invalid for option \"type\"`)\n        }\n      }\n    }\n\n    get type () {\n      return this._type\n    }\n\n    get asymmetricKeyType () {\n      return this._asymmetricKeyType\n    }\n\n    get symmetricKeySize () {\n      return this._symmetricKeySize\n    }\n\n    [toInput] (needsPublic) {\n      switch (this._type) {\n        case 'secret':\n          return this._buffer\n        case 'public':\n          return this._pem\n        default:\n          if (needsPublic) {\n            if (!('_pub' in this)) {\n              this._pub = createPublicKey(this)\n            }\n\n            return this._pub[toInput](false)\n          }\n\n          return this._pem\n      }\n    }\n  }\n\n  createSecretKey = (buffer) => {\n    if (!Buffer.isBuffer(buffer) || !buffer.length) {\n      throw new TypeError('input must be a non-empty Buffer instance')\n    }\n\n    const keyObject = new KeyObject()\n    keyObject._buffer = Buffer.from(buffer)\n    keyObject._symmetricKeySize = buffer.length\n    keyObject._type = 'secret'\n\n    return keyObject\n  }\n\n  createPublicKey = (input) => {\n    if (input instanceof KeyObject) {\n      if (input.type !== 'private') {\n        throw new TypeError(`Invalid key object type ${input.type}, expected private.`)\n      }\n\n      switch (input.asymmetricKeyType) {\n        case 'ec': {\n          const PublicKeyInfo = asn1.get('PublicKeyInfo')\n          const key = PublicKeyInfo.encode({\n            algorithm: {\n              algorithm: 'ecPublicKey',\n              parameters: input._asn1.parameters\n            },\n            publicKey: input._asn1.publicKey\n          })\n\n          return createPublicKey({ key, format: 'der', type: 'spki' })\n        }\n        case 'rsa': {\n          const RSAPublicKey = asn1.get('RSAPublicKey')\n          const key = RSAPublicKey.encode(input._asn1)\n          return createPublicKey({ key, format: 'der', type: 'pkcs1' })\n        }\n      }\n    }\n\n    if (typeof input === 'string' || Buffer.isBuffer(input)) {\n      input = { key: input, format: 'pem' }\n    }\n\n    if (!isObject(input)) {\n      throw new TypeError('input must be a string, Buffer or an object')\n    }\n\n    const { format, passphrase } = input\n    let { key, type } = input\n\n    if (typeof key !== 'string' && !Buffer.isBuffer(key)) {\n      throw new TypeError('key must be a string or Buffer')\n    }\n\n    if (format !== 'pem' && format !== 'der') {\n      throw new TypeError('format must be one of \"pem\" or \"der\"')\n    }\n\n    let label\n    if (format === 'pem') {\n      key = key.toString()\n      switch (key.split(/\\r?\\n/g)[0].toString()) {\n        case '-----BEGIN PUBLIC KEY-----':\n          type = 'spki'\n          label = 'PUBLIC KEY'\n          break\n        case '-----BEGIN RSA PUBLIC KEY-----':\n          type = 'pkcs1'\n          label = 'RSA PUBLIC KEY'\n          break\n        case '-----BEGIN CERTIFICATE-----':\n          throw new errors.JOSENotSupported('X.509 certificates are not supported in your Node.js runtime version')\n        case '-----BEGIN PRIVATE KEY-----':\n        case '-----BEGIN EC PRIVATE KEY-----':\n        case '-----BEGIN RSA PRIVATE KEY-----':\n          return createPublicKey(createPrivateKey(key))\n        default:\n          throw new TypeError('unknown/unsupported PEM type')\n      }\n    }\n\n    switch (type) {\n      case 'spki': {\n        const PublicKeyInfo = asn1.get('PublicKeyInfo')\n        const parsed = PublicKeyInfo.decode(key, format, { label })\n\n        let type, keyObject\n        switch (parsed.algorithm.algorithm) {\n          case 'ecPublicKey': {\n            keyObject = new KeyObject()\n            keyObject._asn1 = parsed\n            keyObject._asymmetricKeyType = 'ec'\n            keyObject._type = 'public'\n            keyObject._pem = PublicKeyInfo.encode(parsed, 'pem', { label: 'PUBLIC KEY' })\n\n            break\n          }\n          case 'rsaEncryption': {\n            type = 'pkcs1'\n            keyObject = createPublicKey({ type, key: parsed.publicKey.data, format: 'der' })\n            break\n          }\n          default:\n            unsupported(parsed.algorithm.algorithm)\n        }\n\n        return keyObject\n      }\n      case 'pkcs1': {\n        const RSAPublicKey = asn1.get('RSAPublicKey')\n        const parsed = RSAPublicKey.decode(key, format, { label })\n\n        // special case when private pkcs1 PEM / DER is used with createPublicKey\n        if (parsed.n === BigInt(0)) {\n          return createPublicKey(createPrivateKey({ key, format, type, passphrase }))\n        }\n\n        const keyObject = new KeyObject()\n        keyObject._asn1 = parsed\n        keyObject._asymmetricKeyType = 'rsa'\n        keyObject._type = 'public'\n        keyObject._pem = RSAPublicKey.encode(parsed, 'pem', { label: 'RSA PUBLIC KEY' })\n\n        return keyObject\n      }\n      case 'pkcs8':\n      case 'sec1':\n        return createPublicKey(createPrivateKey({ format, key, type, passphrase }))\n      default:\n        throw new TypeError(`The value ${type} is invalid for option \"type\"`)\n    }\n  }\n\n  createPrivateKey = (input, hints) => {\n    if (typeof input === 'string' || Buffer.isBuffer(input)) {\n      input = { key: input, format: 'pem' }\n    }\n\n    if (!isObject(input)) {\n      throw new TypeError('input must be a string, Buffer or an object')\n    }\n\n    const { format, passphrase } = input\n    let { key, type } = input\n\n    if (typeof key !== 'string' && !Buffer.isBuffer(key)) {\n      throw new TypeError('key must be a string or Buffer')\n    }\n\n    if (passphrase !== undefined) {\n      throw new errors.JOSENotSupported('encrypted private keys are not supported in your Node.js runtime version')\n    }\n\n    if (format !== 'pem' && format !== 'der') {\n      throw new TypeError('format must be one of \"pem\" or \"der\"')\n    }\n\n    let label\n    if (format === 'pem') {\n      key = key.toString()\n      switch (key.split(/\\r?\\n/g)[0].toString()) {\n        case '-----BEGIN PRIVATE KEY-----':\n          type = 'pkcs8'\n          label = 'PRIVATE KEY'\n          break\n        case '-----BEGIN EC PRIVATE KEY-----':\n          type = 'sec1'\n          label = 'EC PRIVATE KEY'\n          break\n        case '-----BEGIN RSA PRIVATE KEY-----':\n          type = 'pkcs1'\n          label = 'RSA PRIVATE KEY'\n          break\n        default:\n          throw new TypeError('unknown/unsupported PEM type')\n      }\n    }\n\n    switch (type) {\n      case 'pkcs8': {\n        const PrivateKeyInfo = asn1.get('PrivateKeyInfo')\n        const parsed = PrivateKeyInfo.decode(key, format, { label })\n\n        let type, keyObject\n        switch (parsed.algorithm.algorithm) {\n          case 'ecPublicKey': {\n            type = 'sec1'\n            keyObject = createPrivateKey({ type, key: parsed.privateKey, format: 'der' }, { [namedCurve]: parsed.algorithm.parameters.value })\n            break\n          }\n          case 'rsaEncryption': {\n            type = 'pkcs1'\n            keyObject = createPrivateKey({ type, key: parsed.privateKey, format: 'der' })\n            break\n          }\n          default:\n            unsupported(parsed.algorithm.algorithm)\n        }\n\n        keyObject._pkcs8 = key\n        return keyObject\n      }\n      case 'pkcs1': {\n        const RSAPrivateKey = asn1.get('RSAPrivateKey')\n        const parsed = RSAPrivateKey.decode(key, format, { label })\n\n        const keyObject = new KeyObject()\n        keyObject._asn1 = parsed\n        keyObject._asymmetricKeyType = 'rsa'\n        keyObject._type = 'private'\n        keyObject._pem = RSAPrivateKey.encode(parsed, 'pem', { label: 'RSA PRIVATE KEY' })\n\n        return keyObject\n      }\n      case 'sec1': {\n        const ECPrivateKey = asn1.get('ECPrivateKey')\n        let parsed = ECPrivateKey.decode(key, format, { label })\n\n        if (!('parameters' in parsed) && !hints[namedCurve]) {\n          throw new Error('invalid sec1')\n        } else if (!('parameters' in parsed)) {\n          parsed = { ...parsed, parameters: { type: 'namedCurve', value: hints[namedCurve] } }\n        }\n\n        const keyObject = new KeyObject()\n        keyObject._asn1 = parsed\n        keyObject._asymmetricKeyType = 'ec'\n        keyObject._type = 'private'\n        keyObject._pem = ECPrivateKey.encode(parsed, 'pem', { label: 'EC PRIVATE KEY' })\n\n        return keyObject\n      }\n      default:\n        throw new TypeError(`The value ${type} is invalid for option \"type\"`)\n    }\n  }\n}\n\nmodule.exports = { createPublicKey, createPrivateKey, createSecretKey, KeyObject, asInput }\n"]},"metadata":{},"sourceType":"script"}