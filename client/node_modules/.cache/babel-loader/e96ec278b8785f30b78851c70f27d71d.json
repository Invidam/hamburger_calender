{"ast":null,"code":"const http = require('http');\n\nconst https = require('https');\n\nconst urlUtil = require('url');\n\nmodule.exports.default = options => {\n  if (options.fetcher) {\n    return options.fetcher(options.uri);\n  }\n\n  return new Promise((resolve, reject) => {\n    const {\n      hostname,\n      path,\n      port,\n      protocol\n    } = urlUtil.parse(options.uri);\n    const requestOptions = {\n      hostname,\n      path,\n      port,\n      method: 'GET',\n      ...(options.headers && {\n        headers: { ...options.headers\n        }\n      }),\n      ...(options.timeout && {\n        timeout: options.timeout\n      }),\n      ...(options.agent && {\n        agent: options.agent\n      })\n    };\n    const httpRequestLib = protocol === 'https:' ? https : http;\n    httpRequestLib.request(requestOptions, res => {\n      let rawData = '';\n      res.setEncoding('utf8');\n      res.on('data', chunk => {\n        rawData += chunk;\n      });\n      res.on('end', () => {\n        if (res.statusCode < 200 || res.statusCode >= 300) {\n          const errorMsg = res.body && (res.body.message || res.body) || res.statusMessage || `Http Error ${res.statusCode}`;\n          reject({\n            errorMsg\n          });\n        } else {\n          try {\n            resolve(rawData && JSON.parse(rawData));\n          } catch (error) {\n            reject(error);\n          }\n        }\n      });\n    }).on('error', e => reject(e)).end();\n  });\n};","map":{"version":3,"sources":["/home/invidam/hamburger_calender/client/node_modules/jwks-rsa/src/wrappers/request.js"],"names":["http","require","https","urlUtil","module","exports","default","options","fetcher","uri","Promise","resolve","reject","hostname","path","port","protocol","parse","requestOptions","method","headers","timeout","agent","httpRequestLib","request","res","rawData","setEncoding","on","chunk","statusCode","errorMsg","body","message","statusMessage","JSON","error","e","end"],"mappings":"AAAA,MAAMA,IAAI,GAAGC,OAAO,CAAC,MAAD,CAApB;;AACA,MAAMC,KAAK,GAAGD,OAAO,CAAC,OAAD,CAArB;;AACA,MAAME,OAAO,GAAGF,OAAO,CAAC,KAAD,CAAvB;;AAEAG,MAAM,CAACC,OAAP,CAAeC,OAAf,GAA2BC,OAAD,IAAa;AACrC,MAAIA,OAAO,CAACC,OAAZ,EAAqB;AACnB,WAAOD,OAAO,CAACC,OAAR,CAAgBD,OAAO,CAACE,GAAxB,CAAP;AACD;;AAED,SAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC,UAAM;AACJC,MAAAA,QADI;AAEJC,MAAAA,IAFI;AAGJC,MAAAA,IAHI;AAIJC,MAAAA;AAJI,QAKFb,OAAO,CAACc,KAAR,CAAcV,OAAO,CAACE,GAAtB,CALJ;AAOA,UAAMS,cAAc,GAAG;AACrBL,MAAAA,QADqB;AAErBC,MAAAA,IAFqB;AAGrBC,MAAAA,IAHqB;AAIrBI,MAAAA,MAAM,EAAE,KAJa;AAKrB,UAAIZ,OAAO,CAACa,OAAR,IAAmB;AAAEA,QAAAA,OAAO,EAAE,EAAE,GAAGb,OAAO,CAACa;AAAb;AAAX,OAAvB,CALqB;AAMrB,UAAIb,OAAO,CAACc,OAAR,IAAmB;AAAEA,QAAAA,OAAO,EAAEd,OAAO,CAACc;AAAnB,OAAvB,CANqB;AAOrB,UAAId,OAAO,CAACe,KAAR,IAAiB;AAAEA,QAAAA,KAAK,EAAEf,OAAO,CAACe;AAAjB,OAArB;AAPqB,KAAvB;AAUA,UAAMC,cAAc,GAAGP,QAAQ,KAAK,QAAb,GAAwBd,KAAxB,GAAgCF,IAAvD;AACAuB,IAAAA,cAAc,CAACC,OAAf,CAAuBN,cAAvB,EAAwCO,GAAD,IAAS;AAC9C,UAAIC,OAAO,GAAG,EAAd;AACAD,MAAAA,GAAG,CAACE,WAAJ,CAAgB,MAAhB;AACAF,MAAAA,GAAG,CAACG,EAAJ,CAAO,MAAP,EAAgBC,KAAD,IAAW;AAAEH,QAAAA,OAAO,IAAIG,KAAX;AAAmB,OAA/C;AACAJ,MAAAA,GAAG,CAACG,EAAJ,CAAO,KAAP,EAAc,MAAM;AAClB,YAAIH,GAAG,CAACK,UAAJ,GAAiB,GAAjB,IAAwBL,GAAG,CAACK,UAAJ,IAAkB,GAA9C,EAAmD;AACjD,gBAAMC,QAAQ,GAAGN,GAAG,CAACO,IAAJ,KAAaP,GAAG,CAACO,IAAJ,CAASC,OAAT,IAAoBR,GAAG,CAACO,IAArC,KAA8CP,GAAG,CAACS,aAAlD,IAAoE,cAAaT,GAAG,CAACK,UAAW,EAAjH;AACAlB,UAAAA,MAAM,CAAC;AAAEmB,YAAAA;AAAF,WAAD,CAAN;AACD,SAHD,MAGO;AACL,cAAI;AACFpB,YAAAA,OAAO,CAACe,OAAO,IAAIS,IAAI,CAAClB,KAAL,CAAWS,OAAX,CAAZ,CAAP;AACD,WAFD,CAEE,OAAOU,KAAP,EAAc;AACdxB,YAAAA,MAAM,CAACwB,KAAD,CAAN;AACD;AACF;AACF,OAXD;AAYD,KAhBD,EAiBGR,EAjBH,CAiBM,OAjBN,EAiBgBS,CAAD,IAAOzB,MAAM,CAACyB,CAAD,CAjB5B,EAkBGC,GAlBH;AAmBD,GAtCM,CAAP;AAuCD,CA5CD","sourcesContent":["const http = require('http');\nconst https = require('https');\nconst urlUtil = require('url');\n\nmodule.exports.default =  (options) => {\n  if (options.fetcher) {\n    return options.fetcher(options.uri);\n  }\n\n  return new Promise((resolve, reject) => {\n    const {\n      hostname,\n      path,\n      port,\n      protocol\n    } = urlUtil.parse(options.uri);\n\n    const requestOptions = {\n      hostname,\n      path,\n      port,\n      method: 'GET',\n      ...(options.headers && { headers: { ...options.headers } }),\n      ...(options.timeout && { timeout: options.timeout }),\n      ...(options.agent && { agent: options.agent })\n    };\n\n    const httpRequestLib = protocol === 'https:' ? https : http;\n    httpRequestLib.request(requestOptions, (res) => {\n      let rawData = '';\n      res.setEncoding('utf8');\n      res.on('data', (chunk) => { rawData += chunk; });\n      res.on('end', () => {\n        if (res.statusCode < 200 || res.statusCode >= 300) {\n          const errorMsg = res.body && (res.body.message || res.body) || res.statusMessage || `Http Error ${res.statusCode}`;\n          reject({ errorMsg });\n        } else {\n          try {\n            resolve(rawData && JSON.parse(rawData));\n          } catch (error) {\n            reject(error);\n          }\n        }\n      });\n    })\n      .on('error', (e) => reject(e))\n      .end();\n  });\n};\n"]},"metadata":{},"sourceType":"script"}