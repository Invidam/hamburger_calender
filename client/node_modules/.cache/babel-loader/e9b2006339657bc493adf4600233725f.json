{"ast":null,"code":"/**\r\n * A hierarchical token bucket for rate limiting. See\r\n * http://en.wikipedia.org/wiki/Token_bucket for more information.\r\n * @author John Hurliman <jhurliman@cull.tv>\r\n *\r\n * @param {Number} bucketSize Maximum number of tokens to hold in the bucket.\r\n *  Also known as the burst rate.\r\n * @param {Number} tokensPerInterval Number of tokens to drip into the bucket\r\n *  over the course of one interval.\r\n * @param {String|Number} interval The interval length in milliseconds, or as\r\n *  one of the following strings: 'second', 'minute', 'hour', day'.\r\n * @param {TokenBucket} parentBucket Optional. A token bucket that will act as\r\n *  the parent of this bucket.\r\n */\nvar TokenBucket = function (bucketSize, tokensPerInterval, interval, parentBucket) {\n  this.bucketSize = bucketSize;\n  this.tokensPerInterval = tokensPerInterval;\n\n  if (typeof interval === 'string') {\n    switch (interval) {\n      case 'sec':\n      case 'second':\n        this.interval = 1000;\n        break;\n\n      case 'min':\n      case 'minute':\n        this.interval = 1000 * 60;\n        break;\n\n      case 'hr':\n      case 'hour':\n        this.interval = 1000 * 60 * 60;\n        break;\n\n      case 'day':\n        this.interval = 1000 * 60 * 60 * 24;\n        break;\n\n      default:\n        throw new Error('Invaid interval ' + interval);\n    }\n  } else {\n    this.interval = interval;\n  }\n\n  this.parentBucket = parentBucket;\n  this.content = 0;\n  this.lastDrip = +new Date();\n};\n\nTokenBucket.prototype = {\n  bucketSize: 1,\n  tokensPerInterval: 1,\n  interval: 1000,\n  parentBucket: null,\n  content: 0,\n  lastDrip: 0,\n\n  /**\r\n   * Remove the requested number of tokens and fire the given callback. If the\r\n   * bucket (and any parent buckets) contains enough tokens this will happen\r\n   * immediately. Otherwise, the removal and callback will happen when enough\r\n   * tokens become available.\r\n   * @param {Number} count The number of tokens to remove.\r\n   * @param {Function} callback(err, remainingTokens)\r\n   * @returns {Boolean} True if the callback was fired immediately, otherwise\r\n   *  false.\r\n   */\n  removeTokens: function (count, callback) {\n    var self = this; // Is this an infinite size bucket?\n\n    if (!this.bucketSize) {\n      process.nextTick(callback.bind(null, null, count, Number.POSITIVE_INFINITY));\n      return true;\n    } // Make sure the bucket can hold the requested number of tokens\n\n\n    if (count > this.bucketSize) {\n      process.nextTick(callback.bind(null, 'Requested tokens ' + count + ' exceeds bucket size ' + this.bucketSize, null));\n      return false;\n    } // Drip new tokens into this bucket\n\n\n    this.drip(); // If we don't have enough tokens in this bucket, come back later\n\n    if (count > this.content) return comeBackLater();\n\n    if (this.parentBucket) {\n      // Remove the requested from the parent bucket first\n      return this.parentBucket.removeTokens(count, function (err, remainingTokens) {\n        if (err) return callback(err, null); // Check that we still have enough tokens in this bucket\n\n        if (count > self.content) return comeBackLater(); // Tokens were removed from the parent bucket, now remove them from\n        // this bucket and fire the callback. Note that we look at the current\n        // bucket and parent bucket's remaining tokens and return the smaller\n        // of the two values\n\n        self.content -= count;\n        callback(null, Math.min(remainingTokens, self.content));\n      });\n    } else {\n      // Remove the requested tokens from this bucket and fire the callback\n      this.content -= count;\n      process.nextTick(callback.bind(null, null, this.content));\n      return true;\n    }\n\n    function comeBackLater() {\n      // How long do we need to wait to make up the difference in tokens?\n      var waitInterval = Math.ceil((count - self.content) * (self.interval / self.tokensPerInterval));\n      setTimeout(function () {\n        self.removeTokens(count, callback);\n      }, waitInterval);\n      return false;\n    }\n  },\n\n  /**\r\n   * Attempt to remove the requested number of tokens and return immediately.\r\n   * If the bucket (and any parent buckets) contains enough tokens this will\r\n   * return true, otherwise false is returned.\r\n   * @param {Number} count The number of tokens to remove.\r\n   * @param {Boolean} True if the tokens were successfully removed, otherwise\r\n   *  false.\r\n   */\n  tryRemoveTokens: function (count) {\n    // Is this an infinite size bucket?\n    if (!this.bucketSize) return true; // Make sure the bucket can hold the requested number of tokens\n\n    if (count > this.bucketSize) return false; // Drip new tokens into this bucket\n\n    this.drip(); // If we don't have enough tokens in this bucket, return false\n\n    if (count > this.content) return false; // Try to remove the requested tokens from the parent bucket\n\n    if (this.parentBucket && !this.parentBucket.tryRemoveTokens(count)) return false; // Remove the requested tokens from this bucket and return\n\n    this.content -= count;\n    return true;\n  },\n\n  /**\r\n   * Add any new tokens to the bucket since the last drip.\r\n   * @returns {Boolean} True if new tokens were added, otherwise false.\r\n   */\n  drip: function () {\n    if (!this.tokensPerInterval) {\n      this.content = this.bucketSize;\n      return;\n    }\n\n    var now = +new Date();\n    var deltaMS = Math.max(now - this.lastDrip, 0);\n    this.lastDrip = now;\n    var dripAmount = deltaMS * (this.tokensPerInterval / this.interval);\n    this.content = Math.min(this.content + dripAmount, this.bucketSize);\n  }\n};\nmodule.exports = TokenBucket;","map":{"version":3,"sources":["/home/invidam/hamburger_calender/client/node_modules/limiter/lib/tokenBucket.js"],"names":["TokenBucket","bucketSize","tokensPerInterval","interval","parentBucket","Error","content","lastDrip","Date","prototype","removeTokens","count","callback","self","process","nextTick","bind","Number","POSITIVE_INFINITY","drip","comeBackLater","err","remainingTokens","Math","min","waitInterval","ceil","setTimeout","tryRemoveTokens","now","deltaMS","max","dripAmount","module","exports"],"mappings":"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","sourcesContent":["\r\n/**\r\n * A hierarchical token bucket for rate limiting. See\r\n * http://en.wikipedia.org/wiki/Token_bucket for more information.\r\n * @author John Hurliman <jhurliman@cull.tv>\r\n *\r\n * @param {Number} bucketSize Maximum number of tokens to hold in the bucket.\r\n *  Also known as the burst rate.\r\n * @param {Number} tokensPerInterval Number of tokens to drip into the bucket\r\n *  over the course of one interval.\r\n * @param {String|Number} interval The interval length in milliseconds, or as\r\n *  one of the following strings: 'second', 'minute', 'hour', day'.\r\n * @param {TokenBucket} parentBucket Optional. A token bucket that will act as\r\n *  the parent of this bucket.\r\n */\r\nvar TokenBucket = function(bucketSize, tokensPerInterval, interval, parentBucket) {\r\n  this.bucketSize = bucketSize;\r\n  this.tokensPerInterval = tokensPerInterval;\r\n\r\n  if (typeof interval === 'string') {\r\n    switch (interval) {\r\n      case 'sec': case 'second':\r\n        this.interval = 1000; break;\r\n      case 'min': case 'minute':\r\n        this.interval = 1000 * 60; break;\r\n      case 'hr': case 'hour':\r\n        this.interval = 1000 * 60 * 60; break;\r\n      case 'day':\r\n        this.interval = 1000 * 60 * 60 * 24; break;\r\n      default:\r\n        throw new Error('Invaid interval ' + interval);\r\n    }\r\n  } else {\r\n    this.interval = interval;\r\n  }\r\n\r\n  this.parentBucket = parentBucket;\r\n  this.content = 0;\r\n  this.lastDrip = +new Date();\r\n};\r\n\r\nTokenBucket.prototype = {\r\n  bucketSize: 1,\r\n  tokensPerInterval: 1,\r\n  interval: 1000,\r\n  parentBucket: null,\r\n  content: 0,\r\n  lastDrip: 0,\r\n\r\n  /**\r\n   * Remove the requested number of tokens and fire the given callback. If the\r\n   * bucket (and any parent buckets) contains enough tokens this will happen\r\n   * immediately. Otherwise, the removal and callback will happen when enough\r\n   * tokens become available.\r\n   * @param {Number} count The number of tokens to remove.\r\n   * @param {Function} callback(err, remainingTokens)\r\n   * @returns {Boolean} True if the callback was fired immediately, otherwise\r\n   *  false.\r\n   */\r\n  removeTokens: function(count, callback) {\r\n    var self = this;\r\n\r\n    // Is this an infinite size bucket?\r\n    if (!this.bucketSize) {\r\n      process.nextTick(callback.bind(null, null, count, Number.POSITIVE_INFINITY));\r\n      return true;\r\n    }\r\n\r\n    // Make sure the bucket can hold the requested number of tokens\r\n    if (count > this.bucketSize) {\r\n      process.nextTick(callback.bind(null, 'Requested tokens ' + count + ' exceeds bucket size ' +\r\n        this.bucketSize, null));\r\n      return false;\r\n    }\r\n\r\n    // Drip new tokens into this bucket\r\n    this.drip();\r\n\r\n    // If we don't have enough tokens in this bucket, come back later\r\n    if (count > this.content)\r\n      return comeBackLater();\r\n\r\n    if (this.parentBucket) {\r\n      // Remove the requested from the parent bucket first\r\n      return this.parentBucket.removeTokens(count, function(err, remainingTokens) {\r\n        if (err) return callback(err, null);\r\n\r\n        // Check that we still have enough tokens in this bucket\r\n        if (count > self.content)\r\n          return comeBackLater();\r\n\r\n        // Tokens were removed from the parent bucket, now remove them from\r\n        // this bucket and fire the callback. Note that we look at the current\r\n        // bucket and parent bucket's remaining tokens and return the smaller\r\n        // of the two values\r\n        self.content -= count;\r\n        callback(null, Math.min(remainingTokens, self.content));\r\n      });\r\n    } else {\r\n      // Remove the requested tokens from this bucket and fire the callback\r\n      this.content -= count;\r\n      process.nextTick(callback.bind(null, null, this.content));\r\n      return true;\r\n    }\r\n\r\n    function comeBackLater() {\r\n      // How long do we need to wait to make up the difference in tokens?\r\n      var waitInterval = Math.ceil(\r\n        (count - self.content) * (self.interval / self.tokensPerInterval));\r\n      setTimeout(function() { self.removeTokens(count, callback); }, waitInterval);\r\n      return false;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Attempt to remove the requested number of tokens and return immediately.\r\n   * If the bucket (and any parent buckets) contains enough tokens this will\r\n   * return true, otherwise false is returned.\r\n   * @param {Number} count The number of tokens to remove.\r\n   * @param {Boolean} True if the tokens were successfully removed, otherwise\r\n   *  false.\r\n   */\r\n  tryRemoveTokens: function(count) {\r\n    // Is this an infinite size bucket?\r\n    if (!this.bucketSize)\r\n      return true;\r\n\r\n    // Make sure the bucket can hold the requested number of tokens\r\n    if (count > this.bucketSize)\r\n      return false;\r\n\r\n    // Drip new tokens into this bucket\r\n    this.drip();\r\n\r\n    // If we don't have enough tokens in this bucket, return false\r\n    if (count > this.content)\r\n      return false;\r\n\r\n    // Try to remove the requested tokens from the parent bucket\r\n    if (this.parentBucket && !this.parentBucket.tryRemoveTokens(count))\r\n      return false;\r\n\r\n    // Remove the requested tokens from this bucket and return\r\n    this.content -= count;\r\n    return true;\r\n  },\r\n\r\n  /**\r\n   * Add any new tokens to the bucket since the last drip.\r\n   * @returns {Boolean} True if new tokens were added, otherwise false.\r\n   */\r\n  drip: function() {\r\n    if (!this.tokensPerInterval) {\r\n      this.content = this.bucketSize;\r\n      return;\r\n    }\r\n\r\n    var now = +new Date();\r\n    var deltaMS = Math.max(now - this.lastDrip, 0);\r\n    this.lastDrip = now;\r\n\r\n    var dripAmount = deltaMS * (this.tokensPerInterval / this.interval);\r\n    this.content = Math.min(this.content + dripAmount, this.bucketSize);\r\n  }\r\n};\r\n\r\nmodule.exports = TokenBucket;\r\n"]},"metadata":{},"sourceType":"script"}