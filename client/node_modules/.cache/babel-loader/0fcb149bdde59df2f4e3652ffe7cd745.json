{"ast":null,"code":"\"use strict\";\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spread = this && this.__spread || function () {\n  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n\n  return ar;\n};\n\nvar __values = this && this.__values || function (o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n      i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar lru_cache_1 = __importDefault(require(\"lru-cache\"));\n\nvar events_1 = require(\"events\");\n\nvar lodash_clonedeep_1 = __importDefault(require(\"lodash.clonedeep\"));\n\nvar freeze_1 = require(\"./freeze\");\n\nvar sync_1 = require(\"./sync\");\n\nfunction asyncMemoizer(options) {\n  var cache = new lru_cache_1.default(options);\n  var load = options.load;\n  var hash = options.hash;\n  var bypass = options.bypass;\n  var itemMaxAge = options.itemMaxAge;\n  var freeze = options.freeze;\n  var clone = options.clone;\n  var queueMaxAge = options.queueMaxAge || 1000;\n  var loading = new Map();\n  var emitter = new events_1.EventEmitter();\n  var memoizerMethods = Object.assign({\n    del: del,\n    reset: function () {\n      return cache.reset();\n    },\n    keys: cache.keys.bind(cache),\n    on: emitter.on.bind(emitter),\n    once: emitter.once.bind(emitter)\n  }, options);\n\n  if (options.disable) {\n    return Object.assign(load, memoizerMethods);\n  }\n\n  function del() {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    var key = hash.apply(void 0, __spread(args));\n    cache.del(key);\n  }\n\n  function add(key, parameters, result) {\n    if (freeze) {\n      result.forEach(freeze_1.deepFreeze);\n    }\n\n    if (itemMaxAge) {\n      cache.set(key, result, itemMaxAge.apply(void 0, __spread(parameters.concat(result))));\n    } else {\n      cache.set(key, result);\n    }\n  }\n\n  function runCallbacks(callbacks, args) {\n    var e_1, _a;\n\n    try {\n      for (var callbacks_1 = __values(callbacks), callbacks_1_1 = callbacks_1.next(); !callbacks_1_1.done; callbacks_1_1 = callbacks_1.next()) {\n        var callback = callbacks_1_1.value; // Simulate async call when returning from cache\n        // and yield between callback resolution\n\n        if (clone) {\n          setImmediate.apply(void 0, __spread([callback], args.map(lodash_clonedeep_1.default)));\n        } else {\n          setImmediate.apply(void 0, __spread([callback], args));\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (callbacks_1_1 && !callbacks_1_1.done && (_a = callbacks_1.return)) _a.call(callbacks_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  }\n\n  function emit(event) {\n    var parameters = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      parameters[_i - 1] = arguments[_i];\n    }\n\n    emitter.emit.apply(emitter, __spread([event], parameters));\n  }\n\n  function memoizedFunction() {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    var parameters = args.slice(0, -1);\n    var callback = args.slice(-1).pop();\n    var key;\n\n    if (bypass && bypass.apply(void 0, __spread(parameters))) {\n      emit.apply(void 0, __spread(['miss'], parameters));\n      return load.apply(void 0, __spread(args));\n    }\n\n    if (parameters.length === 0 && !hash) {\n      //the load function only receives callback.\n      key = '_';\n    } else {\n      key = hash.apply(void 0, __spread(parameters));\n    }\n\n    var fromCache = cache.get(key);\n\n    if (fromCache) {\n      emit.apply(void 0, __spread(['hit'], parameters)); // found, invoke callback\n\n      return runCallbacks([callback], [null].concat(fromCache));\n    }\n\n    var pendingLoad = loading.get(key);\n\n    if (pendingLoad && pendingLoad.expiresAt > Date.now()) {\n      // request already in progress, queue and return\n      pendingLoad.queue.push(callback);\n      emit.apply(void 0, __spread(['queue'], parameters));\n      return;\n    }\n\n    emit.apply(void 0, __spread(['miss'], parameters));\n    var started = Date.now(); // no pending request or not resolved before expiration\n    // create a new queue and invoke load\n\n    var queue = [callback];\n    loading.set(key, {\n      queue: queue,\n      expiresAt: started + queueMaxAge\n    });\n\n    var loadHandler = function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      var err = args[0];\n\n      if (!err) {\n        add(key, parameters, args.slice(1));\n      } // this can potentially delete a different queue than `queue` if\n      // this callback was called after expiration.\n      // that will only cause a new call to be performed and a new queue to be\n      // created\n\n\n      loading.delete(key);\n      emit.apply(void 0, __spread(['loaded', Date.now() - started], parameters));\n      runCallbacks(queue, args);\n    };\n\n    load.apply(void 0, __spread(parameters, [loadHandler]));\n  }\n\n  ;\n  return Object.assign(memoizedFunction, memoizerMethods);\n}\n\nexports.asyncMemoizer = asyncMemoizer;\nasyncMemoizer.sync = sync_1.syncMemoizer;","map":{"version":3,"sources":["../src/async.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spread = (this && this.__spread) || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n    return ar;\n};\nvar __values = (this && this.__values) || function (o) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar lru_cache_1 = __importDefault(require(\"lru-cache\"));\nvar events_1 = require(\"events\");\nvar lodash_clonedeep_1 = __importDefault(require(\"lodash.clonedeep\"));\nvar freeze_1 = require(\"./freeze\");\nvar sync_1 = require(\"./sync\");\nfunction asyncMemoizer(options) {\n    var cache = new lru_cache_1.default(options);\n    var load = options.load;\n    var hash = options.hash;\n    var bypass = options.bypass;\n    var itemMaxAge = options.itemMaxAge;\n    var freeze = options.freeze;\n    var clone = options.clone;\n    var queueMaxAge = options.queueMaxAge || 1000;\n    var loading = new Map();\n    var emitter = new events_1.EventEmitter();\n    var memoizerMethods = Object.assign({\n        del: del,\n        reset: function () { return cache.reset(); },\n        keys: cache.keys.bind(cache),\n        on: emitter.on.bind(emitter),\n        once: emitter.once.bind(emitter)\n    }, options);\n    if (options.disable) {\n        return Object.assign(load, memoizerMethods);\n    }\n    function del() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var key = hash.apply(void 0, __spread(args));\n        cache.del(key);\n    }\n    function add(key, parameters, result) {\n        if (freeze) {\n            result.forEach(freeze_1.deepFreeze);\n        }\n        if (itemMaxAge) {\n            cache.set(key, result, itemMaxAge.apply(void 0, __spread(parameters.concat(result))));\n        }\n        else {\n            cache.set(key, result);\n        }\n    }\n    function runCallbacks(callbacks, args) {\n        var e_1, _a;\n        try {\n            for (var callbacks_1 = __values(callbacks), callbacks_1_1 = callbacks_1.next(); !callbacks_1_1.done; callbacks_1_1 = callbacks_1.next()) {\n                var callback = callbacks_1_1.value;\n                // Simulate async call when returning from cache\n                // and yield between callback resolution\n                if (clone) {\n                    setImmediate.apply(void 0, __spread([callback], args.map(lodash_clonedeep_1.default)));\n                }\n                else {\n                    setImmediate.apply(void 0, __spread([callback], args));\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (callbacks_1_1 && !callbacks_1_1.done && (_a = callbacks_1.return)) _a.call(callbacks_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    }\n    function emit(event) {\n        var parameters = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            parameters[_i - 1] = arguments[_i];\n        }\n        emitter.emit.apply(emitter, __spread([event], parameters));\n    }\n    function memoizedFunction() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var parameters = args.slice(0, -1);\n        var callback = args.slice(-1).pop();\n        var key;\n        if (bypass && bypass.apply(void 0, __spread(parameters))) {\n            emit.apply(void 0, __spread(['miss'], parameters));\n            return load.apply(void 0, __spread(args));\n        }\n        if (parameters.length === 0 && !hash) {\n            //the load function only receives callback.\n            key = '_';\n        }\n        else {\n            key = hash.apply(void 0, __spread(parameters));\n        }\n        var fromCache = cache.get(key);\n        if (fromCache) {\n            emit.apply(void 0, __spread(['hit'], parameters));\n            // found, invoke callback\n            return runCallbacks([callback], [null].concat(fromCache));\n        }\n        var pendingLoad = loading.get(key);\n        if (pendingLoad && pendingLoad.expiresAt > Date.now()) {\n            // request already in progress, queue and return\n            pendingLoad.queue.push(callback);\n            emit.apply(void 0, __spread(['queue'], parameters));\n            return;\n        }\n        emit.apply(void 0, __spread(['miss'], parameters));\n        var started = Date.now();\n        // no pending request or not resolved before expiration\n        // create a new queue and invoke load\n        var queue = [callback];\n        loading.set(key, {\n            queue: queue,\n            expiresAt: started + queueMaxAge\n        });\n        var loadHandler = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            var err = args[0];\n            if (!err) {\n                add(key, parameters, args.slice(1));\n            }\n            // this can potentially delete a different queue than `queue` if\n            // this callback was called after expiration.\n            // that will only cause a new call to be performed and a new queue to be\n            // created\n            loading.delete(key);\n            emit.apply(void 0, __spread(['loaded', Date.now() - started], parameters));\n            runCallbacks(queue, args);\n        };\n        load.apply(void 0, __spread(parameters, [loadHandler]));\n    }\n    ;\n    return Object.assign(memoizedFunction, memoizerMethods);\n}\nexports.asyncMemoizer = asyncMemoizer;\nasyncMemoizer.sync = sync_1.syncMemoizer;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXN5bmMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvYXN5bmMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSx3REFBNEI7QUFDNUIsaUNBQXNDO0FBQ3RDLHNFQUF5QztBQUN6QyxtQ0FBc0M7QUFDdEMsK0JBQXNDO0FBOEV0QyxTQUFTLGFBQWEsQ0FDbEIsT0FBcUQ7SUFFdkQsSUFBTSxLQUFLLEdBQVEsSUFBSSxtQkFBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ3BDLElBQU0sSUFBSSxHQUFTLE9BQU8sQ0FBQyxJQUFJLENBQUM7SUFDaEMsSUFBTSxJQUFJLEdBQVMsT0FBTyxDQUFDLElBQUksQ0FBQztJQUNoQyxJQUFNLE1BQU0sR0FBTyxPQUFPLENBQUMsTUFBTSxDQUFDO0lBQ2xDLElBQU0sVUFBVSxHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUM7SUFDdEMsSUFBTSxNQUFNLEdBQU8sT0FBTyxDQUFDLE1BQU0sQ0FBQztJQUNsQyxJQUFNLEtBQUssR0FBUSxPQUFPLENBQUMsS0FBSyxDQUFDO0lBQ2pDLElBQU0sV0FBVyxHQUFHLE9BQU8sQ0FBQyxXQUFXLElBQUksSUFBSSxDQUFDO0lBQ2hELElBQU0sT0FBTyxHQUFNLElBQUksR0FBRyxFQUF1QixDQUFDO0lBQ2xELElBQU0sT0FBTyxHQUFNLElBQUkscUJBQVksRUFBRSxDQUFDO0lBRXRDLElBQU0sZUFBZSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7UUFDcEMsR0FBRyxLQUFBO1FBQ0gsS0FBSyxFQUFFLGNBQU0sT0FBQSxLQUFLLENBQUMsS0FBSyxFQUFFLEVBQWIsQ0FBYTtRQUMxQixJQUFJLEVBQUUsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDO1FBQzVCLEVBQUUsRUFBRSxPQUFPLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUM7UUFDNUIsSUFBSSxFQUFFLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQztLQUNqQyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBRVosSUFBSSxPQUFPLENBQUMsT0FBTyxFQUFFO1FBQ25CLE9BQU8sTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEVBQUUsZUFBZSxDQUFDLENBQUM7S0FDN0M7SUFFRCxTQUFTLEdBQUc7UUFBQyxjQUFjO2FBQWQsVUFBYyxFQUFkLHFCQUFjLEVBQWQsSUFBYztZQUFkLHlCQUFjOztRQUN6QixJQUFNLEdBQUcsR0FBRyxJQUFJLHdCQUFJLElBQUksRUFBQyxDQUFDO1FBQzFCLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDakIsQ0FBQztJQUVELFNBQVMsR0FBRyxDQUFDLEdBQVcsRUFBRSxVQUFpQixFQUFFLE1BQWE7UUFDeEQsSUFBSSxNQUFNLEVBQUU7WUFDVixNQUFNLENBQUMsT0FBTyxDQUFDLG1CQUFVLENBQUMsQ0FBQztTQUM1QjtRQUVELElBQUksVUFBVSxFQUFFO1lBQ2QsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsTUFBTSxFQUFFLFVBQVUsd0JBQUksVUFBVSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsR0FBRSxDQUFDO1NBQ2xFO2FBQU07WUFDTCxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxNQUFNLENBQUMsQ0FBQztTQUN4QjtJQUNILENBQUM7SUFFRCxTQUFTLFlBQVksQ0FBQyxTQUFxQixFQUFFLElBQVc7OztZQUN0RCxLQUF1QixJQUFBLGNBQUEsU0FBQSxTQUFTLENBQUEsb0NBQUEsMkRBQUU7Z0JBQTdCLElBQU0sUUFBUSxzQkFBQTtnQkFDakIsZ0RBQWdEO2dCQUNoRCx3Q0FBd0M7Z0JBQ3hDLElBQUksS0FBSyxFQUFFO29CQUNULFlBQVkseUJBQUMsUUFBUSxHQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsMEJBQVMsQ0FBQyxHQUFFO2lCQUNoRDtxQkFBTTtvQkFDTCxZQUFZLHlCQUFDLFFBQVEsR0FBSyxJQUFJLEdBQUU7aUJBQ2pDO2FBQ0Y7Ozs7Ozs7OztJQUNILENBQUM7SUFFRCxTQUFTLElBQUksQ0FBQyxLQUFhO1FBQUUsb0JBQW9CO2FBQXBCLFVBQW9CLEVBQXBCLHFCQUFvQixFQUFwQixJQUFvQjtZQUFwQixtQ0FBb0I7O1FBQy9DLE9BQU8sQ0FBQyxJQUFJLE9BQVosT0FBTyxZQUFNLEtBQUssR0FBSyxVQUFVLEdBQUU7SUFDckMsQ0FBQztJQUVELFNBQVMsZ0JBQWdCO1FBQUMsY0FBYzthQUFkLFVBQWMsRUFBZCxxQkFBYyxFQUFkLElBQWM7WUFBZCx5QkFBYzs7UUFDdEMsSUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNyQyxJQUFNLFFBQVEsR0FBYSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDaEQsSUFBSSxHQUFXLENBQUM7UUFFaEIsSUFBSSxNQUFNLElBQUksTUFBTSx3QkFBSSxVQUFVLEVBQUMsRUFBRTtZQUNuQyxJQUFJLHlCQUFDLE1BQU0sR0FBSyxVQUFVLEdBQUU7WUFDNUIsT0FBTyxJQUFJLHdCQUFJLElBQUksR0FBRTtTQUN0QjtRQUVELElBQUksVUFBVSxDQUFDLE1BQU0sS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUU7WUFDcEMsMkNBQTJDO1lBQzNDLEdBQUcsR0FBRyxHQUFHLENBQUM7U0FDWDthQUFNO1lBQ0wsR0FBRyxHQUFHLElBQUksd0JBQUksVUFBVSxFQUFDLENBQUM7U0FDM0I7UUFFRCxJQUFNLFNBQVMsR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ2pDLElBQUksU0FBUyxFQUFFO1lBQ2IsSUFBSSx5QkFBQyxLQUFLLEdBQUssVUFBVSxHQUFFO1lBQzNCLHlCQUF5QjtZQUN6QixPQUFPLFlBQVksQ0FBQyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7U0FDM0Q7UUFFRCxJQUFNLFdBQVcsR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3JDLElBQUksV0FBVyxJQUFJLFdBQVcsQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxFQUFFO1lBQ3JELGdEQUFnRDtZQUNoRCxXQUFXLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUNqQyxJQUFJLHlCQUFDLE9BQU8sR0FBSyxVQUFVLEdBQUU7WUFDN0IsT0FBTztTQUNSO1FBRUQsSUFBSSx5QkFBQyxNQUFNLEdBQUssVUFBVSxHQUFFO1FBRTVCLElBQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUUzQix1REFBdUQ7UUFDdkQscUNBQXFDO1FBQ3JDLElBQU0sS0FBSyxHQUFHLENBQUUsUUFBUSxDQUFFLENBQUM7UUFDM0IsT0FBTyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUU7WUFDZixLQUFLLE9BQUE7WUFDTCxTQUFTLEVBQUUsT0FBTyxHQUFHLFdBQVc7U0FDakMsQ0FBQyxDQUFDO1FBRUgsSUFBTSxXQUFXLEdBQUc7WUFBQyxjQUFjO2lCQUFkLFVBQWMsRUFBZCxxQkFBYyxFQUFkLElBQWM7Z0JBQWQseUJBQWM7O1lBQ2pDLElBQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNwQixJQUFJLENBQUMsR0FBRyxFQUFFO2dCQUNSLEdBQUcsQ0FBQyxHQUFHLEVBQUUsVUFBVSxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUNyQztZQUVELGdFQUFnRTtZQUNoRSw2Q0FBNkM7WUFDN0Msd0VBQXdFO1lBQ3hFLFVBQVU7WUFDVixPQUFPLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBRXBCLElBQUkseUJBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxPQUFPLEdBQUssVUFBVSxHQUFFO1lBQ3BELFlBQVksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDNUIsQ0FBQyxDQUFDO1FBRUYsSUFBSSx3QkFBSSxVQUFVLEdBQUUsV0FBVyxJQUFFO0lBQ25DLENBQUM7SUFBQSxDQUFDO0lBRUYsT0FBTyxNQUFNLENBQUMsTUFBTSxDQUFDLGdCQUFnQixFQUFFLGVBQWUsQ0FBQyxDQUFDO0FBQzFELENBQUM7QUFJUSxzQ0FBYTtBQUZ0QixhQUFhLENBQUMsSUFBSSxHQUFHLG1CQUFZLENBQUMifQ=="]},"metadata":{},"sourceType":"script"}