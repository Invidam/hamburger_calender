{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.generateServiceStub = void 0;\n/* global window */\n\n/* global AbortController */\n\nconst node_fetch_1 = require(\"node-fetch\");\n\nconst abort_controller_1 = require(\"abort-controller\");\n\nconst featureDetection_1 = require(\"./featureDetection\");\n\nfunction generateServiceStub(rpcs, protocol, servicePath, servicePort, authClient, requestEncoder, responseDecoder) {\n  const fetch = featureDetection_1.hasWindowFetch() ? window.fetch : node_fetch_1.default;\n  const serviceStub = {};\n\n  for (const [rpcName, rpc] of Object.entries(rpcs)) {\n    serviceStub[rpcName] = (request, options, _metadata, callback) => {\n      // We cannot use async-await in this function because we need to return the canceller object as soon as possible.\n      // Using plain old promises instead.\n      const cancelController = featureDetection_1.hasAbortController() ? new AbortController() : new abort_controller_1.AbortController();\n      const cancelSignal = cancelController.signal;\n      let cancelRequested = false;\n      const fetchParameters = requestEncoder(rpc, protocol, servicePath, servicePort, request);\n      const url = fetchParameters.url;\n      const headers = fetchParameters.headers;\n\n      for (const key of Object.keys(options)) {\n        headers[key] = options[key][0];\n      }\n\n      authClient.getRequestHeaders().then(authHeader => {\n        const fetchRequest = {\n          headers: { ...authHeader,\n            ...headers\n          },\n          body: fetchParameters.body,\n          method: fetchParameters.method,\n          signal: cancelSignal\n        };\n\n        if (fetchParameters.method === 'get' || fetchParameters.method === 'delete') {\n          delete fetchRequest['body'];\n        }\n\n        return fetch(url, fetchRequest);\n      }).then(response => {\n        return Promise.all([Promise.resolve(response.ok), response.arrayBuffer()]);\n      }).then(([ok, buffer]) => {\n        const response = responseDecoder(rpc, ok, buffer);\n        callback(null, response);\n      }).catch(err => {\n        if (!cancelRequested || err.name !== 'AbortError') {\n          callback(err);\n        }\n      });\n      return {\n        cancel: () => {\n          cancelRequested = true;\n          cancelController.abort();\n        }\n      };\n    };\n  }\n\n  return serviceStub;\n}\n\nexports.generateServiceStub = generateServiceStub;","map":{"version":3,"sources":["../../src/fallbackServiceStub.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.generateServiceStub = void 0;\n/* global window */\n/* global AbortController */\nconst node_fetch_1 = require(\"node-fetch\");\nconst abort_controller_1 = require(\"abort-controller\");\nconst featureDetection_1 = require(\"./featureDetection\");\nfunction generateServiceStub(rpcs, protocol, servicePath, servicePort, authClient, requestEncoder, responseDecoder) {\n    const fetch = featureDetection_1.hasWindowFetch()\n        ? window.fetch\n        : node_fetch_1.default;\n    const serviceStub = {};\n    for (const [rpcName, rpc] of Object.entries(rpcs)) {\n        serviceStub[rpcName] = (request, options, _metadata, callback) => {\n            // We cannot use async-await in this function because we need to return the canceller object as soon as possible.\n            // Using plain old promises instead.\n            const cancelController = featureDetection_1.hasAbortController()\n                ? new AbortController()\n                : new abort_controller_1.AbortController();\n            const cancelSignal = cancelController.signal;\n            let cancelRequested = false;\n            const fetchParameters = requestEncoder(rpc, protocol, servicePath, servicePort, request);\n            const url = fetchParameters.url;\n            const headers = fetchParameters.headers;\n            for (const key of Object.keys(options)) {\n                headers[key] = options[key][0];\n            }\n            authClient\n                .getRequestHeaders()\n                .then(authHeader => {\n                const fetchRequest = {\n                    headers: {\n                        ...authHeader,\n                        ...headers,\n                    },\n                    body: fetchParameters.body,\n                    method: fetchParameters.method,\n                    signal: cancelSignal,\n                };\n                if (fetchParameters.method === 'get' ||\n                    fetchParameters.method === 'delete') {\n                    delete fetchRequest['body'];\n                }\n                return fetch(url, fetchRequest);\n            })\n                .then((response) => {\n                return Promise.all([\n                    Promise.resolve(response.ok),\n                    response.arrayBuffer(),\n                ]);\n            })\n                .then(([ok, buffer]) => {\n                const response = responseDecoder(rpc, ok, buffer);\n                callback(null, response);\n            })\n                .catch((err) => {\n                if (!cancelRequested || err.name !== 'AbortError') {\n                    callback(err);\n                }\n            });\n            return {\n                cancel: () => {\n                    cancelRequested = true;\n                    cancelController.abort();\n                },\n            };\n        };\n    }\n    return serviceStub;\n}\nexports.generateServiceStub = generateServiceStub;\n//# sourceMappingURL=fallbackServiceStub.js.map"]},"metadata":{},"sourceType":"script"}