{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.transcode = exports.getFieldNameOnBehavior = exports.isRequiredField = exports.isProto3OptionalField = exports.requestChangeCaseAndCleanup = exports.flattenObject = exports.match = exports.applyPattern = exports.encodeWithoutSlashes = exports.encodeWithSlashes = exports.buildQueryStringComponents = exports.deleteField = exports.deepCopy = exports.getField = void 0;\n\nconst util_1 = require(\"./util\");\n\nconst httpOptionName = '(google.api.http)';\nconst fieldBehaviorOptionName = '(google.api.field_behavior)';\nconst proto3OptionalName = 'proto3_optional'; // List of methods as defined in google/api/http.proto (see HttpRule)\n\nconst supportedHttpMethods = ['get', 'post', 'put', 'patch', 'delete'];\n\nfunction getField(request, field) {\n  const parts = field.split('.');\n  let value = request;\n\n  for (const part of parts) {\n    if (typeof value !== 'object') {\n      return undefined;\n    }\n\n    value = value[part];\n  }\n\n  if (typeof value === 'object' && !Array.isArray(value) && value !== null) {\n    return undefined;\n  }\n\n  return value;\n}\n\nexports.getField = getField;\n\nfunction deepCopy(request) {\n  if (typeof request !== 'object' || request === null) {\n    return request;\n  }\n\n  const copy = Object.assign({}, request);\n\n  for (const key in copy) {\n    if (Array.isArray(copy[key])) {\n      copy[key] = copy[key].map(deepCopy);\n    } else if (typeof copy[key] === 'object' && copy[key] !== null) {\n      copy[key] = deepCopy(copy[key]);\n    }\n  }\n\n  return copy;\n}\n\nexports.deepCopy = deepCopy;\n\nfunction deleteField(request, field) {\n  const parts = field.split('.');\n\n  while (parts.length > 1) {\n    if (typeof request !== 'object') {\n      return;\n    }\n\n    const part = parts.shift();\n    request = request[part];\n  }\n\n  const part = parts.shift();\n\n  if (typeof request !== 'object') {\n    return;\n  }\n\n  delete request[part];\n}\n\nexports.deleteField = deleteField;\n\nfunction buildQueryStringComponents(request, prefix = '') {\n  const resultList = [];\n\n  for (const key in request) {\n    if (Array.isArray(request[key])) {\n      for (const value of request[key]) {\n        resultList.push(`${prefix}${encodeWithoutSlashes(key)}=${encodeWithoutSlashes(value.toString())}`);\n      }\n    } else if (typeof request[key] === 'object' && request[key] !== null) {\n      resultList.push(...buildQueryStringComponents(request[key], `${key}.`));\n    } else {\n      resultList.push(`${prefix}${encodeWithoutSlashes(key)}=${encodeWithoutSlashes(request[key] === null ? 'null' : request[key].toString())}`);\n    }\n  }\n\n  return resultList;\n}\n\nexports.buildQueryStringComponents = buildQueryStringComponents;\n\nfunction encodeWithSlashes(str) {\n  return str.split('').map(c => c.match(/[-_.~0-9a-zA-Z]/) ? c : encodeURIComponent(c)).join('');\n}\n\nexports.encodeWithSlashes = encodeWithSlashes;\n\nfunction encodeWithoutSlashes(str) {\n  return str.split('').map(c => c.match(/[-_.~0-9a-zA-Z/]/) ? c : encodeURIComponent(c)).join('');\n}\n\nexports.encodeWithoutSlashes = encodeWithoutSlashes;\n\nfunction escapeRegExp(str) {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\nfunction applyPattern(pattern, fieldValue) {\n  if (!pattern || pattern === '*') {\n    return encodeWithSlashes(fieldValue);\n  }\n\n  if (!pattern.includes('*') && pattern !== fieldValue) {\n    return undefined;\n  } // since we're converting the pattern to a regex, make necessary precautions:\n\n\n  const regex = new RegExp('^' + escapeRegExp(pattern).replace(/\\\\\\*\\\\\\*/g, '(.+)').replace(/\\\\\\*/g, '([^/]+)') + '$');\n\n  if (!fieldValue.match(regex)) {\n    return undefined;\n  }\n\n  return encodeWithoutSlashes(fieldValue);\n}\n\nexports.applyPattern = applyPattern;\n\nfunction match(request, pattern) {\n  let url = pattern;\n  const matchedFields = [];\n\n  for (;;) {\n    const match = url.match(/^(.*)\\{([^}=]+)(?:=([^}]*))?\\}(.*)/);\n\n    if (!match) {\n      break;\n    }\n\n    const [, before, field, pattern, after] = match;\n    matchedFields.push(field);\n    const fieldValue = getField(request, field);\n\n    if (typeof fieldValue === 'undefined') {\n      return undefined;\n    }\n\n    const appliedPattern = applyPattern(pattern, fieldValue === null ? 'null' : fieldValue.toString());\n\n    if (typeof appliedPattern === 'undefined') {\n      return undefined;\n    }\n\n    url = before + appliedPattern + after;\n  }\n\n  return {\n    matchedFields,\n    url\n  };\n}\n\nexports.match = match;\n\nfunction flattenObject(request) {\n  const result = {};\n\n  for (const key in request) {\n    if (typeof request[key] === 'undefined') {\n      continue;\n    }\n\n    if (Array.isArray(request[key])) {\n      // According to the http.proto comments, a repeated field may only\n      // contain primitive types, so no extra recursion here.\n      result[key] = request[key];\n      continue;\n    }\n\n    if (typeof request[key] === 'object' && request[key] !== null) {\n      const nested = flattenObject(request[key]);\n\n      for (const nestedKey in nested) {\n        result[`${key}.${nestedKey}`] = nested[nestedKey];\n      }\n\n      continue;\n    }\n\n    result[key] = request[key];\n  }\n\n  return result;\n}\n\nexports.flattenObject = flattenObject;\n\nfunction requestChangeCaseAndCleanup(request, caseChangeFunc) {\n  if (!request || typeof request !== 'object') {\n    return request;\n  }\n\n  const convertedRequest = {};\n\n  for (const field in request) {\n    // cleaning up inherited properties\n    if (!Object.prototype.hasOwnProperty.call(request, field)) {\n      continue;\n    }\n\n    const convertedField = caseChangeFunc(field);\n    const value = request[field];\n\n    if (Array.isArray(value)) {\n      convertedRequest[convertedField] = value.map(v => requestChangeCaseAndCleanup(v, caseChangeFunc));\n    } else {\n      convertedRequest[convertedField] = requestChangeCaseAndCleanup(value, caseChangeFunc);\n    }\n  }\n\n  return convertedRequest;\n}\n\nexports.requestChangeCaseAndCleanup = requestChangeCaseAndCleanup;\n\nfunction isProto3OptionalField(field) {\n  return field && field.options && field.options[proto3OptionalName];\n}\n\nexports.isProto3OptionalField = isProto3OptionalField;\n\nfunction isRequiredField(field) {\n  return field && field.options && field.options[fieldBehaviorOptionName] === 'REQUIRED';\n}\n\nexports.isRequiredField = isRequiredField;\n\nfunction getFieldNameOnBehavior(fields) {\n  const requiredFields = new Set();\n  const optionalFields = new Set();\n\n  for (const fieldName in fields) {\n    const field = fields[fieldName];\n\n    if (isRequiredField(field)) {\n      requiredFields.add(fieldName);\n    }\n\n    if (isProto3OptionalField(field)) {\n      optionalFields.add(fieldName);\n    }\n  }\n\n  return {\n    requiredFields,\n    optionalFields\n  };\n}\n\nexports.getFieldNameOnBehavior = getFieldNameOnBehavior;\n\nfunction transcode(request, parsedOptions, requestFields) {\n  const {\n    requiredFields,\n    optionalFields\n  } = getFieldNameOnBehavior(requestFields); // all fields annotated as REQUIRED MUST be emitted in the body.\n\n  for (const requiredField of requiredFields) {\n    if (!(requiredField in request) || request[requiredField] === 'undefined') {\n      throw new Error(`Required field ${requiredField} is not present in the request.`);\n    }\n  } // request is supposed to have keys in camelCase.\n\n\n  const snakeRequest = requestChangeCaseAndCleanup(request, util_1.camelToSnakeCase);\n  const httpRules = [];\n\n  for (const option of parsedOptions) {\n    if (!(httpOptionName in option)) {\n      continue;\n    }\n\n    const httpRule = option[httpOptionName];\n    httpRules.push(httpRule);\n\n    if (httpRule === null || httpRule === void 0 ? void 0 : httpRule.additional_bindings) {\n      const additionalBindings = Array.isArray(httpRule.additional_bindings) ? httpRule.additional_bindings : [httpRule.additional_bindings];\n      httpRules.push(...additionalBindings);\n    }\n  }\n\n  for (const httpRule of httpRules) {\n    for (const httpMethod of supportedHttpMethods) {\n      if (!(httpMethod in httpRule)) {\n        continue;\n      }\n\n      const pathTemplate = httpRule[httpMethod];\n      const matchResult = match(snakeRequest, pathTemplate);\n\n      if (typeof matchResult === 'undefined') {\n        continue;\n      }\n\n      const {\n        url,\n        matchedFields\n      } = matchResult;\n\n      if (httpRule.body === '*') {\n        // all fields except the matched fields go to request data\n        const data = deepCopy(snakeRequest);\n\n        for (const field of matchedFields) {\n          deleteField(data, field);\n        } // Remove unset proto3 optional field from the request body.\n\n\n        for (const key in data) {\n          if (optionalFields.has(util_1.snakeToCamelCase(key)) && (!(key in snakeRequest) || snakeRequest[key] === 'undefined')) {\n            delete data[key];\n          }\n        } // HTTP endpoint expects camelCase but we have snake_case at this point\n\n\n        const camelCaseData = requestChangeCaseAndCleanup(data, util_1.snakeToCamelCase);\n        return {\n          httpMethod,\n          url,\n          queryString: '',\n          data: camelCaseData\n        };\n      } // one field possibly goes to request data, others go to query string\n\n\n      const body = httpRule.body;\n      let data = '';\n      const queryStringObject = deepCopy(request); // use camel case for query string\n\n      if (body) {\n        deleteField(queryStringObject, util_1.snakeToCamelCase(body)); // Unset optional field should not add in body request.\n\n        data = optionalFields.has(body) && snakeRequest[body] === 'undefined' ? '' : snakeRequest[body];\n      }\n\n      for (const field of matchedFields) {\n        deleteField(queryStringObject, util_1.snakeToCamelCase(field));\n      } // Unset proto3 optional field does not appear in the query params.\n\n\n      for (const key in queryStringObject) {\n        if (optionalFields.has(key) && request[key] === 'undefined') {\n          delete queryStringObject[key];\n        }\n      }\n\n      const queryStringComponents = buildQueryStringComponents(queryStringObject);\n      const queryString = queryStringComponents.join('&');\n      let camelCaseData;\n\n      if (typeof data === 'string') {\n        camelCaseData = data;\n      } else {\n        camelCaseData = requestChangeCaseAndCleanup(data, util_1.snakeToCamelCase);\n      }\n\n      return {\n        httpMethod,\n        url,\n        queryString,\n        data: camelCaseData\n      };\n    }\n  }\n\n  return undefined;\n}\n\nexports.transcode = transcode;","map":{"version":3,"sources":["../../src/transcoding.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.transcode = exports.getFieldNameOnBehavior = exports.isRequiredField = exports.isProto3OptionalField = exports.requestChangeCaseAndCleanup = exports.flattenObject = exports.match = exports.applyPattern = exports.encodeWithoutSlashes = exports.encodeWithSlashes = exports.buildQueryStringComponents = exports.deleteField = exports.deepCopy = exports.getField = void 0;\nconst util_1 = require(\"./util\");\nconst httpOptionName = '(google.api.http)';\nconst fieldBehaviorOptionName = '(google.api.field_behavior)';\nconst proto3OptionalName = 'proto3_optional';\n// List of methods as defined in google/api/http.proto (see HttpRule)\nconst supportedHttpMethods = ['get', 'post', 'put', 'patch', 'delete'];\nfunction getField(request, field) {\n    const parts = field.split('.');\n    let value = request;\n    for (const part of parts) {\n        if (typeof value !== 'object') {\n            return undefined;\n        }\n        value = value[part];\n    }\n    if (typeof value === 'object' && !Array.isArray(value) && value !== null) {\n        return undefined;\n    }\n    return value;\n}\nexports.getField = getField;\nfunction deepCopy(request) {\n    if (typeof request !== 'object' || request === null) {\n        return request;\n    }\n    const copy = Object.assign({}, request);\n    for (const key in copy) {\n        if (Array.isArray(copy[key])) {\n            copy[key] = copy[key].map(deepCopy);\n        }\n        else if (typeof copy[key] === 'object' && copy[key] !== null) {\n            copy[key] = deepCopy(copy[key]);\n        }\n    }\n    return copy;\n}\nexports.deepCopy = deepCopy;\nfunction deleteField(request, field) {\n    const parts = field.split('.');\n    while (parts.length > 1) {\n        if (typeof request !== 'object') {\n            return;\n        }\n        const part = parts.shift();\n        request = request[part];\n    }\n    const part = parts.shift();\n    if (typeof request !== 'object') {\n        return;\n    }\n    delete request[part];\n}\nexports.deleteField = deleteField;\nfunction buildQueryStringComponents(request, prefix = '') {\n    const resultList = [];\n    for (const key in request) {\n        if (Array.isArray(request[key])) {\n            for (const value of request[key]) {\n                resultList.push(`${prefix}${encodeWithoutSlashes(key)}=${encodeWithoutSlashes(value.toString())}`);\n            }\n        }\n        else if (typeof request[key] === 'object' && request[key] !== null) {\n            resultList.push(...buildQueryStringComponents(request[key], `${key}.`));\n        }\n        else {\n            resultList.push(`${prefix}${encodeWithoutSlashes(key)}=${encodeWithoutSlashes(request[key] === null ? 'null' : request[key].toString())}`);\n        }\n    }\n    return resultList;\n}\nexports.buildQueryStringComponents = buildQueryStringComponents;\nfunction encodeWithSlashes(str) {\n    return str\n        .split('')\n        .map(c => (c.match(/[-_.~0-9a-zA-Z]/) ? c : encodeURIComponent(c)))\n        .join('');\n}\nexports.encodeWithSlashes = encodeWithSlashes;\nfunction encodeWithoutSlashes(str) {\n    return str\n        .split('')\n        .map(c => (c.match(/[-_.~0-9a-zA-Z/]/) ? c : encodeURIComponent(c)))\n        .join('');\n}\nexports.encodeWithoutSlashes = encodeWithoutSlashes;\nfunction escapeRegExp(str) {\n    return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\nfunction applyPattern(pattern, fieldValue) {\n    if (!pattern || pattern === '*') {\n        return encodeWithSlashes(fieldValue);\n    }\n    if (!pattern.includes('*') && pattern !== fieldValue) {\n        return undefined;\n    }\n    // since we're converting the pattern to a regex, make necessary precautions:\n    const regex = new RegExp('^' +\n        escapeRegExp(pattern)\n            .replace(/\\\\\\*\\\\\\*/g, '(.+)')\n            .replace(/\\\\\\*/g, '([^/]+)') +\n        '$');\n    if (!fieldValue.match(regex)) {\n        return undefined;\n    }\n    return encodeWithoutSlashes(fieldValue);\n}\nexports.applyPattern = applyPattern;\nfunction match(request, pattern) {\n    let url = pattern;\n    const matchedFields = [];\n    for (;;) {\n        const match = url.match(/^(.*)\\{([^}=]+)(?:=([^}]*))?\\}(.*)/);\n        if (!match) {\n            break;\n        }\n        const [, before, field, pattern, after] = match;\n        matchedFields.push(field);\n        const fieldValue = getField(request, field);\n        if (typeof fieldValue === 'undefined') {\n            return undefined;\n        }\n        const appliedPattern = applyPattern(pattern, fieldValue === null ? 'null' : fieldValue.toString());\n        if (typeof appliedPattern === 'undefined') {\n            return undefined;\n        }\n        url = before + appliedPattern + after;\n    }\n    return { matchedFields, url };\n}\nexports.match = match;\nfunction flattenObject(request) {\n    const result = {};\n    for (const key in request) {\n        if (typeof request[key] === 'undefined') {\n            continue;\n        }\n        if (Array.isArray(request[key])) {\n            // According to the http.proto comments, a repeated field may only\n            // contain primitive types, so no extra recursion here.\n            result[key] = request[key];\n            continue;\n        }\n        if (typeof request[key] === 'object' && request[key] !== null) {\n            const nested = flattenObject(request[key]);\n            for (const nestedKey in nested) {\n                result[`${key}.${nestedKey}`] = nested[nestedKey];\n            }\n            continue;\n        }\n        result[key] = request[key];\n    }\n    return result;\n}\nexports.flattenObject = flattenObject;\nfunction requestChangeCaseAndCleanup(request, caseChangeFunc) {\n    if (!request || typeof request !== 'object') {\n        return request;\n    }\n    const convertedRequest = {};\n    for (const field in request) {\n        // cleaning up inherited properties\n        if (!Object.prototype.hasOwnProperty.call(request, field)) {\n            continue;\n        }\n        const convertedField = caseChangeFunc(field);\n        const value = request[field];\n        if (Array.isArray(value)) {\n            convertedRequest[convertedField] = value.map(v => requestChangeCaseAndCleanup(v, caseChangeFunc));\n        }\n        else {\n            convertedRequest[convertedField] = requestChangeCaseAndCleanup(value, caseChangeFunc);\n        }\n    }\n    return convertedRequest;\n}\nexports.requestChangeCaseAndCleanup = requestChangeCaseAndCleanup;\nfunction isProto3OptionalField(field) {\n    return field && field.options && field.options[proto3OptionalName];\n}\nexports.isProto3OptionalField = isProto3OptionalField;\nfunction isRequiredField(field) {\n    return (field &&\n        field.options &&\n        field.options[fieldBehaviorOptionName] === 'REQUIRED');\n}\nexports.isRequiredField = isRequiredField;\nfunction getFieldNameOnBehavior(fields) {\n    const requiredFields = new Set();\n    const optionalFields = new Set();\n    for (const fieldName in fields) {\n        const field = fields[fieldName];\n        if (isRequiredField(field)) {\n            requiredFields.add(fieldName);\n        }\n        if (isProto3OptionalField(field)) {\n            optionalFields.add(fieldName);\n        }\n    }\n    return { requiredFields, optionalFields };\n}\nexports.getFieldNameOnBehavior = getFieldNameOnBehavior;\nfunction transcode(request, parsedOptions, requestFields) {\n    const { requiredFields, optionalFields } = getFieldNameOnBehavior(requestFields);\n    // all fields annotated as REQUIRED MUST be emitted in the body.\n    for (const requiredField of requiredFields) {\n        if (!(requiredField in request) || request[requiredField] === 'undefined') {\n            throw new Error(`Required field ${requiredField} is not present in the request.`);\n        }\n    }\n    // request is supposed to have keys in camelCase.\n    const snakeRequest = requestChangeCaseAndCleanup(request, util_1.camelToSnakeCase);\n    const httpRules = [];\n    for (const option of parsedOptions) {\n        if (!(httpOptionName in option)) {\n            continue;\n        }\n        const httpRule = option[httpOptionName];\n        httpRules.push(httpRule);\n        if (httpRule === null || httpRule === void 0 ? void 0 : httpRule.additional_bindings) {\n            const additionalBindings = Array.isArray(httpRule.additional_bindings)\n                ? httpRule.additional_bindings\n                : [httpRule.additional_bindings];\n            httpRules.push(...additionalBindings);\n        }\n    }\n    for (const httpRule of httpRules) {\n        for (const httpMethod of supportedHttpMethods) {\n            if (!(httpMethod in httpRule)) {\n                continue;\n            }\n            const pathTemplate = httpRule[httpMethod];\n            const matchResult = match(snakeRequest, pathTemplate);\n            if (typeof matchResult === 'undefined') {\n                continue;\n            }\n            const { url, matchedFields } = matchResult;\n            if (httpRule.body === '*') {\n                // all fields except the matched fields go to request data\n                const data = deepCopy(snakeRequest);\n                for (const field of matchedFields) {\n                    deleteField(data, field);\n                }\n                // Remove unset proto3 optional field from the request body.\n                for (const key in data) {\n                    if (optionalFields.has(util_1.snakeToCamelCase(key)) &&\n                        (!(key in snakeRequest) || snakeRequest[key] === 'undefined')) {\n                        delete data[key];\n                    }\n                }\n                // HTTP endpoint expects camelCase but we have snake_case at this point\n                const camelCaseData = requestChangeCaseAndCleanup(data, util_1.snakeToCamelCase);\n                return { httpMethod, url, queryString: '', data: camelCaseData };\n            }\n            // one field possibly goes to request data, others go to query string\n            const body = httpRule.body;\n            let data = '';\n            const queryStringObject = deepCopy(request); // use camel case for query string\n            if (body) {\n                deleteField(queryStringObject, util_1.snakeToCamelCase(body));\n                // Unset optional field should not add in body request.\n                data =\n                    optionalFields.has(body) && snakeRequest[body] === 'undefined'\n                        ? ''\n                        : snakeRequest[body];\n            }\n            for (const field of matchedFields) {\n                deleteField(queryStringObject, util_1.snakeToCamelCase(field));\n            }\n            // Unset proto3 optional field does not appear in the query params.\n            for (const key in queryStringObject) {\n                if (optionalFields.has(key) && request[key] === 'undefined') {\n                    delete queryStringObject[key];\n                }\n            }\n            const queryStringComponents = buildQueryStringComponents(queryStringObject);\n            const queryString = queryStringComponents.join('&');\n            let camelCaseData;\n            if (typeof data === 'string') {\n                camelCaseData = data;\n            }\n            else {\n                camelCaseData = requestChangeCaseAndCleanup(data, util_1.snakeToCamelCase);\n            }\n            return { httpMethod, url, queryString, data: camelCaseData };\n        }\n    }\n    return undefined;\n}\nexports.transcode = transcode;\n//# sourceMappingURL=transcoding.js.map"]},"metadata":{},"sourceType":"script"}