{"ast":null,"code":"const {\n  inflateRawSync\n} = require('zlib');\n\nconst base64url = require('../help/base64url');\n\nconst getKey = require('../help/get_key');\n\nconst {\n  KeyStore\n} = require('../jwks');\n\nconst errors = require('../errors');\n\nconst {\n  check,\n  decrypt,\n  keyManagementDecrypt\n} = require('../jwa');\n\nconst JWK = require('../jwk');\n\nconst {\n  createSecretKey\n} = require('../help/key_object');\n\nconst generateCEK = require('./generate_cek');\n\nconst validateHeaders = require('./validate_headers');\n\nconst {\n  detect: resolveSerialization\n} = require('./serializers');\n\nconst SINGLE_RECIPIENT = new Set(['compact', 'flattened']);\n\nconst combineHeader = (prot = {}, unprotected = {}, header = {}) => {\n  if (typeof prot === 'string') {\n    prot = base64url.JSON.decode(prot);\n  }\n\n  const p2s = prot.p2s || unprotected.p2s || header.p2s;\n  const apu = prot.apu || unprotected.apu || header.apu;\n  const apv = prot.apv || unprotected.apv || header.apv;\n  const iv = prot.iv || unprotected.iv || header.iv;\n  const tag = prot.tag || unprotected.tag || header.tag;\n  return { ...prot,\n    ...unprotected,\n    ...header,\n    ...(typeof p2s === 'string' ? {\n      p2s: base64url.decodeToBuffer(p2s)\n    } : undefined),\n    ...(typeof apu === 'string' ? {\n      apu: base64url.decodeToBuffer(apu)\n    } : undefined),\n    ...(typeof apv === 'string' ? {\n      apv: base64url.decodeToBuffer(apv)\n    } : undefined),\n    ...(typeof iv === 'string' ? {\n      iv: base64url.decodeToBuffer(iv)\n    } : undefined),\n    ...(typeof tag === 'string' ? {\n      tag: base64url.decodeToBuffer(tag)\n    } : undefined)\n  };\n};\n\nconst validateAlgorithms = (algorithms, option) => {\n  if (algorithms !== undefined && (!Array.isArray(algorithms) || algorithms.some(s => typeof s !== 'string' || !s))) {\n    throw new TypeError(`\"${option}\" option must be an array of non-empty strings`);\n  }\n\n  if (!algorithms) {\n    return undefined;\n  }\n\n  return new Set(algorithms);\n};\n/*\n * @public\n */\n\n\nconst jweDecrypt = (skipValidateHeaders, serialization, jwe, key, {\n  crit = [],\n  complete = false,\n  keyManagementAlgorithms,\n  contentEncryptionAlgorithms\n} = {}) => {\n  key = getKey(key, true);\n  keyManagementAlgorithms = validateAlgorithms(keyManagementAlgorithms, 'keyManagementAlgorithms');\n  contentEncryptionAlgorithms = validateAlgorithms(contentEncryptionAlgorithms, 'contentEncryptionAlgorithms');\n\n  if (!Array.isArray(crit) || crit.some(s => typeof s !== 'string' || !s)) {\n    throw new TypeError('\"crit\" option must be an array of non-empty strings');\n  }\n\n  if (!serialization) {\n    serialization = resolveSerialization(jwe);\n  }\n\n  let alg, ciphertext, enc, encryptedKey, iv, opts, prot, tag, unprotected, cek, aad, header; // treat general format with one recipient as flattened\n  // skips iteration and avoids multi errors in this case\n\n  if (serialization === 'general' && jwe.recipients.length === 1) {\n    serialization = 'flattened';\n    const {\n      recipients,\n      ...root\n    } = jwe;\n    jwe = { ...root,\n      ...recipients[0]\n    };\n  }\n\n  if (SINGLE_RECIPIENT.has(serialization)) {\n    if (serialization === 'compact') {\n      // compact serialization format\n      [prot, encryptedKey, iv, ciphertext, tag] = jwe.split('.');\n    } else {\n      // flattened serialization format\n      ({\n        protected: prot,\n        encrypted_key: encryptedKey,\n        iv,\n        ciphertext,\n        tag,\n        unprotected,\n        aad,\n        header\n      } = jwe);\n    }\n\n    if (!skipValidateHeaders) {\n      validateHeaders(prot, unprotected, [{\n        header\n      }], true, crit);\n    }\n\n    opts = combineHeader(prot, unprotected, header);\n    ({\n      alg,\n      enc\n    } = opts);\n\n    if (keyManagementAlgorithms && !keyManagementAlgorithms.has(alg)) {\n      throw new errors.JOSEAlgNotWhitelisted('key management algorithm not whitelisted');\n    }\n\n    if (contentEncryptionAlgorithms && !contentEncryptionAlgorithms.has(enc)) {\n      throw new errors.JOSEAlgNotWhitelisted('content encryption algorithm not whitelisted');\n    }\n\n    if (key instanceof KeyStore) {\n      const keystore = key;\n      let keys;\n\n      if (opts.alg === 'dir') {\n        keys = keystore.all({\n          kid: opts.kid,\n          alg: opts.enc,\n          key_ops: ['decrypt']\n        });\n      } else {\n        keys = keystore.all({\n          kid: opts.kid,\n          alg: opts.alg,\n          key_ops: ['unwrapKey']\n        });\n      }\n\n      switch (keys.length) {\n        case 0:\n          throw new errors.JWKSNoMatchingKey();\n\n        case 1:\n          // treat the call as if a Key instance was passed in\n          // skips iteration and avoids multi errors in this case\n          key = keys[0];\n          break;\n\n        default:\n          {\n            const errs = [];\n\n            for (const key of keys) {\n              try {\n                return jweDecrypt(true, serialization, jwe, key, {\n                  crit,\n                  complete,\n                  contentEncryptionAlgorithms: contentEncryptionAlgorithms ? [...contentEncryptionAlgorithms] : undefined,\n                  keyManagementAlgorithms: keyManagementAlgorithms ? [...keyManagementAlgorithms] : undefined\n                });\n              } catch (err) {\n                errs.push(err);\n                continue;\n              }\n            }\n\n            const multi = new errors.JOSEMultiError(errs);\n\n            if ([...multi].some(e => e instanceof errors.JWEDecryptionFailed)) {\n              throw new errors.JWEDecryptionFailed();\n            }\n\n            throw multi;\n          }\n      }\n    }\n\n    check(key, ...(alg === 'dir' ? ['decrypt', enc] : ['keyManagementDecrypt', alg]));\n\n    try {\n      if (alg === 'dir') {\n        cek = JWK.asKey(key, {\n          alg: enc,\n          use: 'enc'\n        });\n      } else if (alg === 'ECDH-ES') {\n        const unwrapped = keyManagementDecrypt(alg, key, undefined, opts);\n        cek = JWK.asKey(createSecretKey(unwrapped), {\n          alg: enc,\n          use: 'enc'\n        });\n      } else {\n        const unwrapped = keyManagementDecrypt(alg, key, base64url.decodeToBuffer(encryptedKey), opts);\n        cek = JWK.asKey(createSecretKey(unwrapped), {\n          alg: enc,\n          use: 'enc'\n        });\n      }\n    } catch (err) {\n      // To mitigate the attacks described in RFC 3218, the\n      // recipient MUST NOT distinguish between format, padding, and length\n      // errors of encrypted keys.  It is strongly recommended, in the event\n      // of receiving an improperly formatted key, that the recipient\n      // substitute a randomly generated CEK and proceed to the next step, to\n      // mitigate timing attacks.\n      cek = generateCEK(enc);\n    }\n\n    let adata;\n\n    if (aad) {\n      adata = Buffer.concat([Buffer.from(prot || ''), Buffer.from('.'), Buffer.from(aad)]);\n    } else {\n      adata = Buffer.from(prot || '');\n    }\n\n    try {\n      iv = base64url.decodeToBuffer(iv);\n    } catch (err) {}\n\n    try {\n      tag = base64url.decodeToBuffer(tag);\n    } catch (err) {}\n\n    let cleartext = decrypt(enc, cek, base64url.decodeToBuffer(ciphertext), {\n      iv,\n      tag,\n      aad: adata\n    });\n\n    if (opts.zip) {\n      cleartext = inflateRawSync(cleartext);\n    }\n\n    if (complete) {\n      const result = {\n        cleartext,\n        key,\n        cek\n      };\n      if (aad) result.aad = aad;\n      if (header) result.header = header;\n      if (unprotected) result.unprotected = unprotected;\n      if (prot) result.protected = base64url.JSON.decode(prot);\n      return result;\n    }\n\n    return cleartext;\n  }\n\n  validateHeaders(jwe.protected, jwe.unprotected, jwe.recipients.map(({\n    header\n  }) => ({\n    header\n  })), true, crit); // general serialization format\n\n  const {\n    recipients,\n    ...root\n  } = jwe;\n  const errs = [];\n\n  for (const recipient of recipients) {\n    try {\n      return jweDecrypt(true, 'flattened', { ...root,\n        ...recipient\n      }, key, {\n        crit,\n        complete,\n        contentEncryptionAlgorithms: contentEncryptionAlgorithms ? [...contentEncryptionAlgorithms] : undefined,\n        keyManagementAlgorithms: keyManagementAlgorithms ? [...keyManagementAlgorithms] : undefined\n      });\n    } catch (err) {\n      errs.push(err);\n      continue;\n    }\n  }\n\n  const multi = new errors.JOSEMultiError(errs);\n\n  if ([...multi].some(e => e instanceof errors.JWEDecryptionFailed)) {\n    throw new errors.JWEDecryptionFailed();\n  } else if ([...multi].every(e => e instanceof errors.JWKSNoMatchingKey)) {\n    throw new errors.JWKSNoMatchingKey();\n  }\n\n  throw multi;\n};\n\nmodule.exports = jweDecrypt.bind(undefined, false, undefined);","map":{"version":3,"sources":["/home/invidam/hamburger_calender/client/node_modules/jose/lib/jwe/decrypt.js"],"names":["inflateRawSync","require","base64url","getKey","KeyStore","errors","check","decrypt","keyManagementDecrypt","JWK","createSecretKey","generateCEK","validateHeaders","detect","resolveSerialization","SINGLE_RECIPIENT","Set","combineHeader","prot","unprotected","header","JSON","decode","p2s","apu","apv","iv","tag","decodeToBuffer","undefined","validateAlgorithms","algorithms","option","Array","isArray","some","s","TypeError","jweDecrypt","skipValidateHeaders","serialization","jwe","key","crit","complete","keyManagementAlgorithms","contentEncryptionAlgorithms","alg","ciphertext","enc","encryptedKey","opts","cek","aad","recipients","length","root","has","split","protected","encrypted_key","JOSEAlgNotWhitelisted","keystore","keys","all","kid","key_ops","JWKSNoMatchingKey","errs","err","push","multi","JOSEMultiError","e","JWEDecryptionFailed","asKey","use","unwrapped","adata","Buffer","concat","from","cleartext","zip","result","map","recipient","every","module","exports","bind"],"mappings":"AAAA,MAAM;AAAEA,EAAAA;AAAF,IAAqBC,OAAO,CAAC,MAAD,CAAlC;;AAEA,MAAMC,SAAS,GAAGD,OAAO,CAAC,mBAAD,CAAzB;;AACA,MAAME,MAAM,GAAGF,OAAO,CAAC,iBAAD,CAAtB;;AACA,MAAM;AAAEG,EAAAA;AAAF,IAAeH,OAAO,CAAC,SAAD,CAA5B;;AACA,MAAMI,MAAM,GAAGJ,OAAO,CAAC,WAAD,CAAtB;;AACA,MAAM;AAAEK,EAAAA,KAAF;AAASC,EAAAA,OAAT;AAAkBC,EAAAA;AAAlB,IAA2CP,OAAO,CAAC,QAAD,CAAxD;;AACA,MAAMQ,GAAG,GAAGR,OAAO,CAAC,QAAD,CAAnB;;AAEA,MAAM;AAAES,EAAAA;AAAF,IAAsBT,OAAO,CAAC,oBAAD,CAAnC;;AACA,MAAMU,WAAW,GAAGV,OAAO,CAAC,gBAAD,CAA3B;;AACA,MAAMW,eAAe,GAAGX,OAAO,CAAC,oBAAD,CAA/B;;AACA,MAAM;AAAEY,EAAAA,MAAM,EAAEC;AAAV,IAAmCb,OAAO,CAAC,eAAD,CAAhD;;AAEA,MAAMc,gBAAgB,GAAG,IAAIC,GAAJ,CAAQ,CAAC,SAAD,EAAY,WAAZ,CAAR,CAAzB;;AAEA,MAAMC,aAAa,GAAG,CAACC,IAAI,GAAG,EAAR,EAAYC,WAAW,GAAG,EAA1B,EAA8BC,MAAM,GAAG,EAAvC,KAA8C;AAClE,MAAI,OAAOF,IAAP,KAAgB,QAApB,EAA8B;AAC5BA,IAAAA,IAAI,GAAGhB,SAAS,CAACmB,IAAV,CAAeC,MAAf,CAAsBJ,IAAtB,CAAP;AACD;;AAED,QAAMK,GAAG,GAAGL,IAAI,CAACK,GAAL,IAAYJ,WAAW,CAACI,GAAxB,IAA+BH,MAAM,CAACG,GAAlD;AACA,QAAMC,GAAG,GAAGN,IAAI,CAACM,GAAL,IAAYL,WAAW,CAACK,GAAxB,IAA+BJ,MAAM,CAACI,GAAlD;AACA,QAAMC,GAAG,GAAGP,IAAI,CAACO,GAAL,IAAYN,WAAW,CAACM,GAAxB,IAA+BL,MAAM,CAACK,GAAlD;AACA,QAAMC,EAAE,GAAGR,IAAI,CAACQ,EAAL,IAAWP,WAAW,CAACO,EAAvB,IAA6BN,MAAM,CAACM,EAA/C;AACA,QAAMC,GAAG,GAAGT,IAAI,CAACS,GAAL,IAAYR,WAAW,CAACQ,GAAxB,IAA+BP,MAAM,CAACO,GAAlD;AAEA,SAAO,EACL,GAAGT,IADE;AAEL,OAAGC,WAFE;AAGL,OAAGC,MAHE;AAIL,QAAI,OAAOG,GAAP,KAAe,QAAf,GAA0B;AAAEA,MAAAA,GAAG,EAAErB,SAAS,CAAC0B,cAAV,CAAyBL,GAAzB;AAAP,KAA1B,GAAmEM,SAAvE,CAJK;AAKL,QAAI,OAAOL,GAAP,KAAe,QAAf,GAA0B;AAAEA,MAAAA,GAAG,EAAEtB,SAAS,CAAC0B,cAAV,CAAyBJ,GAAzB;AAAP,KAA1B,GAAmEK,SAAvE,CALK;AAML,QAAI,OAAOJ,GAAP,KAAe,QAAf,GAA0B;AAAEA,MAAAA,GAAG,EAAEvB,SAAS,CAAC0B,cAAV,CAAyBH,GAAzB;AAAP,KAA1B,GAAmEI,SAAvE,CANK;AAOL,QAAI,OAAOH,EAAP,KAAc,QAAd,GAAyB;AAAEA,MAAAA,EAAE,EAAExB,SAAS,CAAC0B,cAAV,CAAyBF,EAAzB;AAAN,KAAzB,GAAgEG,SAApE,CAPK;AAQL,QAAI,OAAOF,GAAP,KAAe,QAAf,GAA0B;AAAEA,MAAAA,GAAG,EAAEzB,SAAS,CAAC0B,cAAV,CAAyBD,GAAzB;AAAP,KAA1B,GAAmEE,SAAvE;AARK,GAAP;AAUD,CArBD;;AAuBA,MAAMC,kBAAkB,GAAG,CAACC,UAAD,EAAaC,MAAb,KAAwB;AACjD,MAAID,UAAU,KAAKF,SAAf,KAA6B,CAACI,KAAK,CAACC,OAAN,CAAcH,UAAd,CAAD,IAA8BA,UAAU,CAACI,IAAX,CAAgBC,CAAC,IAAI,OAAOA,CAAP,KAAa,QAAb,IAAyB,CAACA,CAA/C,CAA3D,CAAJ,EAAmH;AACjH,UAAM,IAAIC,SAAJ,CAAe,IAAGL,MAAO,gDAAzB,CAAN;AACD;;AAED,MAAI,CAACD,UAAL,EAAiB;AACf,WAAOF,SAAP;AACD;;AAED,SAAO,IAAIb,GAAJ,CAAQe,UAAR,CAAP;AACD,CAVD;AAYA;AACA;AACA;;;AACA,MAAMO,UAAU,GAAG,CAACC,mBAAD,EAAsBC,aAAtB,EAAqCC,GAArC,EAA0CC,GAA1C,EAA+C;AAAEC,EAAAA,IAAI,GAAG,EAAT;AAAaC,EAAAA,QAAQ,GAAG,KAAxB;AAA+BC,EAAAA,uBAA/B;AAAwDC,EAAAA;AAAxD,IAAwF,EAAvI,KAA8I;AAC/JJ,EAAAA,GAAG,GAAGvC,MAAM,CAACuC,GAAD,EAAM,IAAN,CAAZ;AAEAG,EAAAA,uBAAuB,GAAGf,kBAAkB,CAACe,uBAAD,EAA0B,yBAA1B,CAA5C;AACAC,EAAAA,2BAA2B,GAAGhB,kBAAkB,CAACgB,2BAAD,EAA8B,6BAA9B,CAAhD;;AAEA,MAAI,CAACb,KAAK,CAACC,OAAN,CAAcS,IAAd,CAAD,IAAwBA,IAAI,CAACR,IAAL,CAAUC,CAAC,IAAI,OAAOA,CAAP,KAAa,QAAb,IAAyB,CAACA,CAAzC,CAA5B,EAAyE;AACvE,UAAM,IAAIC,SAAJ,CAAc,qDAAd,CAAN;AACD;;AAED,MAAI,CAACG,aAAL,EAAoB;AAClBA,IAAAA,aAAa,GAAG1B,oBAAoB,CAAC2B,GAAD,CAApC;AACD;;AAED,MAAIM,GAAJ,EAASC,UAAT,EAAqBC,GAArB,EAA0BC,YAA1B,EAAwCxB,EAAxC,EAA4CyB,IAA5C,EAAkDjC,IAAlD,EAAwDS,GAAxD,EAA6DR,WAA7D,EAA0EiC,GAA1E,EAA+EC,GAA/E,EAAoFjC,MAApF,CAd+J,CAgB/J;AACA;;AACA,MAAIoB,aAAa,KAAK,SAAlB,IAA+BC,GAAG,CAACa,UAAJ,CAAeC,MAAf,KAA0B,CAA7D,EAAgE;AAC9Df,IAAAA,aAAa,GAAG,WAAhB;AACA,UAAM;AAAEc,MAAAA,UAAF;AAAc,SAAGE;AAAjB,QAA0Bf,GAAhC;AACAA,IAAAA,GAAG,GAAG,EAAE,GAAGe,IAAL;AAAW,SAAGF,UAAU,CAAC,CAAD;AAAxB,KAAN;AACD;;AAED,MAAIvC,gBAAgB,CAAC0C,GAAjB,CAAqBjB,aAArB,CAAJ,EAAyC;AACvC,QAAIA,aAAa,KAAK,SAAtB,EAAiC;AAAE;AAChC,OAACtB,IAAD,EAAOgC,YAAP,EAAqBxB,EAArB,EAAyBsB,UAAzB,EAAqCrB,GAArC,IAA4Cc,GAAG,CAACiB,KAAJ,CAAU,GAAV,CAA7C;AACD,KAFD,MAEO;AAAE;AACP,OAAC;AAAEC,QAAAA,SAAS,EAAEzC,IAAb;AAAmB0C,QAAAA,aAAa,EAAEV,YAAlC;AAAgDxB,QAAAA,EAAhD;AAAoDsB,QAAAA,UAApD;AAAgErB,QAAAA,GAAhE;AAAqER,QAAAA,WAArE;AAAkFkC,QAAAA,GAAlF;AAAuFjC,QAAAA;AAAvF,UAAkGqB,GAAnG;AACD;;AAED,QAAI,CAACF,mBAAL,EAA0B;AACxB3B,MAAAA,eAAe,CAACM,IAAD,EAAOC,WAAP,EAAoB,CAAC;AAAEC,QAAAA;AAAF,OAAD,CAApB,EAAkC,IAAlC,EAAwCuB,IAAxC,CAAf;AACD;;AAEDQ,IAAAA,IAAI,GAAGlC,aAAa,CAACC,IAAD,EAAOC,WAAP,EAAoBC,MAApB,CAApB;AAEC,KAAC;AAAE2B,MAAAA,GAAF;AAAOE,MAAAA;AAAP,QAAeE,IAAhB;;AAED,QAAIN,uBAAuB,IAAI,CAACA,uBAAuB,CAACY,GAAxB,CAA4BV,GAA5B,CAAhC,EAAkE;AAChE,YAAM,IAAI1C,MAAM,CAACwD,qBAAX,CAAiC,0CAAjC,CAAN;AACD;;AAED,QAAIf,2BAA2B,IAAI,CAACA,2BAA2B,CAACW,GAA5B,CAAgCR,GAAhC,CAApC,EAA0E;AACxE,YAAM,IAAI5C,MAAM,CAACwD,qBAAX,CAAiC,8CAAjC,CAAN;AACD;;AAED,QAAInB,GAAG,YAAYtC,QAAnB,EAA6B;AAC3B,YAAM0D,QAAQ,GAAGpB,GAAjB;AACA,UAAIqB,IAAJ;;AACA,UAAIZ,IAAI,CAACJ,GAAL,KAAa,KAAjB,EAAwB;AACtBgB,QAAAA,IAAI,GAAGD,QAAQ,CAACE,GAAT,CAAa;AAAEC,UAAAA,GAAG,EAAEd,IAAI,CAACc,GAAZ;AAAiBlB,UAAAA,GAAG,EAAEI,IAAI,CAACF,GAA3B;AAAgCiB,UAAAA,OAAO,EAAE,CAAC,SAAD;AAAzC,SAAb,CAAP;AACD,OAFD,MAEO;AACLH,QAAAA,IAAI,GAAGD,QAAQ,CAACE,GAAT,CAAa;AAAEC,UAAAA,GAAG,EAAEd,IAAI,CAACc,GAAZ;AAAiBlB,UAAAA,GAAG,EAAEI,IAAI,CAACJ,GAA3B;AAAgCmB,UAAAA,OAAO,EAAE,CAAC,WAAD;AAAzC,SAAb,CAAP;AACD;;AACD,cAAQH,IAAI,CAACR,MAAb;AACE,aAAK,CAAL;AACE,gBAAM,IAAIlD,MAAM,CAAC8D,iBAAX,EAAN;;AACF,aAAK,CAAL;AACE;AACA;AACAzB,UAAAA,GAAG,GAAGqB,IAAI,CAAC,CAAD,CAAV;AACA;;AACF;AAAS;AACP,kBAAMK,IAAI,GAAG,EAAb;;AACA,iBAAK,MAAM1B,GAAX,IAAkBqB,IAAlB,EAAwB;AACtB,kBAAI;AACF,uBAAOzB,UAAU,CAAC,IAAD,EAAOE,aAAP,EAAsBC,GAAtB,EAA2BC,GAA3B,EAAgC;AAC/CC,kBAAAA,IAD+C;AAE/CC,kBAAAA,QAF+C;AAG/CE,kBAAAA,2BAA2B,EAAEA,2BAA2B,GAAG,CAAC,GAAGA,2BAAJ,CAAH,GAAsCjB,SAH/C;AAI/CgB,kBAAAA,uBAAuB,EAAEA,uBAAuB,GAAG,CAAC,GAAGA,uBAAJ,CAAH,GAAkChB;AAJnC,iBAAhC,CAAjB;AAMD,eAPD,CAOE,OAAOwC,GAAP,EAAY;AACZD,gBAAAA,IAAI,CAACE,IAAL,CAAUD,GAAV;AACA;AACD;AACF;;AAED,kBAAME,KAAK,GAAG,IAAIlE,MAAM,CAACmE,cAAX,CAA0BJ,IAA1B,CAAd;;AACA,gBAAI,CAAC,GAAGG,KAAJ,EAAWpC,IAAX,CAAgBsC,CAAC,IAAIA,CAAC,YAAYpE,MAAM,CAACqE,mBAAzC,CAAJ,EAAmE;AACjE,oBAAM,IAAIrE,MAAM,CAACqE,mBAAX,EAAN;AACD;;AACD,kBAAMH,KAAN;AACD;AA7BH;AA+BD;;AAEDjE,IAAAA,KAAK,CAACoC,GAAD,EAAM,IAAIK,GAAG,KAAK,KAAR,GAAgB,CAAC,SAAD,EAAYE,GAAZ,CAAhB,GAAmC,CAAC,sBAAD,EAAyBF,GAAzB,CAAvC,CAAN,CAAL;;AAEA,QAAI;AACF,UAAIA,GAAG,KAAK,KAAZ,EAAmB;AACjBK,QAAAA,GAAG,GAAG3C,GAAG,CAACkE,KAAJ,CAAUjC,GAAV,EAAe;AAAEK,UAAAA,GAAG,EAAEE,GAAP;AAAY2B,UAAAA,GAAG,EAAE;AAAjB,SAAf,CAAN;AACD,OAFD,MAEO,IAAI7B,GAAG,KAAK,SAAZ,EAAuB;AAC5B,cAAM8B,SAAS,GAAGrE,oBAAoB,CAACuC,GAAD,EAAML,GAAN,EAAWb,SAAX,EAAsBsB,IAAtB,CAAtC;AACAC,QAAAA,GAAG,GAAG3C,GAAG,CAACkE,KAAJ,CAAUjE,eAAe,CAACmE,SAAD,CAAzB,EAAsC;AAAE9B,UAAAA,GAAG,EAAEE,GAAP;AAAY2B,UAAAA,GAAG,EAAE;AAAjB,SAAtC,CAAN;AACD,OAHM,MAGA;AACL,cAAMC,SAAS,GAAGrE,oBAAoB,CAACuC,GAAD,EAAML,GAAN,EAAWxC,SAAS,CAAC0B,cAAV,CAAyBsB,YAAzB,CAAX,EAAmDC,IAAnD,CAAtC;AACAC,QAAAA,GAAG,GAAG3C,GAAG,CAACkE,KAAJ,CAAUjE,eAAe,CAACmE,SAAD,CAAzB,EAAsC;AAAE9B,UAAAA,GAAG,EAAEE,GAAP;AAAY2B,UAAAA,GAAG,EAAE;AAAjB,SAAtC,CAAN;AACD;AACF,KAVD,CAUE,OAAOP,GAAP,EAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACAjB,MAAAA,GAAG,GAAGzC,WAAW,CAACsC,GAAD,CAAjB;AACD;;AAED,QAAI6B,KAAJ;;AACA,QAAIzB,GAAJ,EAAS;AACPyB,MAAAA,KAAK,GAAGC,MAAM,CAACC,MAAP,CAAc,CACpBD,MAAM,CAACE,IAAP,CAAY/D,IAAI,IAAI,EAApB,CADoB,EAEpB6D,MAAM,CAACE,IAAP,CAAY,GAAZ,CAFoB,EAGpBF,MAAM,CAACE,IAAP,CAAY5B,GAAZ,CAHoB,CAAd,CAAR;AAKD,KAND,MAMO;AACLyB,MAAAA,KAAK,GAAGC,MAAM,CAACE,IAAP,CAAY/D,IAAI,IAAI,EAApB,CAAR;AACD;;AAED,QAAI;AACFQ,MAAAA,EAAE,GAAGxB,SAAS,CAAC0B,cAAV,CAAyBF,EAAzB,CAAL;AACD,KAFD,CAEE,OAAO2C,GAAP,EAAY,CAAE;;AAChB,QAAI;AACF1C,MAAAA,GAAG,GAAGzB,SAAS,CAAC0B,cAAV,CAAyBD,GAAzB,CAAN;AACD,KAFD,CAEE,OAAO0C,GAAP,EAAY,CAAE;;AAEhB,QAAIa,SAAS,GAAG3E,OAAO,CAAC0C,GAAD,EAAMG,GAAN,EAAWlD,SAAS,CAAC0B,cAAV,CAAyBoB,UAAzB,CAAX,EAAiD;AAAEtB,MAAAA,EAAF;AAAMC,MAAAA,GAAN;AAAW0B,MAAAA,GAAG,EAAEyB;AAAhB,KAAjD,CAAvB;;AAEA,QAAI3B,IAAI,CAACgC,GAAT,EAAc;AACZD,MAAAA,SAAS,GAAGlF,cAAc,CAACkF,SAAD,CAA1B;AACD;;AAED,QAAItC,QAAJ,EAAc;AACZ,YAAMwC,MAAM,GAAG;AAAEF,QAAAA,SAAF;AAAaxC,QAAAA,GAAb;AAAkBU,QAAAA;AAAlB,OAAf;AACA,UAAIC,GAAJ,EAAS+B,MAAM,CAAC/B,GAAP,GAAaA,GAAb;AACT,UAAIjC,MAAJ,EAAYgE,MAAM,CAAChE,MAAP,GAAgBA,MAAhB;AACZ,UAAID,WAAJ,EAAiBiE,MAAM,CAACjE,WAAP,GAAqBA,WAArB;AACjB,UAAID,IAAJ,EAAUkE,MAAM,CAACzB,SAAP,GAAmBzD,SAAS,CAACmB,IAAV,CAAeC,MAAf,CAAsBJ,IAAtB,CAAnB;AACV,aAAOkE,MAAP;AACD;;AAED,WAAOF,SAAP;AACD;;AAEDtE,EAAAA,eAAe,CAAC6B,GAAG,CAACkB,SAAL,EAAgBlB,GAAG,CAACtB,WAApB,EAAiCsB,GAAG,CAACa,UAAJ,CAAe+B,GAAf,CAAmB,CAAC;AAAEjE,IAAAA;AAAF,GAAD,MAAiB;AAAEA,IAAAA;AAAF,GAAjB,CAAnB,CAAjC,EAAmF,IAAnF,EAAyFuB,IAAzF,CAAf,CAlJ+J,CAoJ/J;;AACA,QAAM;AAAEW,IAAAA,UAAF;AAAc,OAAGE;AAAjB,MAA0Bf,GAAhC;AACA,QAAM2B,IAAI,GAAG,EAAb;;AACA,OAAK,MAAMkB,SAAX,IAAwBhC,UAAxB,EAAoC;AAClC,QAAI;AACF,aAAOhB,UAAU,CAAC,IAAD,EAAO,WAAP,EAAoB,EAAE,GAAGkB,IAAL;AAAW,WAAG8B;AAAd,OAApB,EAA+C5C,GAA/C,EAAoD;AACnEC,QAAAA,IADmE;AAEnEC,QAAAA,QAFmE;AAGnEE,QAAAA,2BAA2B,EAAEA,2BAA2B,GAAG,CAAC,GAAGA,2BAAJ,CAAH,GAAsCjB,SAH3B;AAInEgB,QAAAA,uBAAuB,EAAEA,uBAAuB,GAAG,CAAC,GAAGA,uBAAJ,CAAH,GAAkChB;AAJf,OAApD,CAAjB;AAMD,KAPD,CAOE,OAAOwC,GAAP,EAAY;AACZD,MAAAA,IAAI,CAACE,IAAL,CAAUD,GAAV;AACA;AACD;AACF;;AAED,QAAME,KAAK,GAAG,IAAIlE,MAAM,CAACmE,cAAX,CAA0BJ,IAA1B,CAAd;;AACA,MAAI,CAAC,GAAGG,KAAJ,EAAWpC,IAAX,CAAgBsC,CAAC,IAAIA,CAAC,YAAYpE,MAAM,CAACqE,mBAAzC,CAAJ,EAAmE;AACjE,UAAM,IAAIrE,MAAM,CAACqE,mBAAX,EAAN;AACD,GAFD,MAEO,IAAI,CAAC,GAAGH,KAAJ,EAAWgB,KAAX,CAAiBd,CAAC,IAAIA,CAAC,YAAYpE,MAAM,CAAC8D,iBAA1C,CAAJ,EAAkE;AACvE,UAAM,IAAI9D,MAAM,CAAC8D,iBAAX,EAAN;AACD;;AACD,QAAMI,KAAN;AACD,CA5KD;;AA8KAiB,MAAM,CAACC,OAAP,GAAiBnD,UAAU,CAACoD,IAAX,CAAgB7D,SAAhB,EAA2B,KAA3B,EAAkCA,SAAlC,CAAjB","sourcesContent":["const { inflateRawSync } = require('zlib')\n\nconst base64url = require('../help/base64url')\nconst getKey = require('../help/get_key')\nconst { KeyStore } = require('../jwks')\nconst errors = require('../errors')\nconst { check, decrypt, keyManagementDecrypt } = require('../jwa')\nconst JWK = require('../jwk')\n\nconst { createSecretKey } = require('../help/key_object')\nconst generateCEK = require('./generate_cek')\nconst validateHeaders = require('./validate_headers')\nconst { detect: resolveSerialization } = require('./serializers')\n\nconst SINGLE_RECIPIENT = new Set(['compact', 'flattened'])\n\nconst combineHeader = (prot = {}, unprotected = {}, header = {}) => {\n  if (typeof prot === 'string') {\n    prot = base64url.JSON.decode(prot)\n  }\n\n  const p2s = prot.p2s || unprotected.p2s || header.p2s\n  const apu = prot.apu || unprotected.apu || header.apu\n  const apv = prot.apv || unprotected.apv || header.apv\n  const iv = prot.iv || unprotected.iv || header.iv\n  const tag = prot.tag || unprotected.tag || header.tag\n\n  return {\n    ...prot,\n    ...unprotected,\n    ...header,\n    ...(typeof p2s === 'string' ? { p2s: base64url.decodeToBuffer(p2s) } : undefined),\n    ...(typeof apu === 'string' ? { apu: base64url.decodeToBuffer(apu) } : undefined),\n    ...(typeof apv === 'string' ? { apv: base64url.decodeToBuffer(apv) } : undefined),\n    ...(typeof iv === 'string' ? { iv: base64url.decodeToBuffer(iv) } : undefined),\n    ...(typeof tag === 'string' ? { tag: base64url.decodeToBuffer(tag) } : undefined)\n  }\n}\n\nconst validateAlgorithms = (algorithms, option) => {\n  if (algorithms !== undefined && (!Array.isArray(algorithms) || algorithms.some(s => typeof s !== 'string' || !s))) {\n    throw new TypeError(`\"${option}\" option must be an array of non-empty strings`)\n  }\n\n  if (!algorithms) {\n    return undefined\n  }\n\n  return new Set(algorithms)\n}\n\n/*\n * @public\n */\nconst jweDecrypt = (skipValidateHeaders, serialization, jwe, key, { crit = [], complete = false, keyManagementAlgorithms, contentEncryptionAlgorithms } = {}) => {\n  key = getKey(key, true)\n\n  keyManagementAlgorithms = validateAlgorithms(keyManagementAlgorithms, 'keyManagementAlgorithms')\n  contentEncryptionAlgorithms = validateAlgorithms(contentEncryptionAlgorithms, 'contentEncryptionAlgorithms')\n\n  if (!Array.isArray(crit) || crit.some(s => typeof s !== 'string' || !s)) {\n    throw new TypeError('\"crit\" option must be an array of non-empty strings')\n  }\n\n  if (!serialization) {\n    serialization = resolveSerialization(jwe)\n  }\n\n  let alg, ciphertext, enc, encryptedKey, iv, opts, prot, tag, unprotected, cek, aad, header\n\n  // treat general format with one recipient as flattened\n  // skips iteration and avoids multi errors in this case\n  if (serialization === 'general' && jwe.recipients.length === 1) {\n    serialization = 'flattened'\n    const { recipients, ...root } = jwe\n    jwe = { ...root, ...recipients[0] }\n  }\n\n  if (SINGLE_RECIPIENT.has(serialization)) {\n    if (serialization === 'compact') { // compact serialization format\n      ([prot, encryptedKey, iv, ciphertext, tag] = jwe.split('.'))\n    } else { // flattened serialization format\n      ({ protected: prot, encrypted_key: encryptedKey, iv, ciphertext, tag, unprotected, aad, header } = jwe)\n    }\n\n    if (!skipValidateHeaders) {\n      validateHeaders(prot, unprotected, [{ header }], true, crit)\n    }\n\n    opts = combineHeader(prot, unprotected, header)\n\n    ;({ alg, enc } = opts)\n\n    if (keyManagementAlgorithms && !keyManagementAlgorithms.has(alg)) {\n      throw new errors.JOSEAlgNotWhitelisted('key management algorithm not whitelisted')\n    }\n\n    if (contentEncryptionAlgorithms && !contentEncryptionAlgorithms.has(enc)) {\n      throw new errors.JOSEAlgNotWhitelisted('content encryption algorithm not whitelisted')\n    }\n\n    if (key instanceof KeyStore) {\n      const keystore = key\n      let keys\n      if (opts.alg === 'dir') {\n        keys = keystore.all({ kid: opts.kid, alg: opts.enc, key_ops: ['decrypt'] })\n      } else {\n        keys = keystore.all({ kid: opts.kid, alg: opts.alg, key_ops: ['unwrapKey'] })\n      }\n      switch (keys.length) {\n        case 0:\n          throw new errors.JWKSNoMatchingKey()\n        case 1:\n          // treat the call as if a Key instance was passed in\n          // skips iteration and avoids multi errors in this case\n          key = keys[0]\n          break\n        default: {\n          const errs = []\n          for (const key of keys) {\n            try {\n              return jweDecrypt(true, serialization, jwe, key, {\n                crit,\n                complete,\n                contentEncryptionAlgorithms: contentEncryptionAlgorithms ? [...contentEncryptionAlgorithms] : undefined,\n                keyManagementAlgorithms: keyManagementAlgorithms ? [...keyManagementAlgorithms] : undefined\n              })\n            } catch (err) {\n              errs.push(err)\n              continue\n            }\n          }\n\n          const multi = new errors.JOSEMultiError(errs)\n          if ([...multi].some(e => e instanceof errors.JWEDecryptionFailed)) {\n            throw new errors.JWEDecryptionFailed()\n          }\n          throw multi\n        }\n      }\n    }\n\n    check(key, ...(alg === 'dir' ? ['decrypt', enc] : ['keyManagementDecrypt', alg]))\n\n    try {\n      if (alg === 'dir') {\n        cek = JWK.asKey(key, { alg: enc, use: 'enc' })\n      } else if (alg === 'ECDH-ES') {\n        const unwrapped = keyManagementDecrypt(alg, key, undefined, opts)\n        cek = JWK.asKey(createSecretKey(unwrapped), { alg: enc, use: 'enc' })\n      } else {\n        const unwrapped = keyManagementDecrypt(alg, key, base64url.decodeToBuffer(encryptedKey), opts)\n        cek = JWK.asKey(createSecretKey(unwrapped), { alg: enc, use: 'enc' })\n      }\n    } catch (err) {\n      // To mitigate the attacks described in RFC 3218, the\n      // recipient MUST NOT distinguish between format, padding, and length\n      // errors of encrypted keys.  It is strongly recommended, in the event\n      // of receiving an improperly formatted key, that the recipient\n      // substitute a randomly generated CEK and proceed to the next step, to\n      // mitigate timing attacks.\n      cek = generateCEK(enc)\n    }\n\n    let adata\n    if (aad) {\n      adata = Buffer.concat([\n        Buffer.from(prot || ''),\n        Buffer.from('.'),\n        Buffer.from(aad)\n      ])\n    } else {\n      adata = Buffer.from(prot || '')\n    }\n\n    try {\n      iv = base64url.decodeToBuffer(iv)\n    } catch (err) {}\n    try {\n      tag = base64url.decodeToBuffer(tag)\n    } catch (err) {}\n\n    let cleartext = decrypt(enc, cek, base64url.decodeToBuffer(ciphertext), { iv, tag, aad: adata })\n\n    if (opts.zip) {\n      cleartext = inflateRawSync(cleartext)\n    }\n\n    if (complete) {\n      const result = { cleartext, key, cek }\n      if (aad) result.aad = aad\n      if (header) result.header = header\n      if (unprotected) result.unprotected = unprotected\n      if (prot) result.protected = base64url.JSON.decode(prot)\n      return result\n    }\n\n    return cleartext\n  }\n\n  validateHeaders(jwe.protected, jwe.unprotected, jwe.recipients.map(({ header }) => ({ header })), true, crit)\n\n  // general serialization format\n  const { recipients, ...root } = jwe\n  const errs = []\n  for (const recipient of recipients) {\n    try {\n      return jweDecrypt(true, 'flattened', { ...root, ...recipient }, key, {\n        crit,\n        complete,\n        contentEncryptionAlgorithms: contentEncryptionAlgorithms ? [...contentEncryptionAlgorithms] : undefined,\n        keyManagementAlgorithms: keyManagementAlgorithms ? [...keyManagementAlgorithms] : undefined\n      })\n    } catch (err) {\n      errs.push(err)\n      continue\n    }\n  }\n\n  const multi = new errors.JOSEMultiError(errs)\n  if ([...multi].some(e => e instanceof errors.JWEDecryptionFailed)) {\n    throw new errors.JWEDecryptionFailed()\n  } else if ([...multi].every(e => e instanceof errors.JWKSNoMatchingKey)) {\n    throw new errors.JWKSNoMatchingKey()\n  }\n  throw multi\n}\n\nmodule.exports = jweDecrypt.bind(undefined, false, undefined)\n"]},"metadata":{},"sourceType":"script"}