{"ast":null,"code":"const {\n  createPublicKey,\n  createPrivateKey,\n  createSecretKey,\n  KeyObject\n} = require('../help/key_object');\n\nconst base64url = require('../help/base64url');\n\nconst isObject = require('../help/is_object');\n\nconst {\n  jwkToPem\n} = require('../help/key_utils');\n\nconst errors = require('../errors');\n\nconst RSAKey = require('./key/rsa');\n\nconst ECKey = require('./key/ec');\n\nconst OKPKey = require('./key/okp');\n\nconst OctKey = require('./key/oct');\n\nconst importable = new Set(['string', 'buffer', 'object']);\n\nconst mergedParameters = (target = {}, source = {}) => {\n  return {\n    alg: source.alg,\n    key_ops: source.key_ops,\n    kid: source.kid,\n    use: source.use,\n    x5c: source.x5c,\n    x5t: source.x5t,\n    'x5t#S256': source['x5t#S256'],\n    ...target\n  };\n};\n\nconst openSSHpublicKey = /^[a-zA-Z0-9-]+ AAAA(?:[0-9A-Za-z+/])+(?:==|=)?(?: .*)?$/;\n\nconst asKey = (key, parameters, {\n  calculateMissingRSAPrimes = false\n} = {}) => {\n  let privateKey, publicKey, secret;\n\n  if (!importable.has(typeof key)) {\n    throw new TypeError('key argument must be a string, buffer or an object');\n  }\n\n  if (parameters !== undefined && !isObject(parameters)) {\n    throw new TypeError('parameters argument must be a plain object when provided');\n  }\n\n  if (key instanceof KeyObject) {\n    switch (key.type) {\n      case 'private':\n        privateKey = key;\n        break;\n\n      case 'public':\n        publicKey = key;\n        break;\n\n      case 'secret':\n        secret = key;\n        break;\n    }\n  } else if (typeof key === 'object' && key && 'kty' in key && key.kty === 'oct') {\n    // symmetric key <Object>\n    try {\n      secret = createSecretKey(base64url.decodeToBuffer(key.k));\n    } catch (err) {\n      if (!('k' in key)) {\n        secret = {\n          type: 'secret'\n        };\n      }\n    }\n\n    parameters = mergedParameters(parameters, key);\n  } else if (typeof key === 'object' && key && 'kty' in key) {\n    // assume JWK formatted asymmetric key <Object>\n    ({\n      calculateMissingRSAPrimes = false\n    } = parameters || {\n      calculateMissingRSAPrimes\n    });\n    let pem;\n\n    try {\n      pem = jwkToPem(key, {\n        calculateMissingRSAPrimes\n      });\n    } catch (err) {\n      if (err instanceof errors.JOSEError) {\n        throw err;\n      }\n    }\n\n    if (pem && key.d) {\n      privateKey = createPrivateKey(pem);\n    } else if (pem) {\n      publicKey = createPublicKey(pem);\n    }\n\n    parameters = mergedParameters({}, key);\n  } else if (key && (typeof key === 'object' || typeof key === 'string')) {\n    // <Object> | <string> | <Buffer> passed to crypto.createPrivateKey or crypto.createPublicKey or <Buffer> passed to crypto.createSecretKey\n    try {\n      privateKey = createPrivateKey(key);\n    } catch (err) {\n      if (err instanceof errors.JOSEError) {\n        throw err;\n      }\n    }\n\n    try {\n      publicKey = createPublicKey(key);\n\n      if (key.startsWith('-----BEGIN CERTIFICATE-----') && (!parameters || !('x5c' in parameters))) {\n        parameters = mergedParameters(parameters, {\n          x5c: [key.replace(/(?:-----(?:BEGIN|END) CERTIFICATE-----|\\s)/g, '')]\n        });\n      }\n    } catch (err) {\n      if (err instanceof errors.JOSEError) {\n        throw err;\n      }\n    }\n\n    try {\n      // this is to filter out invalid PEM keys and certs, i'll rather have them fail import then\n      // have them imported as symmetric \"oct\" keys\n      if (!key.includes('-----BEGIN') && !openSSHpublicKey.test(key.toString('ascii').replace(/[\\r\\n]/g, ''))) {\n        secret = createSecretKey(Buffer.isBuffer(key) ? key : Buffer.from(key));\n      }\n    } catch (err) {}\n  }\n\n  const keyObject = privateKey || publicKey || secret;\n\n  if (privateKey || publicKey) {\n    switch (keyObject.asymmetricKeyType) {\n      case 'rsa':\n        return new RSAKey(keyObject, parameters);\n\n      case 'ec':\n        return new ECKey(keyObject, parameters);\n\n      case 'ed25519':\n      case 'ed448':\n      case 'x25519':\n      case 'x448':\n        return new OKPKey(keyObject, parameters);\n\n      default:\n        throw new errors.JOSENotSupported('only RSA, EC and OKP asymmetric keys are supported');\n    }\n  } else if (secret) {\n    return new OctKey(keyObject, parameters);\n  }\n\n  throw new errors.JWKImportFailed('key import failed');\n};\n\nmodule.exports = asKey;","map":{"version":3,"sources":["/home/invidam/hamburger_calender/client/node_modules/jose/lib/jwk/import.js"],"names":["createPublicKey","createPrivateKey","createSecretKey","KeyObject","require","base64url","isObject","jwkToPem","errors","RSAKey","ECKey","OKPKey","OctKey","importable","Set","mergedParameters","target","source","alg","key_ops","kid","use","x5c","x5t","openSSHpublicKey","asKey","key","parameters","calculateMissingRSAPrimes","privateKey","publicKey","secret","has","TypeError","undefined","type","kty","decodeToBuffer","k","err","pem","JOSEError","d","startsWith","replace","includes","test","toString","Buffer","isBuffer","from","keyObject","asymmetricKeyType","JOSENotSupported","JWKImportFailed","module","exports"],"mappings":"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","sourcesContent":["const { createPublicKey, createPrivateKey, createSecretKey, KeyObject } = require('../help/key_object')\nconst base64url = require('../help/base64url')\nconst isObject = require('../help/is_object')\nconst { jwkToPem } = require('../help/key_utils')\nconst errors = require('../errors')\n\nconst RSAKey = require('./key/rsa')\nconst ECKey = require('./key/ec')\nconst OKPKey = require('./key/okp')\nconst OctKey = require('./key/oct')\n\nconst importable = new Set(['string', 'buffer', 'object'])\n\nconst mergedParameters = (target = {}, source = {}) => {\n  return {\n    alg: source.alg,\n    key_ops: source.key_ops,\n    kid: source.kid,\n    use: source.use,\n    x5c: source.x5c,\n    x5t: source.x5t,\n    'x5t#S256': source['x5t#S256'],\n    ...target\n  }\n}\n\nconst openSSHpublicKey = /^[a-zA-Z0-9-]+ AAAA(?:[0-9A-Za-z+/])+(?:==|=)?(?: .*)?$/\n\nconst asKey = (key, parameters, { calculateMissingRSAPrimes = false } = {}) => {\n  let privateKey, publicKey, secret\n\n  if (!importable.has(typeof key)) {\n    throw new TypeError('key argument must be a string, buffer or an object')\n  }\n\n  if (parameters !== undefined && !isObject(parameters)) {\n    throw new TypeError('parameters argument must be a plain object when provided')\n  }\n\n  if (key instanceof KeyObject) {\n    switch (key.type) {\n      case 'private':\n        privateKey = key\n        break\n      case 'public':\n        publicKey = key\n        break\n      case 'secret':\n        secret = key\n        break\n    }\n  } else if (typeof key === 'object' && key && 'kty' in key && key.kty === 'oct') { // symmetric key <Object>\n    try {\n      secret = createSecretKey(base64url.decodeToBuffer(key.k))\n    } catch (err) {\n      if (!('k' in key)) {\n        secret = { type: 'secret' }\n      }\n    }\n    parameters = mergedParameters(parameters, key)\n  } else if (typeof key === 'object' && key && 'kty' in key) { // assume JWK formatted asymmetric key <Object>\n    ({ calculateMissingRSAPrimes = false } = parameters || { calculateMissingRSAPrimes })\n    let pem\n\n    try {\n      pem = jwkToPem(key, { calculateMissingRSAPrimes })\n    } catch (err) {\n      if (err instanceof errors.JOSEError) {\n        throw err\n      }\n    }\n\n    if (pem && key.d) {\n      privateKey = createPrivateKey(pem)\n    } else if (pem) {\n      publicKey = createPublicKey(pem)\n    }\n\n    parameters = mergedParameters({}, key)\n  } else if (key && (typeof key === 'object' || typeof key === 'string')) { // <Object> | <string> | <Buffer> passed to crypto.createPrivateKey or crypto.createPublicKey or <Buffer> passed to crypto.createSecretKey\n    try {\n      privateKey = createPrivateKey(key)\n    } catch (err) {\n      if (err instanceof errors.JOSEError) {\n        throw err\n      }\n    }\n\n    try {\n      publicKey = createPublicKey(key)\n      if (key.startsWith('-----BEGIN CERTIFICATE-----') && (!parameters || !('x5c' in parameters))) {\n        parameters = mergedParameters(parameters, {\n          x5c: [key.replace(/(?:-----(?:BEGIN|END) CERTIFICATE-----|\\s)/g, '')]\n        })\n      }\n    } catch (err) {\n      if (err instanceof errors.JOSEError) {\n        throw err\n      }\n    }\n\n    try {\n      // this is to filter out invalid PEM keys and certs, i'll rather have them fail import then\n      // have them imported as symmetric \"oct\" keys\n      if (!key.includes('-----BEGIN') && !openSSHpublicKey.test(key.toString('ascii').replace(/[\\r\\n]/g, ''))) {\n        secret = createSecretKey(Buffer.isBuffer(key) ? key : Buffer.from(key))\n      }\n    } catch (err) {}\n  }\n\n  const keyObject = privateKey || publicKey || secret\n\n  if (privateKey || publicKey) {\n    switch (keyObject.asymmetricKeyType) {\n      case 'rsa':\n        return new RSAKey(keyObject, parameters)\n      case 'ec':\n        return new ECKey(keyObject, parameters)\n      case 'ed25519':\n      case 'ed448':\n      case 'x25519':\n      case 'x448':\n        return new OKPKey(keyObject, parameters)\n      default:\n        throw new errors.JOSENotSupported('only RSA, EC and OKP asymmetric keys are supported')\n    }\n  } else if (secret) {\n    return new OctKey(keyObject, parameters)\n  }\n\n  throw new errors.JWKImportFailed('key import failed')\n}\n\nmodule.exports = asKey\n"]},"metadata":{},"sourceType":"script"}