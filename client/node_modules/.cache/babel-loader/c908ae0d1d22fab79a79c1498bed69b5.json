{"ast":null,"code":"const {\n  publicEncrypt,\n  privateDecrypt,\n  constants\n} = require('crypto');\n\nconst {\n  oaepHashSupported\n} = require('../help/runtime_support');\n\nconst {\n  KEYOBJECT\n} = require('../help/consts');\n\nconst {\n  asInput\n} = require('../help/key_object');\n\nconst resolvePadding = alg => {\n  switch (alg) {\n    case 'RSA-OAEP':\n    case 'RSA-OAEP-256':\n    case 'RSA-OAEP-384':\n    case 'RSA-OAEP-512':\n      return constants.RSA_PKCS1_OAEP_PADDING;\n\n    case 'RSA1_5':\n      return constants.RSA_PKCS1_PADDING;\n  }\n};\n\nconst resolveOaepHash = alg => {\n  switch (alg) {\n    case 'RSA-OAEP':\n      return 'sha1';\n\n    case 'RSA-OAEP-256':\n      return 'sha256';\n\n    case 'RSA-OAEP-384':\n      return 'sha384';\n\n    case 'RSA-OAEP-512':\n      return 'sha512';\n\n    default:\n      return undefined;\n  }\n};\n\nconst wrapKey = (padding, oaepHash, {\n  [KEYOBJECT]: keyObject\n}, payload) => {\n  const key = asInput(keyObject, true);\n  return {\n    wrapped: publicEncrypt({\n      key,\n      oaepHash,\n      padding\n    }, payload)\n  };\n};\n\nconst unwrapKey = (padding, oaepHash, {\n  [KEYOBJECT]: keyObject\n}, payload) => {\n  const key = asInput(keyObject, false);\n  return privateDecrypt({\n    key,\n    oaepHash,\n    padding\n  }, payload);\n};\n\nconst LENGTHS = {\n  RSA1_5: 0,\n  'RSA-OAEP': 592,\n  'RSA-OAEP-256': 784,\n  'RSA-OAEP-384': 1040,\n  'RSA-OAEP-512': 1296\n};\n\nmodule.exports = (JWA, JWK) => {\n  const algs = ['RSA-OAEP', 'RSA1_5'];\n\n  if (oaepHashSupported) {\n    algs.splice(1, 0, 'RSA-OAEP-256', 'RSA-OAEP-384', 'RSA-OAEP-512');\n  }\n\n  algs.forEach(jwaAlg => {\n    const padding = resolvePadding(jwaAlg);\n    const oaepHash = resolveOaepHash(jwaAlg);\n    JWA.keyManagementEncrypt.set(jwaAlg, wrapKey.bind(undefined, padding, oaepHash));\n    JWA.keyManagementDecrypt.set(jwaAlg, unwrapKey.bind(undefined, padding, oaepHash));\n\n    JWK.RSA.wrapKey[jwaAlg] = key => (key.use === 'enc' || key.use === undefined) && key.length >= LENGTHS[jwaAlg];\n\n    JWK.RSA.unwrapKey[jwaAlg] = key => key.private && (key.use === 'enc' || key.use === undefined) && key.length >= LENGTHS[jwaAlg];\n  });\n};","map":{"version":3,"sources":["/home/invidam/hamburger_calender/client/node_modules/jose/lib/jwa/rsaes.js"],"names":["publicEncrypt","privateDecrypt","constants","require","oaepHashSupported","KEYOBJECT","asInput","resolvePadding","alg","RSA_PKCS1_OAEP_PADDING","RSA_PKCS1_PADDING","resolveOaepHash","undefined","wrapKey","padding","oaepHash","keyObject","payload","key","wrapped","unwrapKey","LENGTHS","RSA1_5","module","exports","JWA","JWK","algs","splice","forEach","jwaAlg","keyManagementEncrypt","set","bind","keyManagementDecrypt","RSA","use","length","private"],"mappings":"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","sourcesContent":["const { publicEncrypt, privateDecrypt, constants } = require('crypto')\n\nconst { oaepHashSupported } = require('../help/runtime_support')\nconst { KEYOBJECT } = require('../help/consts')\nconst { asInput } = require('../help/key_object')\n\nconst resolvePadding = (alg) => {\n  switch (alg) {\n    case 'RSA-OAEP':\n    case 'RSA-OAEP-256':\n    case 'RSA-OAEP-384':\n    case 'RSA-OAEP-512':\n      return constants.RSA_PKCS1_OAEP_PADDING\n    case 'RSA1_5':\n      return constants.RSA_PKCS1_PADDING\n  }\n}\n\nconst resolveOaepHash = (alg) => {\n  switch (alg) {\n    case 'RSA-OAEP':\n      return 'sha1'\n    case 'RSA-OAEP-256':\n      return 'sha256'\n    case 'RSA-OAEP-384':\n      return 'sha384'\n    case 'RSA-OAEP-512':\n      return 'sha512'\n    default:\n      return undefined\n  }\n}\n\nconst wrapKey = (padding, oaepHash, { [KEYOBJECT]: keyObject }, payload) => {\n  const key = asInput(keyObject, true)\n  return { wrapped: publicEncrypt({ key, oaepHash, padding }, payload) }\n}\n\nconst unwrapKey = (padding, oaepHash, { [KEYOBJECT]: keyObject }, payload) => {\n  const key = asInput(keyObject, false)\n  return privateDecrypt({ key, oaepHash, padding }, payload)\n}\n\nconst LENGTHS = {\n  RSA1_5: 0,\n  'RSA-OAEP': 592,\n  'RSA-OAEP-256': 784,\n  'RSA-OAEP-384': 1040,\n  'RSA-OAEP-512': 1296\n}\n\nmodule.exports = (JWA, JWK) => {\n  const algs = ['RSA-OAEP', 'RSA1_5']\n\n  if (oaepHashSupported) {\n    algs.splice(1, 0, 'RSA-OAEP-256', 'RSA-OAEP-384', 'RSA-OAEP-512')\n  }\n\n  algs.forEach((jwaAlg) => {\n    const padding = resolvePadding(jwaAlg)\n    const oaepHash = resolveOaepHash(jwaAlg)\n    JWA.keyManagementEncrypt.set(jwaAlg, wrapKey.bind(undefined, padding, oaepHash))\n    JWA.keyManagementDecrypt.set(jwaAlg, unwrapKey.bind(undefined, padding, oaepHash))\n    JWK.RSA.wrapKey[jwaAlg] = key => (key.use === 'enc' || key.use === undefined) && key.length >= LENGTHS[jwaAlg]\n    JWK.RSA.unwrapKey[jwaAlg] = key => key.private && (key.use === 'enc' || key.use === undefined) && key.length >= LENGTHS[jwaAlg]\n  })\n}\n"]},"metadata":{},"sourceType":"script"}