{"ast":null,"code":"\"use strict\"; // Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toProto3JSON = void 0;\n\nconst assert = require(\"assert\");\n\nconst any_1 = require(\"./any\");\n\nconst bytes_1 = require(\"./bytes\");\n\nconst util_1 = require(\"./util\");\n\nconst enum_1 = require(\"./enum\");\n\nconst value_1 = require(\"./value\");\n\nconst duration_1 = require(\"./duration\");\n\nconst timestamp_1 = require(\"./timestamp\");\n\nconst wrappers_1 = require(\"./wrappers\");\n\nconst fieldmask_1 = require(\"./fieldmask\");\n\nconst id = x => {\n  return x;\n};\n\nfunction toProto3JSON(obj) {\n  const objType = obj.$type;\n\n  if (!objType) {\n    throw new Error('Cannot serialize object to proto3 JSON since its .$type is unknown. Use Type.fromObject(obj) before calling toProto3JSON.');\n  }\n\n  objType.resolveAll();\n  const typeName = util_1.getFullyQualifiedTypeName(objType); // Types that require special handling according to\n  // https://developers.google.com/protocol-buffers/docs/proto3#json\n\n  if (typeName === '.google.protobuf.Any') {\n    return any_1.googleProtobufAnyToProto3JSON(obj);\n  }\n\n  if (typeName === '.google.protobuf.Value') {\n    return value_1.googleProtobufValueToProto3JSON(obj);\n  }\n\n  if (typeName === '.google.protobuf.Struct') {\n    return value_1.googleProtobufStructToProto3JSON(obj);\n  }\n\n  if (typeName === '.google.protobuf.ListValue') {\n    return value_1.googleProtobufListValueToProto3JSON(obj);\n  }\n\n  if (typeName === '.google.protobuf.Duration') {\n    return duration_1.googleProtobufDurationToProto3JSON(obj);\n  }\n\n  if (typeName === '.google.protobuf.Timestamp') {\n    return timestamp_1.googleProtobufTimestampToProto3JSON(obj);\n  }\n\n  if (typeName === '.google.protobuf.FieldMask') {\n    return fieldmask_1.googleProtobufFieldMaskToProto3JSON(obj);\n  }\n\n  if (util_1.wrapperTypes.has(typeName)) {\n    return wrappers_1.wrapperToProto3JSON(obj);\n  }\n\n  const result = {};\n\n  for (const [key, value] of Object.entries(obj)) {\n    const field = objType.fields[key];\n    const fieldResolvedType = field.resolvedType;\n    const fieldFullyQualifiedTypeName = fieldResolvedType ? util_1.getFullyQualifiedTypeName(fieldResolvedType) : null;\n\n    if (value === null) {\n      result[key] = null;\n      continue;\n    }\n\n    if (Array.isArray(value)) {\n      // if the repeated value has a complex type, convert it to proto3 JSON, otherwise use as is\n      result[key] = value.map(fieldResolvedType ? element => {\n        return toProto3JSON(element);\n      } : id);\n      continue;\n    }\n\n    if (field.map) {\n      const map = {};\n\n      for (const [mapKey, mapValue] of Object.entries(value)) {\n        // if the map value has a complex type, convert it to proto3 JSON, otherwise use as is\n        map[mapKey] = fieldResolvedType ? toProto3JSON(mapValue) : mapValue;\n      }\n\n      result[key] = map;\n      continue;\n    }\n\n    if (fieldFullyQualifiedTypeName === '.google.protobuf.NullValue') {\n      result[key] = null;\n      continue;\n    }\n\n    if (fieldResolvedType && 'values' in fieldResolvedType && value !== null) {\n      result[key] = enum_1.resolveEnumValueToString(fieldResolvedType, value);\n      continue;\n    }\n\n    if (fieldResolvedType) {\n      result[key] = toProto3JSON(value);\n      continue;\n    }\n\n    if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean' || value === null) {\n      result[key] = value;\n      continue;\n    }\n\n    if (Buffer.isBuffer(value) || value instanceof Uint8Array) {\n      result[key] = bytes_1.bytesToProto3JSON(value);\n      continue;\n    } // The remaining case is Long, everything else is an internal error\n\n\n    assert(value.constructor.name === 'Long', `toProto3JSON: don't know how to convert field ${key} with value ${value}`);\n    result[key] = value.toString();\n    continue;\n  }\n\n  return result;\n}\n\nexports.toProto3JSON = toProto3JSON;","map":{"version":3,"sources":["../../typescript/src/toproto3json.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toProto3JSON = void 0;\nconst assert = require(\"assert\");\nconst any_1 = require(\"./any\");\nconst bytes_1 = require(\"./bytes\");\nconst util_1 = require(\"./util\");\nconst enum_1 = require(\"./enum\");\nconst value_1 = require(\"./value\");\nconst duration_1 = require(\"./duration\");\nconst timestamp_1 = require(\"./timestamp\");\nconst wrappers_1 = require(\"./wrappers\");\nconst fieldmask_1 = require(\"./fieldmask\");\nconst id = (x) => {\n    return x;\n};\nfunction toProto3JSON(obj) {\n    const objType = obj.$type;\n    if (!objType) {\n        throw new Error('Cannot serialize object to proto3 JSON since its .$type is unknown. Use Type.fromObject(obj) before calling toProto3JSON.');\n    }\n    objType.resolveAll();\n    const typeName = util_1.getFullyQualifiedTypeName(objType);\n    // Types that require special handling according to\n    // https://developers.google.com/protocol-buffers/docs/proto3#json\n    if (typeName === '.google.protobuf.Any') {\n        return any_1.googleProtobufAnyToProto3JSON(obj);\n    }\n    if (typeName === '.google.protobuf.Value') {\n        return value_1.googleProtobufValueToProto3JSON(obj);\n    }\n    if (typeName === '.google.protobuf.Struct') {\n        return value_1.googleProtobufStructToProto3JSON(obj);\n    }\n    if (typeName === '.google.protobuf.ListValue') {\n        return value_1.googleProtobufListValueToProto3JSON(obj);\n    }\n    if (typeName === '.google.protobuf.Duration') {\n        return duration_1.googleProtobufDurationToProto3JSON(obj);\n    }\n    if (typeName === '.google.protobuf.Timestamp') {\n        return timestamp_1.googleProtobufTimestampToProto3JSON(obj);\n    }\n    if (typeName === '.google.protobuf.FieldMask') {\n        return fieldmask_1.googleProtobufFieldMaskToProto3JSON(obj);\n    }\n    if (util_1.wrapperTypes.has(typeName)) {\n        return wrappers_1.wrapperToProto3JSON(obj);\n    }\n    const result = {};\n    for (const [key, value] of Object.entries(obj)) {\n        const field = objType.fields[key];\n        const fieldResolvedType = field.resolvedType;\n        const fieldFullyQualifiedTypeName = fieldResolvedType\n            ? util_1.getFullyQualifiedTypeName(fieldResolvedType)\n            : null;\n        if (value === null) {\n            result[key] = null;\n            continue;\n        }\n        if (Array.isArray(value)) {\n            // if the repeated value has a complex type, convert it to proto3 JSON, otherwise use as is\n            result[key] = value.map(fieldResolvedType\n                ? element => {\n                    return toProto3JSON(element);\n                }\n                : id);\n            continue;\n        }\n        if (field.map) {\n            const map = {};\n            for (const [mapKey, mapValue] of Object.entries(value)) {\n                // if the map value has a complex type, convert it to proto3 JSON, otherwise use as is\n                map[mapKey] = fieldResolvedType\n                    ? toProto3JSON(mapValue)\n                    : mapValue;\n            }\n            result[key] = map;\n            continue;\n        }\n        if (fieldFullyQualifiedTypeName === '.google.protobuf.NullValue') {\n            result[key] = null;\n            continue;\n        }\n        if (fieldResolvedType && 'values' in fieldResolvedType && value !== null) {\n            result[key] = enum_1.resolveEnumValueToString(fieldResolvedType, value);\n            continue;\n        }\n        if (fieldResolvedType) {\n            result[key] = toProto3JSON(value);\n            continue;\n        }\n        if (typeof value === 'string' ||\n            typeof value === 'number' ||\n            typeof value === 'boolean' ||\n            value === null) {\n            result[key] = value;\n            continue;\n        }\n        if (Buffer.isBuffer(value) || value instanceof Uint8Array) {\n            result[key] = bytes_1.bytesToProto3JSON(value);\n            continue;\n        }\n        // The remaining case is Long, everything else is an internal error\n        assert(value.constructor.name === 'Long', `toProto3JSON: don't know how to convert field ${key} with value ${value}`);\n        result[key] = value.toString();\n        continue;\n    }\n    return result;\n}\nexports.toProto3JSON = toProto3JSON;\n//# sourceMappingURL=toproto3json.js.map"]},"metadata":{},"sourceType":"script"}