{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst query_partition_1 = require(\"./query-partition\");\n\nconst util_1 = require(\"./util\");\n\nconst logger_1 = require(\"./logger\");\n\nconst reference_1 = require(\"./reference\");\n\nconst path_1 = require(\"./path\");\n\nconst validate_1 = require(\"./validate\");\n\nconst types_1 = require(\"./types\");\n\nconst order_1 = require(\"./order\");\n/**\n * A `CollectionGroup` refers to all documents that are contained in a\n * collection or subcollection with a specific collection ID.\n *\n * @class CollectionGroup\n */\n\n\nclass CollectionGroup extends reference_1.Query {\n  /** @hideconstructor */\n  constructor(firestore, collectionId, converter) {\n    super(firestore, reference_1.QueryOptions.forCollectionGroupQuery(collectionId, converter));\n  }\n  /**\n   * Partitions a query by returning partition cursors that can be used to run\n   * the query in parallel. The returned cursors are split points that can be\n   * used as starting and end points for individual query invocations.\n   *\n   * @example\n   * const query = firestore.collectionGroup('collectionId');\n   * for await (const partition of query.getPartitions(42)) {\n   *   const partitionedQuery = partition.toQuery();\n   *   const querySnapshot = await partitionedQuery.get();\n   *   console.log(`Partition contained ${querySnapshot.length} documents`);\n   * }\n   *\n   * @param {number} desiredPartitionCount The desired maximum number of\n   * partition points. The number must be strictly positive. The actual number\n   * of partitions returned may be fewer.\n   * @return {AsyncIterable<QueryPartition>} An AsyncIterable of\n   * `QueryPartition`s.\n   */\n\n\n  async *getPartitions(desiredPartitionCount) {\n    var _a;\n\n    validate_1.validateInteger('desiredPartitionCount', desiredPartitionCount, {\n      minValue: 1\n    });\n    const tag = util_1.requestTag();\n    await this.firestore.initializeIfNeeded(tag);\n    const partitions = [];\n\n    if (desiredPartitionCount > 1) {\n      // Partition queries require explicit ordering by __name__.\n      const queryWithDefaultOrder = this.orderBy(path_1.FieldPath.documentId());\n      const request = queryWithDefaultOrder.toProto(); // Since we are always returning an extra partition (with an empty endBefore\n      // cursor), we reduce the desired partition count by one.\n\n      request.partitionCount = desiredPartitionCount - 1;\n      const stream = await this.firestore.requestStream('partitionQueryStream', request, tag);\n      stream.resume();\n\n      for await (const currentCursor of stream) {\n        partitions.push((_a = currentCursor.values) !== null && _a !== void 0 ? _a : []);\n      }\n    }\n\n    logger_1.logger('Firestore.getPartitions', tag, 'Received %d partitions', partitions.length); // Sort the partitions as they may not be ordered if responses are paged.\n\n    partitions.sort((l, r) => order_1.compareArrays(l, r));\n\n    for (let i = 0; i < partitions.length; ++i) {\n      yield new query_partition_1.QueryPartition(this._firestore, this._queryOptions.collectionId, this._queryOptions.converter, i > 0 ? partitions[i - 1] : undefined, partitions[i]);\n    } // Return the extra partition with the empty cursor.\n\n\n    yield new query_partition_1.QueryPartition(this._firestore, this._queryOptions.collectionId, this._queryOptions.converter, partitions.pop(), undefined);\n  }\n\n  withConverter(converter) {\n    return new CollectionGroup(this.firestore, this._queryOptions.collectionId, converter !== null && converter !== void 0 ? converter : types_1.defaultConverter());\n  }\n\n}\n\nexports.CollectionGroup = CollectionGroup;","map":{"version":3,"sources":["/home/invidam/hamburger_calender/client/node_modules/@google-cloud/firestore/build/src/collection-group.js"],"names":["Object","defineProperty","exports","value","query_partition_1","require","util_1","logger_1","reference_1","path_1","validate_1","types_1","order_1","CollectionGroup","Query","constructor","firestore","collectionId","converter","QueryOptions","forCollectionGroupQuery","getPartitions","desiredPartitionCount","_a","validateInteger","minValue","tag","requestTag","initializeIfNeeded","partitions","queryWithDefaultOrder","orderBy","FieldPath","documentId","request","toProto","partitionCount","stream","requestStream","resume","currentCursor","push","values","logger","length","sort","l","r","compareArrays","i","QueryPartition","_firestore","_queryOptions","undefined","pop","withConverter","defaultConverter"],"mappings":"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","sourcesContent":["\"use strict\";\n/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst query_partition_1 = require(\"./query-partition\");\nconst util_1 = require(\"./util\");\nconst logger_1 = require(\"./logger\");\nconst reference_1 = require(\"./reference\");\nconst path_1 = require(\"./path\");\nconst validate_1 = require(\"./validate\");\nconst types_1 = require(\"./types\");\nconst order_1 = require(\"./order\");\n/**\n * A `CollectionGroup` refers to all documents that are contained in a\n * collection or subcollection with a specific collection ID.\n *\n * @class CollectionGroup\n */\nclass CollectionGroup extends reference_1.Query {\n    /** @hideconstructor */\n    constructor(firestore, collectionId, converter) {\n        super(firestore, reference_1.QueryOptions.forCollectionGroupQuery(collectionId, converter));\n    }\n    /**\n     * Partitions a query by returning partition cursors that can be used to run\n     * the query in parallel. The returned cursors are split points that can be\n     * used as starting and end points for individual query invocations.\n     *\n     * @example\n     * const query = firestore.collectionGroup('collectionId');\n     * for await (const partition of query.getPartitions(42)) {\n     *   const partitionedQuery = partition.toQuery();\n     *   const querySnapshot = await partitionedQuery.get();\n     *   console.log(`Partition contained ${querySnapshot.length} documents`);\n     * }\n     *\n     * @param {number} desiredPartitionCount The desired maximum number of\n     * partition points. The number must be strictly positive. The actual number\n     * of partitions returned may be fewer.\n     * @return {AsyncIterable<QueryPartition>} An AsyncIterable of\n     * `QueryPartition`s.\n     */\n    async *getPartitions(desiredPartitionCount) {\n        var _a;\n        validate_1.validateInteger('desiredPartitionCount', desiredPartitionCount, {\n            minValue: 1,\n        });\n        const tag = util_1.requestTag();\n        await this.firestore.initializeIfNeeded(tag);\n        const partitions = [];\n        if (desiredPartitionCount > 1) {\n            // Partition queries require explicit ordering by __name__.\n            const queryWithDefaultOrder = this.orderBy(path_1.FieldPath.documentId());\n            const request = queryWithDefaultOrder.toProto();\n            // Since we are always returning an extra partition (with an empty endBefore\n            // cursor), we reduce the desired partition count by one.\n            request.partitionCount = desiredPartitionCount - 1;\n            const stream = await this.firestore.requestStream('partitionQueryStream', request, tag);\n            stream.resume();\n            for await (const currentCursor of stream) {\n                partitions.push((_a = currentCursor.values) !== null && _a !== void 0 ? _a : []);\n            }\n        }\n        logger_1.logger('Firestore.getPartitions', tag, 'Received %d partitions', partitions.length);\n        // Sort the partitions as they may not be ordered if responses are paged.\n        partitions.sort((l, r) => order_1.compareArrays(l, r));\n        for (let i = 0; i < partitions.length; ++i) {\n            yield new query_partition_1.QueryPartition(this._firestore, this._queryOptions.collectionId, this._queryOptions.converter, i > 0 ? partitions[i - 1] : undefined, partitions[i]);\n        }\n        // Return the extra partition with the empty cursor.\n        yield new query_partition_1.QueryPartition(this._firestore, this._queryOptions.collectionId, this._queryOptions.converter, partitions.pop(), undefined);\n    }\n    withConverter(converter) {\n        return new CollectionGroup(this.firestore, this._queryOptions.collectionId, converter !== null && converter !== void 0 ? converter : types_1.defaultConverter());\n    }\n}\nexports.CollectionGroup = CollectionGroup;\n//# sourceMappingURL=collection-group.js.map"]},"metadata":{},"sourceType":"script"}