{"ast":null,"code":"\"use strict\"; // Copyright 2020 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst document_1 = require(\"./document\");\n\nconst reference_1 = require(\"./reference\");\n\nconst timestamp_1 = require(\"./timestamp\");\n\nconst validate_1 = require(\"./validate\");\n\nconst BUNDLE_VERSION = 1;\n/**\n * Builds a Firestore data bundle with results from the given document and query snapshots.\n */\n\nclass BundleBuilder {\n  constructor(bundleId) {\n    this.bundleId = bundleId; // Resulting documents for the bundle, keyed by full document path.\n\n    this.documents = new Map(); // Named queries saved in the bundle, keyed by query name.\n\n    this.namedQueries = new Map(); // The latest read time among all bundled documents and queries.\n\n    this.latestReadTime = new timestamp_1.Timestamp(0, 0);\n  }\n  /**\n   * Adds a Firestore document snapshot or query snapshot to the bundle.\n   * Both the documents data and the query read time will be included in the bundle.\n   *\n   * @param {DocumentSnapshot | string} documentOrName A document snapshot to add or a name of a query.\n   * @param {Query=} querySnapshot A query snapshot to add to the bundle, if provided.\n   * @returns {BundleBuilder} This instance.\n   *\n   * @example\n   * const bundle = firestore.bundle('data-bundle');\n   * const docSnapshot = await firestore.doc('abc/123').get();\n   * const querySnapshot = await firestore.collection('coll').get();\n   *\n   * const bundleBuffer = bundle.add(docSnapshot); // Add a document\n   *                            .add('coll-query', querySnapshot) // Add a named query.\n   *                            .build()\n   * // Save `bundleBuffer` to CDN or stream it to clients.\n   */\n\n\n  add(documentOrName, querySnapshot) {\n    // eslint-disable-next-line prefer-rest-params\n    validate_1.validateMinNumberOfArguments('BundleBuilder.add', arguments, 1); // eslint-disable-next-line prefer-rest-params\n\n    validate_1.validateMaxNumberOfArguments('BundleBuilder.add', arguments, 2);\n\n    if (arguments.length === 1) {\n      validateDocumentSnapshot('documentOrName', documentOrName);\n      this.addBundledDocument(documentOrName);\n    } else {\n      validate_1.validateString('documentOrName', documentOrName);\n      validateQuerySnapshot('querySnapshot', querySnapshot);\n      this.addNamedQuery(documentOrName, querySnapshot);\n    }\n\n    return this;\n  }\n\n  addBundledDocument(snap, queryName) {\n    const originalDocument = this.documents.get(snap.ref.path);\n    const originalQueries = originalDocument === null || originalDocument === void 0 ? void 0 : originalDocument.metadata.queries; // Update with document built from `snap` because it is newer.\n\n    if (!originalDocument || timestamp_1.Timestamp.fromProto(originalDocument.metadata.readTime) < snap.readTime) {\n      const docProto = snap.toDocumentProto();\n      this.documents.set(snap.ref.path, {\n        document: snap.exists ? docProto : undefined,\n        metadata: {\n          name: docProto.name,\n          readTime: snap.readTime.toProto().timestampValue,\n          exists: snap.exists\n        }\n      });\n    } // Update `queries` to include both original and `queryName`.\n\n\n    const newDocument = this.documents.get(snap.ref.path);\n    newDocument.metadata.queries = originalQueries || [];\n\n    if (queryName) {\n      newDocument.metadata.queries.push(queryName);\n    }\n\n    if (snap.readTime > this.latestReadTime) {\n      this.latestReadTime = snap.readTime;\n    }\n  }\n\n  addNamedQuery(name, querySnap) {\n    if (this.namedQueries.has(name)) {\n      throw new Error(`Query name conflict: ${name} has already been added.`);\n    }\n\n    this.namedQueries.set(name, {\n      name,\n      bundledQuery: querySnap.query._toBundledQuery(),\n      readTime: querySnap.readTime.toProto().timestampValue\n    });\n\n    for (const snap of querySnap.docs) {\n      this.addBundledDocument(snap, name);\n    }\n\n    if (querySnap.readTime > this.latestReadTime) {\n      this.latestReadTime = querySnap.readTime;\n    }\n  }\n  /**\n   * Converts a IBundleElement to a Buffer whose content is the length prefixed JSON representation\n   * of the element.\n   * @private\n   * @internal\n   */\n\n\n  elementToLengthPrefixedBuffer(bundleElement) {\n    // Convert to a valid proto message object then take its JSON representation.\n    // This take cares of stuff like converting internal byte array fields\n    // to Base64 encodings.\n    // We lazy-load the Proto file to reduce cold-start times.\n    const message = require('../protos/firestore_v1_proto_api').firestore.BundleElement.fromObject(bundleElement).toJSON();\n\n    const buffer = Buffer.from(JSON.stringify(message), 'utf-8');\n    const lengthBuffer = Buffer.from(buffer.length.toString());\n    return Buffer.concat([lengthBuffer, buffer]);\n  }\n\n  build() {\n    let bundleBuffer = Buffer.alloc(0);\n\n    for (const namedQuery of this.namedQueries.values()) {\n      bundleBuffer = Buffer.concat([bundleBuffer, this.elementToLengthPrefixedBuffer({\n        namedQuery\n      })]);\n    }\n\n    for (const bundledDocument of this.documents.values()) {\n      const documentMetadata = bundledDocument.metadata;\n      bundleBuffer = Buffer.concat([bundleBuffer, this.elementToLengthPrefixedBuffer({\n        documentMetadata\n      })]); // Write to the bundle if document exists.\n\n      const document = bundledDocument.document;\n\n      if (document) {\n        bundleBuffer = Buffer.concat([bundleBuffer, this.elementToLengthPrefixedBuffer({\n          document\n        })]);\n      }\n    }\n\n    const metadata = {\n      id: this.bundleId,\n      createTime: this.latestReadTime.toProto().timestampValue,\n      version: BUNDLE_VERSION,\n      totalDocuments: this.documents.size,\n      totalBytes: bundleBuffer.length\n    }; // Prepends the metadata element to the bundleBuffer: `bundleBuffer` is the second argument to `Buffer.concat`.\n\n    bundleBuffer = Buffer.concat([this.elementToLengthPrefixedBuffer({\n      metadata\n    }), bundleBuffer]);\n    return bundleBuffer;\n  }\n\n}\n\nexports.BundleBuilder = BundleBuilder;\n/**\n * Convenient class to hold both the metadata and the actual content of a document to be bundled.\n * @private\n * @internal\n */\n\nclass BundledDocument {\n  constructor(metadata, document) {\n    this.metadata = metadata;\n    this.document = document;\n  }\n\n}\n/**\n * Validates that 'value' is DocumentSnapshot.\n *\n * @private\n * @internal\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n */\n\n\nfunction validateDocumentSnapshot(arg, value) {\n  if (!(value instanceof document_1.DocumentSnapshot)) {\n    throw new Error(validate_1.invalidArgumentMessage(arg, 'DocumentSnapshot'));\n  }\n}\n/**\n * Validates that 'value' is QuerySnapshot.\n *\n * @private\n * @internal\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n */\n\n\nfunction validateQuerySnapshot(arg, value) {\n  if (!(value instanceof reference_1.QuerySnapshot)) {\n    throw new Error(validate_1.invalidArgumentMessage(arg, 'QuerySnapshot'));\n  }\n}","map":{"version":3,"sources":["/home/invidam/hamburger_calender/client/node_modules/@google-cloud/firestore/build/src/bundle.js"],"names":["Object","defineProperty","exports","value","document_1","require","reference_1","timestamp_1","validate_1","BUNDLE_VERSION","BundleBuilder","constructor","bundleId","documents","Map","namedQueries","latestReadTime","Timestamp","add","documentOrName","querySnapshot","validateMinNumberOfArguments","arguments","validateMaxNumberOfArguments","length","validateDocumentSnapshot","addBundledDocument","validateString","validateQuerySnapshot","addNamedQuery","snap","queryName","originalDocument","get","ref","path","originalQueries","metadata","queries","fromProto","readTime","docProto","toDocumentProto","set","document","exists","undefined","name","toProto","timestampValue","newDocument","push","querySnap","has","Error","bundledQuery","query","_toBundledQuery","docs","elementToLengthPrefixedBuffer","bundleElement","message","firestore","BundleElement","fromObject","toJSON","buffer","Buffer","from","JSON","stringify","lengthBuffer","toString","concat","build","bundleBuffer","alloc","namedQuery","values","bundledDocument","documentMetadata","id","createTime","version","totalDocuments","size","totalBytes","BundledDocument","arg","DocumentSnapshot","invalidArgumentMessage","QuerySnapshot"],"mappings":"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","sourcesContent":["\"use strict\";\n// Copyright 2020 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst document_1 = require(\"./document\");\nconst reference_1 = require(\"./reference\");\nconst timestamp_1 = require(\"./timestamp\");\nconst validate_1 = require(\"./validate\");\nconst BUNDLE_VERSION = 1;\n/**\n * Builds a Firestore data bundle with results from the given document and query snapshots.\n */\nclass BundleBuilder {\n    constructor(bundleId) {\n        this.bundleId = bundleId;\n        // Resulting documents for the bundle, keyed by full document path.\n        this.documents = new Map();\n        // Named queries saved in the bundle, keyed by query name.\n        this.namedQueries = new Map();\n        // The latest read time among all bundled documents and queries.\n        this.latestReadTime = new timestamp_1.Timestamp(0, 0);\n    }\n    /**\n     * Adds a Firestore document snapshot or query snapshot to the bundle.\n     * Both the documents data and the query read time will be included in the bundle.\n     *\n     * @param {DocumentSnapshot | string} documentOrName A document snapshot to add or a name of a query.\n     * @param {Query=} querySnapshot A query snapshot to add to the bundle, if provided.\n     * @returns {BundleBuilder} This instance.\n     *\n     * @example\n     * const bundle = firestore.bundle('data-bundle');\n     * const docSnapshot = await firestore.doc('abc/123').get();\n     * const querySnapshot = await firestore.collection('coll').get();\n     *\n     * const bundleBuffer = bundle.add(docSnapshot); // Add a document\n     *                            .add('coll-query', querySnapshot) // Add a named query.\n     *                            .build()\n     * // Save `bundleBuffer` to CDN or stream it to clients.\n     */\n    add(documentOrName, querySnapshot) {\n        // eslint-disable-next-line prefer-rest-params\n        validate_1.validateMinNumberOfArguments('BundleBuilder.add', arguments, 1);\n        // eslint-disable-next-line prefer-rest-params\n        validate_1.validateMaxNumberOfArguments('BundleBuilder.add', arguments, 2);\n        if (arguments.length === 1) {\n            validateDocumentSnapshot('documentOrName', documentOrName);\n            this.addBundledDocument(documentOrName);\n        }\n        else {\n            validate_1.validateString('documentOrName', documentOrName);\n            validateQuerySnapshot('querySnapshot', querySnapshot);\n            this.addNamedQuery(documentOrName, querySnapshot);\n        }\n        return this;\n    }\n    addBundledDocument(snap, queryName) {\n        const originalDocument = this.documents.get(snap.ref.path);\n        const originalQueries = originalDocument === null || originalDocument === void 0 ? void 0 : originalDocument.metadata.queries;\n        // Update with document built from `snap` because it is newer.\n        if (!originalDocument ||\n            timestamp_1.Timestamp.fromProto(originalDocument.metadata.readTime) < snap.readTime) {\n            const docProto = snap.toDocumentProto();\n            this.documents.set(snap.ref.path, {\n                document: snap.exists ? docProto : undefined,\n                metadata: {\n                    name: docProto.name,\n                    readTime: snap.readTime.toProto().timestampValue,\n                    exists: snap.exists,\n                },\n            });\n        }\n        // Update `queries` to include both original and `queryName`.\n        const newDocument = this.documents.get(snap.ref.path);\n        newDocument.metadata.queries = originalQueries || [];\n        if (queryName) {\n            newDocument.metadata.queries.push(queryName);\n        }\n        if (snap.readTime > this.latestReadTime) {\n            this.latestReadTime = snap.readTime;\n        }\n    }\n    addNamedQuery(name, querySnap) {\n        if (this.namedQueries.has(name)) {\n            throw new Error(`Query name conflict: ${name} has already been added.`);\n        }\n        this.namedQueries.set(name, {\n            name,\n            bundledQuery: querySnap.query._toBundledQuery(),\n            readTime: querySnap.readTime.toProto().timestampValue,\n        });\n        for (const snap of querySnap.docs) {\n            this.addBundledDocument(snap, name);\n        }\n        if (querySnap.readTime > this.latestReadTime) {\n            this.latestReadTime = querySnap.readTime;\n        }\n    }\n    /**\n     * Converts a IBundleElement to a Buffer whose content is the length prefixed JSON representation\n     * of the element.\n     * @private\n     * @internal\n     */\n    elementToLengthPrefixedBuffer(bundleElement) {\n        // Convert to a valid proto message object then take its JSON representation.\n        // This take cares of stuff like converting internal byte array fields\n        // to Base64 encodings.\n        // We lazy-load the Proto file to reduce cold-start times.\n        const message = require('../protos/firestore_v1_proto_api')\n            .firestore.BundleElement.fromObject(bundleElement)\n            .toJSON();\n        const buffer = Buffer.from(JSON.stringify(message), 'utf-8');\n        const lengthBuffer = Buffer.from(buffer.length.toString());\n        return Buffer.concat([lengthBuffer, buffer]);\n    }\n    build() {\n        let bundleBuffer = Buffer.alloc(0);\n        for (const namedQuery of this.namedQueries.values()) {\n            bundleBuffer = Buffer.concat([\n                bundleBuffer,\n                this.elementToLengthPrefixedBuffer({ namedQuery }),\n            ]);\n        }\n        for (const bundledDocument of this.documents.values()) {\n            const documentMetadata = bundledDocument.metadata;\n            bundleBuffer = Buffer.concat([\n                bundleBuffer,\n                this.elementToLengthPrefixedBuffer({ documentMetadata }),\n            ]);\n            // Write to the bundle if document exists.\n            const document = bundledDocument.document;\n            if (document) {\n                bundleBuffer = Buffer.concat([\n                    bundleBuffer,\n                    this.elementToLengthPrefixedBuffer({ document }),\n                ]);\n            }\n        }\n        const metadata = {\n            id: this.bundleId,\n            createTime: this.latestReadTime.toProto().timestampValue,\n            version: BUNDLE_VERSION,\n            totalDocuments: this.documents.size,\n            totalBytes: bundleBuffer.length,\n        };\n        // Prepends the metadata element to the bundleBuffer: `bundleBuffer` is the second argument to `Buffer.concat`.\n        bundleBuffer = Buffer.concat([\n            this.elementToLengthPrefixedBuffer({ metadata }),\n            bundleBuffer,\n        ]);\n        return bundleBuffer;\n    }\n}\nexports.BundleBuilder = BundleBuilder;\n/**\n * Convenient class to hold both the metadata and the actual content of a document to be bundled.\n * @private\n * @internal\n */\nclass BundledDocument {\n    constructor(metadata, document) {\n        this.metadata = metadata;\n        this.document = document;\n    }\n}\n/**\n * Validates that 'value' is DocumentSnapshot.\n *\n * @private\n * @internal\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n */\nfunction validateDocumentSnapshot(arg, value) {\n    if (!(value instanceof document_1.DocumentSnapshot)) {\n        throw new Error(validate_1.invalidArgumentMessage(arg, 'DocumentSnapshot'));\n    }\n}\n/**\n * Validates that 'value' is QuerySnapshot.\n *\n * @private\n * @internal\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n */\nfunction validateQuerySnapshot(arg, value) {\n    if (!(value instanceof reference_1.QuerySnapshot)) {\n        throw new Error(validate_1.invalidArgumentMessage(arg, 'QuerySnapshot'));\n    }\n}\n//# sourceMappingURL=bundle.js.map"]},"metadata":{},"sourceType":"script"}