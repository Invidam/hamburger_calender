{"ast":null,"code":"const isObject = require('../help/is_object');\n\nlet validateCrit = require('../help/validate_crit');\n\nconst {\n  JWSInvalid\n} = require('../errors');\n\nvalidateCrit = validateCrit.bind(undefined, JWSInvalid);\n\nconst compactSerializer = (payload, [recipient]) => {\n  return `${recipient.protected}.${payload}.${recipient.signature}`;\n};\n\ncompactSerializer.validate = (jws, {\n  0: {\n    unprotectedHeader,\n    protectedHeader\n  },\n  length\n}) => {\n  if (length !== 1 || unprotectedHeader) {\n    throw new JWSInvalid('JWS Compact Serialization doesn\\'t support multiple recipients or JWS unprotected headers');\n  }\n\n  validateCrit(protectedHeader, unprotectedHeader, protectedHeader ? protectedHeader.crit : undefined);\n};\n\nconst flattenedSerializer = (payload, [recipient]) => {\n  const {\n    header,\n    signature,\n    protected: prot\n  } = recipient;\n  return {\n    payload,\n    ...(prot ? {\n      protected: prot\n    } : undefined),\n    ...(header ? {\n      header\n    } : undefined),\n    signature\n  };\n};\n\nflattenedSerializer.validate = (jws, {\n  0: {\n    unprotectedHeader,\n    protectedHeader\n  },\n  length\n}) => {\n  if (length !== 1) {\n    throw new JWSInvalid('Flattened JWS JSON Serialization doesn\\'t support multiple recipients');\n  }\n\n  validateCrit(protectedHeader, unprotectedHeader, protectedHeader ? protectedHeader.crit : undefined);\n};\n\nconst generalSerializer = (payload, recipients) => {\n  return {\n    payload,\n    signatures: recipients.map(({\n      header,\n      signature,\n      protected: prot\n    }) => {\n      return { ...(prot ? {\n          protected: prot\n        } : undefined),\n        ...(header ? {\n          header\n        } : undefined),\n        signature\n      };\n    })\n  };\n};\n\ngeneralSerializer.validate = (jws, recipients) => {\n  let validateB64 = false;\n  recipients.forEach(({\n    protectedHeader,\n    unprotectedHeader\n  }) => {\n    if (protectedHeader && !validateB64 && 'b64' in protectedHeader) {\n      validateB64 = true;\n    }\n\n    validateCrit(protectedHeader, unprotectedHeader, protectedHeader ? protectedHeader.crit : undefined);\n  });\n\n  if (validateB64) {\n    const values = recipients.map(({\n      protectedHeader\n    }) => protectedHeader && protectedHeader.b64);\n\n    if (!values.every((actual, i, [expected]) => actual === expected)) {\n      throw new JWSInvalid('the \"b64\" Header Parameter value MUST be the same for all recipients');\n    }\n  }\n};\n\nconst isJSON = input => {\n  return isObject(input) && (typeof input.payload === 'string' || Buffer.isBuffer(input.payload));\n};\n\nconst isValidRecipient = recipient => {\n  return isObject(recipient) && typeof recipient.signature === 'string' && (recipient.header === undefined || isObject(recipient.header)) && (recipient.protected === undefined || typeof recipient.protected === 'string');\n};\n\nconst isMultiRecipient = input => {\n  if (Array.isArray(input.signatures) && input.signatures.every(isValidRecipient)) {\n    return true;\n  }\n\n  return false;\n};\n\nconst detect = input => {\n  if (typeof input === 'string' && input.split('.').length === 3) {\n    return 'compact';\n  }\n\n  if (isJSON(input)) {\n    if (isMultiRecipient(input)) {\n      return 'general';\n    }\n\n    if (isValidRecipient(input)) {\n      return 'flattened';\n    }\n  }\n\n  throw new JWSInvalid('JWS malformed or invalid serialization');\n};\n\nmodule.exports = {\n  compact: compactSerializer,\n  flattened: flattenedSerializer,\n  general: generalSerializer,\n  detect\n};","map":{"version":3,"sources":["/home/invidam/hamburger_calender/client/node_modules/jose/lib/jws/serializers.js"],"names":["isObject","require","validateCrit","JWSInvalid","bind","undefined","compactSerializer","payload","recipient","protected","signature","validate","jws","unprotectedHeader","protectedHeader","length","crit","flattenedSerializer","header","prot","generalSerializer","recipients","signatures","map","validateB64","forEach","values","b64","every","actual","i","expected","isJSON","input","Buffer","isBuffer","isValidRecipient","isMultiRecipient","Array","isArray","detect","split","module","exports","compact","flattened","general"],"mappings":"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","sourcesContent":["const isObject = require('../help/is_object')\nlet validateCrit = require('../help/validate_crit')\nconst { JWSInvalid } = require('../errors')\n\nvalidateCrit = validateCrit.bind(undefined, JWSInvalid)\n\nconst compactSerializer = (payload, [recipient]) => {\n  return `${recipient.protected}.${payload}.${recipient.signature}`\n}\ncompactSerializer.validate = (jws, { 0: { unprotectedHeader, protectedHeader }, length }) => {\n  if (length !== 1 || unprotectedHeader) {\n    throw new JWSInvalid('JWS Compact Serialization doesn\\'t support multiple recipients or JWS unprotected headers')\n  }\n  validateCrit(protectedHeader, unprotectedHeader, protectedHeader ? protectedHeader.crit : undefined)\n}\n\nconst flattenedSerializer = (payload, [recipient]) => {\n  const { header, signature, protected: prot } = recipient\n\n  return {\n    payload,\n    ...prot ? { protected: prot } : undefined,\n    ...header ? { header } : undefined,\n    signature\n  }\n}\nflattenedSerializer.validate = (jws, { 0: { unprotectedHeader, protectedHeader }, length }) => {\n  if (length !== 1) {\n    throw new JWSInvalid('Flattened JWS JSON Serialization doesn\\'t support multiple recipients')\n  }\n  validateCrit(protectedHeader, unprotectedHeader, protectedHeader ? protectedHeader.crit : undefined)\n}\n\nconst generalSerializer = (payload, recipients) => {\n  return {\n    payload,\n    signatures: recipients.map(({ header, signature, protected: prot }) => {\n      return {\n        ...prot ? { protected: prot } : undefined,\n        ...header ? { header } : undefined,\n        signature\n      }\n    })\n  }\n}\ngeneralSerializer.validate = (jws, recipients) => {\n  let validateB64 = false\n  recipients.forEach(({ protectedHeader, unprotectedHeader }) => {\n    if (protectedHeader && !validateB64 && 'b64' in protectedHeader) {\n      validateB64 = true\n    }\n    validateCrit(protectedHeader, unprotectedHeader, protectedHeader ? protectedHeader.crit : undefined)\n  })\n\n  if (validateB64) {\n    const values = recipients.map(({ protectedHeader }) => protectedHeader && protectedHeader.b64)\n    if (!values.every((actual, i, [expected]) => actual === expected)) {\n      throw new JWSInvalid('the \"b64\" Header Parameter value MUST be the same for all recipients')\n    }\n  }\n}\n\nconst isJSON = (input) => {\n  return isObject(input) && (typeof input.payload === 'string' || Buffer.isBuffer(input.payload))\n}\n\nconst isValidRecipient = (recipient) => {\n  return isObject(recipient) && typeof recipient.signature === 'string' &&\n    (recipient.header === undefined || isObject(recipient.header)) &&\n    (recipient.protected === undefined || typeof recipient.protected === 'string')\n}\n\nconst isMultiRecipient = (input) => {\n  if (Array.isArray(input.signatures) && input.signatures.every(isValidRecipient)) {\n    return true\n  }\n\n  return false\n}\n\nconst detect = (input) => {\n  if (typeof input === 'string' && input.split('.').length === 3) {\n    return 'compact'\n  }\n\n  if (isJSON(input)) {\n    if (isMultiRecipient(input)) {\n      return 'general'\n    }\n\n    if (isValidRecipient(input)) {\n      return 'flattened'\n    }\n  }\n\n  throw new JWSInvalid('JWS malformed or invalid serialization')\n}\n\nmodule.exports = {\n  compact: compactSerializer,\n  flattened: flattenedSerializer,\n  general: generalSerializer,\n  detect\n}\n"]},"metadata":{},"sourceType":"script"}