{"ast":null,"code":"const isDisjoint = require('../help/is_disjoint');\n\nconst base64url = require('../help/base64url');\n\nlet validateCrit = require('../help/validate_crit');\n\nconst {\n  JWEInvalid,\n  JOSENotSupported\n} = require('../errors');\n\nvalidateCrit = validateCrit.bind(undefined, JWEInvalid);\n\nmodule.exports = (prot, unprotected, recipients, checkAlgorithms, crit) => {\n  if (typeof prot === 'string') {\n    try {\n      prot = base64url.JSON.decode(prot);\n    } catch (err) {\n      throw new JWEInvalid('could not parse JWE protected header');\n    }\n  }\n\n  let alg = [];\n  const enc = new Set();\n\n  if (!isDisjoint(prot, unprotected) || !recipients.every(({\n    header\n  }) => {\n    if (typeof header === 'object') {\n      alg.push(header.alg);\n      enc.add(header.enc);\n    }\n\n    const combined = { ...unprotected,\n      ...header\n    };\n    validateCrit(prot, combined, crit);\n\n    if ('zip' in combined) {\n      throw new JWEInvalid('\"zip\" Header Parameter MUST be integrity protected');\n    } else if (prot && 'zip' in prot && prot.zip !== 'DEF') {\n      throw new JOSENotSupported('only \"DEF\" compression algorithm is supported');\n    }\n\n    return isDisjoint(header, prot) && isDisjoint(header, unprotected);\n  })) {\n    throw new JWEInvalid('JWE Shared Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint');\n  }\n\n  if (typeof prot === 'object') {\n    alg.push(prot.alg);\n    enc.add(prot.enc);\n  }\n\n  if (typeof unprotected === 'object') {\n    alg.push(unprotected.alg);\n    enc.add(unprotected.enc);\n  }\n\n  alg = alg.filter(Boolean);\n  enc.delete(undefined);\n\n  if (recipients.length !== 1) {\n    if (alg.includes('dir') || alg.includes('ECDH-ES')) {\n      throw new JWEInvalid('dir and ECDH-ES alg may only be used with a single recipient');\n    }\n  }\n\n  if (checkAlgorithms) {\n    if (alg.length !== recipients.length) {\n      throw new JWEInvalid('missing Key Management algorithm');\n    }\n\n    if (enc.size === 0) {\n      throw new JWEInvalid('missing Content Encryption algorithm');\n    } else if (enc.size !== 1) {\n      throw new JWEInvalid('there must only be one Content Encryption algorithm');\n    }\n  } else {\n    if (enc.size > 1) {\n      throw new JWEInvalid('there must only be one Content Encryption algorithm');\n    }\n  }\n\n  return [...enc][0];\n};","map":{"version":3,"sources":["/home/invidam/hamburger_calender/client/node_modules/jose/lib/jwe/validate_headers.js"],"names":["isDisjoint","require","base64url","validateCrit","JWEInvalid","JOSENotSupported","bind","undefined","module","exports","prot","unprotected","recipients","checkAlgorithms","crit","JSON","decode","err","alg","enc","Set","every","header","push","add","combined","zip","filter","Boolean","delete","length","includes","size"],"mappings":"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","sourcesContent":["const isDisjoint = require('../help/is_disjoint')\nconst base64url = require('../help/base64url')\nlet validateCrit = require('../help/validate_crit')\nconst { JWEInvalid, JOSENotSupported } = require('../errors')\n\nvalidateCrit = validateCrit.bind(undefined, JWEInvalid)\n\nmodule.exports = (prot, unprotected, recipients, checkAlgorithms, crit) => {\n  if (typeof prot === 'string') {\n    try {\n      prot = base64url.JSON.decode(prot)\n    } catch (err) {\n      throw new JWEInvalid('could not parse JWE protected header')\n    }\n  }\n\n  let alg = []\n  const enc = new Set()\n  if (!isDisjoint(prot, unprotected) || !recipients.every(({ header }) => {\n    if (typeof header === 'object') {\n      alg.push(header.alg)\n      enc.add(header.enc)\n    }\n    const combined = { ...unprotected, ...header }\n    validateCrit(prot, combined, crit)\n    if ('zip' in combined) {\n      throw new JWEInvalid('\"zip\" Header Parameter MUST be integrity protected')\n    } else if (prot && 'zip' in prot && prot.zip !== 'DEF') {\n      throw new JOSENotSupported('only \"DEF\" compression algorithm is supported')\n    }\n    return isDisjoint(header, prot) && isDisjoint(header, unprotected)\n  })) {\n    throw new JWEInvalid('JWE Shared Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint')\n  }\n\n  if (typeof prot === 'object') {\n    alg.push(prot.alg)\n    enc.add(prot.enc)\n  }\n  if (typeof unprotected === 'object') {\n    alg.push(unprotected.alg)\n    enc.add(unprotected.enc)\n  }\n\n  alg = alg.filter(Boolean)\n  enc.delete(undefined)\n\n  if (recipients.length !== 1) {\n    if (alg.includes('dir') || alg.includes('ECDH-ES')) {\n      throw new JWEInvalid('dir and ECDH-ES alg may only be used with a single recipient')\n    }\n  }\n\n  if (checkAlgorithms) {\n    if (alg.length !== recipients.length) {\n      throw new JWEInvalid('missing Key Management algorithm')\n    }\n    if (enc.size === 0) {\n      throw new JWEInvalid('missing Content Encryption algorithm')\n    } else if (enc.size !== 1) {\n      throw new JWEInvalid('there must only be one Content Encryption algorithm')\n    }\n  } else {\n    if (enc.size > 1) {\n      throw new JWEInvalid('there must only be one Content Encryption algorithm')\n    }\n  }\n\n  return [...enc][0]\n}\n"]},"metadata":{},"sourceType":"script"}