{"ast":null,"code":"const isObject = require('../help/is_object');\n\nconst secs = require('../help/secs');\n\nconst epoch = require('../help/epoch');\n\nconst getKey = require('../help/get_key');\n\nconst JWS = require('../jws');\n\nconst isString = require('./shared_validations').isString.bind(undefined, TypeError);\n\nconst validateOptions = options => {\n  if (typeof options.iat !== 'boolean') {\n    throw new TypeError('options.iat must be a boolean');\n  }\n\n  if (typeof options.kid !== 'boolean') {\n    throw new TypeError('options.kid must be a boolean');\n  }\n\n  isString(options.subject, 'options.subject');\n  isString(options.issuer, 'options.issuer');\n\n  if (options.audience !== undefined && (typeof options.audience !== 'string' || !options.audience) && (!Array.isArray(options.audience) || options.audience.length === 0 || options.audience.some(a => !a || typeof a !== 'string'))) {\n    throw new TypeError('options.audience must be a string or an array of strings');\n  }\n\n  if (!isObject(options.header)) {\n    throw new TypeError('options.header must be an object');\n  }\n\n  isString(options.algorithm, 'options.algorithm');\n  isString(options.expiresIn, 'options.expiresIn');\n  isString(options.notBefore, 'options.notBefore');\n  isString(options.jti, 'options.jti');\n\n  if (options.now !== undefined && (!(options.now instanceof Date) || !options.now.getTime())) {\n    throw new TypeError('options.now must be a valid Date object');\n  }\n};\n\nmodule.exports = (payload, key, options = {}) => {\n  if (!isObject(options)) {\n    throw new TypeError('options must be an object');\n  }\n\n  const {\n    algorithm,\n    audience,\n    expiresIn,\n    header = {},\n    iat = true,\n    issuer,\n    jti,\n    kid = true,\n    notBefore,\n    subject,\n    now\n  } = options;\n  validateOptions({\n    algorithm,\n    audience,\n    expiresIn,\n    header,\n    iat,\n    issuer,\n    jti,\n    kid,\n    notBefore,\n    now,\n    subject\n  });\n\n  if (!isObject(payload)) {\n    throw new TypeError('payload must be an object');\n  }\n\n  let unix;\n\n  if (expiresIn || notBefore || iat) {\n    unix = epoch(now || new Date());\n  }\n\n  payload = { ...payload,\n    sub: subject || payload.sub,\n    aud: audience || payload.aud,\n    iss: issuer || payload.iss,\n    jti: jti || payload.jti,\n    iat: iat ? unix : payload.iat,\n    exp: expiresIn ? unix + secs(expiresIn) : payload.exp,\n    nbf: notBefore ? unix + secs(notBefore) : payload.nbf\n  };\n  key = getKey(key);\n  let includeKid;\n\n  if (typeof options.kid === 'boolean') {\n    includeKid = kid;\n  } else {\n    includeKid = !key.secret;\n  }\n\n  return JWS.sign(JSON.stringify(payload), key, { ...header,\n    alg: algorithm || header.alg,\n    kid: includeKid ? key.kid : header.kid\n  });\n};","map":{"version":3,"sources":["/home/invidam/hamburger_calender/client/node_modules/jose/lib/jwt/sign.js"],"names":["isObject","require","secs","epoch","getKey","JWS","isString","bind","undefined","TypeError","validateOptions","options","iat","kid","subject","issuer","audience","Array","isArray","length","some","a","header","algorithm","expiresIn","notBefore","jti","now","Date","getTime","module","exports","payload","key","unix","sub","aud","iss","exp","nbf","includeKid","secret","sign","JSON","stringify","alg"],"mappings":"AAAA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,mBAAD,CAAxB;;AACA,MAAMC,IAAI,GAAGD,OAAO,CAAC,cAAD,CAApB;;AACA,MAAME,KAAK,GAAGF,OAAO,CAAC,eAAD,CAArB;;AACA,MAAMG,MAAM,GAAGH,OAAO,CAAC,iBAAD,CAAtB;;AACA,MAAMI,GAAG,GAAGJ,OAAO,CAAC,QAAD,CAAnB;;AAEA,MAAMK,QAAQ,GAAGL,OAAO,CAAC,sBAAD,CAAP,CAAgCK,QAAhC,CAAyCC,IAAzC,CAA8CC,SAA9C,EAAyDC,SAAzD,CAAjB;;AAEA,MAAMC,eAAe,GAAIC,OAAD,IAAa;AACnC,MAAI,OAAOA,OAAO,CAACC,GAAf,KAAuB,SAA3B,EAAsC;AACpC,UAAM,IAAIH,SAAJ,CAAc,+BAAd,CAAN;AACD;;AAED,MAAI,OAAOE,OAAO,CAACE,GAAf,KAAuB,SAA3B,EAAsC;AACpC,UAAM,IAAIJ,SAAJ,CAAc,+BAAd,CAAN;AACD;;AAEDH,EAAAA,QAAQ,CAACK,OAAO,CAACG,OAAT,EAAkB,iBAAlB,CAAR;AACAR,EAAAA,QAAQ,CAACK,OAAO,CAACI,MAAT,EAAiB,gBAAjB,CAAR;;AAEA,MACEJ,OAAO,CAACK,QAAR,KAAqBR,SAArB,IAEE,CAAC,OAAOG,OAAO,CAACK,QAAf,KAA4B,QAA5B,IAAwC,CAACL,OAAO,CAACK,QAAlD,MACC,CAACC,KAAK,CAACC,OAAN,CAAcP,OAAO,CAACK,QAAtB,CAAD,IAAoCL,OAAO,CAACK,QAAR,CAAiBG,MAAjB,KAA4B,CAAhE,IAAqER,OAAO,CAACK,QAAR,CAAiBI,IAAjB,CAAsBC,CAAC,IAAI,CAACA,CAAD,IAAM,OAAOA,CAAP,KAAa,QAA9C,CADtE,CAHJ,EAME;AACA,UAAM,IAAIZ,SAAJ,CAAc,0DAAd,CAAN;AACD;;AAED,MAAI,CAACT,QAAQ,CAACW,OAAO,CAACW,MAAT,CAAb,EAA+B;AAC7B,UAAM,IAAIb,SAAJ,CAAc,kCAAd,CAAN;AACD;;AAEDH,EAAAA,QAAQ,CAACK,OAAO,CAACY,SAAT,EAAoB,mBAApB,CAAR;AACAjB,EAAAA,QAAQ,CAACK,OAAO,CAACa,SAAT,EAAoB,mBAApB,CAAR;AACAlB,EAAAA,QAAQ,CAACK,OAAO,CAACc,SAAT,EAAoB,mBAApB,CAAR;AACAnB,EAAAA,QAAQ,CAACK,OAAO,CAACe,GAAT,EAAc,aAAd,CAAR;;AAEA,MAAIf,OAAO,CAACgB,GAAR,KAAgBnB,SAAhB,KAA8B,EAAEG,OAAO,CAACgB,GAAR,YAAuBC,IAAzB,KAAkC,CAACjB,OAAO,CAACgB,GAAR,CAAYE,OAAZ,EAAjE,CAAJ,EAA6F;AAC3F,UAAM,IAAIpB,SAAJ,CAAc,yCAAd,CAAN;AACD;AACF,CAlCD;;AAoCAqB,MAAM,CAACC,OAAP,GAAiB,CAACC,OAAD,EAAUC,GAAV,EAAetB,OAAO,GAAG,EAAzB,KAAgC;AAC/C,MAAI,CAACX,QAAQ,CAACW,OAAD,CAAb,EAAwB;AACtB,UAAM,IAAIF,SAAJ,CAAc,2BAAd,CAAN;AACD;;AAED,QAAM;AACJc,IAAAA,SADI;AACOP,IAAAA,QADP;AACiBQ,IAAAA,SADjB;AAC4BF,IAAAA,MAAM,GAAG,EADrC;AACyCV,IAAAA,GAAG,GAAG,IAD/C;AAEJG,IAAAA,MAFI;AAEIW,IAAAA,GAFJ;AAESb,IAAAA,GAAG,GAAG,IAFf;AAEqBY,IAAAA,SAFrB;AAEgCX,IAAAA,OAFhC;AAEyCa,IAAAA;AAFzC,MAGFhB,OAHJ;AAKAD,EAAAA,eAAe,CAAC;AACda,IAAAA,SADc;AACHP,IAAAA,QADG;AACOQ,IAAAA,SADP;AACkBF,IAAAA,MADlB;AAC0BV,IAAAA,GAD1B;AAC+BG,IAAAA,MAD/B;AACuCW,IAAAA,GADvC;AAC4Cb,IAAAA,GAD5C;AACiDY,IAAAA,SADjD;AAC4DE,IAAAA,GAD5D;AACiEb,IAAAA;AADjE,GAAD,CAAf;;AAIA,MAAI,CAACd,QAAQ,CAACgC,OAAD,CAAb,EAAwB;AACtB,UAAM,IAAIvB,SAAJ,CAAc,2BAAd,CAAN;AACD;;AAED,MAAIyB,IAAJ;;AACA,MAAIV,SAAS,IAAIC,SAAb,IAA0Bb,GAA9B,EAAmC;AACjCsB,IAAAA,IAAI,GAAG/B,KAAK,CAACwB,GAAG,IAAI,IAAIC,IAAJ,EAAR,CAAZ;AACD;;AAEDI,EAAAA,OAAO,GAAG,EACR,GAAGA,OADK;AAERG,IAAAA,GAAG,EAAErB,OAAO,IAAIkB,OAAO,CAACG,GAFhB;AAGRC,IAAAA,GAAG,EAAEpB,QAAQ,IAAIgB,OAAO,CAACI,GAHjB;AAIRC,IAAAA,GAAG,EAAEtB,MAAM,IAAIiB,OAAO,CAACK,GAJf;AAKRX,IAAAA,GAAG,EAAEA,GAAG,IAAIM,OAAO,CAACN,GALZ;AAMRd,IAAAA,GAAG,EAAEA,GAAG,GAAGsB,IAAH,GAAUF,OAAO,CAACpB,GANlB;AAOR0B,IAAAA,GAAG,EAAEd,SAAS,GAAGU,IAAI,GAAGhC,IAAI,CAACsB,SAAD,CAAd,GAA4BQ,OAAO,CAACM,GAP1C;AAQRC,IAAAA,GAAG,EAAEd,SAAS,GAAGS,IAAI,GAAGhC,IAAI,CAACuB,SAAD,CAAd,GAA4BO,OAAO,CAACO;AAR1C,GAAV;AAWAN,EAAAA,GAAG,GAAG7B,MAAM,CAAC6B,GAAD,CAAZ;AAEA,MAAIO,UAAJ;;AAEA,MAAI,OAAO7B,OAAO,CAACE,GAAf,KAAuB,SAA3B,EAAsC;AACpC2B,IAAAA,UAAU,GAAG3B,GAAb;AACD,GAFD,MAEO;AACL2B,IAAAA,UAAU,GAAG,CAACP,GAAG,CAACQ,MAAlB;AACD;;AAED,SAAOpC,GAAG,CAACqC,IAAJ,CAASC,IAAI,CAACC,SAAL,CAAeZ,OAAf,CAAT,EAAkCC,GAAlC,EAAuC,EAC5C,GAAGX,MADyC;AAE5CuB,IAAAA,GAAG,EAAEtB,SAAS,IAAID,MAAM,CAACuB,GAFmB;AAG5ChC,IAAAA,GAAG,EAAE2B,UAAU,GAAGP,GAAG,CAACpB,GAAP,GAAaS,MAAM,CAACT;AAHS,GAAvC,CAAP;AAKD,CAjDD","sourcesContent":["const isObject = require('../help/is_object')\nconst secs = require('../help/secs')\nconst epoch = require('../help/epoch')\nconst getKey = require('../help/get_key')\nconst JWS = require('../jws')\n\nconst isString = require('./shared_validations').isString.bind(undefined, TypeError)\n\nconst validateOptions = (options) => {\n  if (typeof options.iat !== 'boolean') {\n    throw new TypeError('options.iat must be a boolean')\n  }\n\n  if (typeof options.kid !== 'boolean') {\n    throw new TypeError('options.kid must be a boolean')\n  }\n\n  isString(options.subject, 'options.subject')\n  isString(options.issuer, 'options.issuer')\n\n  if (\n    options.audience !== undefined &&\n    (\n      (typeof options.audience !== 'string' || !options.audience) &&\n      (!Array.isArray(options.audience) || options.audience.length === 0 || options.audience.some(a => !a || typeof a !== 'string'))\n    )\n  ) {\n    throw new TypeError('options.audience must be a string or an array of strings')\n  }\n\n  if (!isObject(options.header)) {\n    throw new TypeError('options.header must be an object')\n  }\n\n  isString(options.algorithm, 'options.algorithm')\n  isString(options.expiresIn, 'options.expiresIn')\n  isString(options.notBefore, 'options.notBefore')\n  isString(options.jti, 'options.jti')\n\n  if (options.now !== undefined && (!(options.now instanceof Date) || !options.now.getTime())) {\n    throw new TypeError('options.now must be a valid Date object')\n  }\n}\n\nmodule.exports = (payload, key, options = {}) => {\n  if (!isObject(options)) {\n    throw new TypeError('options must be an object')\n  }\n\n  const {\n    algorithm, audience, expiresIn, header = {}, iat = true,\n    issuer, jti, kid = true, notBefore, subject, now\n  } = options\n\n  validateOptions({\n    algorithm, audience, expiresIn, header, iat, issuer, jti, kid, notBefore, now, subject\n  })\n\n  if (!isObject(payload)) {\n    throw new TypeError('payload must be an object')\n  }\n\n  let unix\n  if (expiresIn || notBefore || iat) {\n    unix = epoch(now || new Date())\n  }\n\n  payload = {\n    ...payload,\n    sub: subject || payload.sub,\n    aud: audience || payload.aud,\n    iss: issuer || payload.iss,\n    jti: jti || payload.jti,\n    iat: iat ? unix : payload.iat,\n    exp: expiresIn ? unix + secs(expiresIn) : payload.exp,\n    nbf: notBefore ? unix + secs(notBefore) : payload.nbf\n  }\n\n  key = getKey(key)\n\n  let includeKid\n\n  if (typeof options.kid === 'boolean') {\n    includeKid = kid\n  } else {\n    includeKid = !key.secret\n  }\n\n  return JWS.sign(JSON.stringify(payload), key, {\n    ...header,\n    alg: algorithm || header.alg,\n    kid: includeKid ? key.kid : header.kid\n  })\n}\n"]},"metadata":{},"sourceType":"script"}