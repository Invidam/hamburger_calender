{"ast":null,"code":"const {\n  pbkdf2Sync: pbkdf2,\n  randomBytes\n} = require('crypto');\n\nconst {\n  KEYOBJECT\n} = require('../help/consts');\n\nconst base64url = require('../help/base64url');\n\nconst SALT_LENGTH = 16;\nconst NULL_BUFFER = Buffer.alloc(1, 0);\n\nconst concatSalt = (alg, p2s) => {\n  return Buffer.concat([Buffer.from(alg, 'utf8'), NULL_BUFFER, p2s]);\n};\n\nconst wrapKey = (keylen, sha, concat, wrap, {\n  [KEYOBJECT]: keyObject\n}, payload) => {\n  // Note that if password-based encryption is used for multiple\n  // recipients, it is expected that each recipient use different values\n  // for the PBES2 parameters \"p2s\" and \"p2c\".\n  // here we generate p2c between 2048 and 4096 and random p2s\n  const p2c = Math.floor(Math.random() * 2049 + 2048);\n  const p2s = randomBytes(SALT_LENGTH);\n  const salt = concat(p2s);\n  const derivedKey = pbkdf2(keyObject.export(), salt, p2c, keylen, sha);\n  const result = wrap({\n    [KEYOBJECT]: derivedKey\n  }, payload);\n  result.header = result.header || {};\n  Object.assign(result.header, {\n    p2c,\n    p2s: base64url.encodeBuffer(p2s)\n  });\n  return result;\n};\n\nconst unwrapKey = (keylen, sha, concat, unwrap, {\n  [KEYOBJECT]: keyObject\n}, payload, header) => {\n  const {\n    p2s,\n    p2c\n  } = header;\n  const salt = concat(p2s);\n  const derivedKey = pbkdf2(keyObject.export(), salt, p2c, keylen, sha);\n  return unwrap({\n    [KEYOBJECT]: derivedKey\n  }, payload, header);\n};\n\nmodule.exports = (JWA, JWK) => {\n  ['PBES2-HS256+A128KW', 'PBES2-HS384+A192KW', 'PBES2-HS512+A256KW'].forEach(jwaAlg => {\n    const kw = jwaAlg.substr(-6);\n    const kwWrap = JWA.keyManagementEncrypt.get(kw);\n    const kwUnwrap = JWA.keyManagementDecrypt.get(kw);\n    const keylen = parseInt(jwaAlg.substr(13, 3), 10) / 8;\n    const sha = `sha${jwaAlg.substr(8, 3)}`;\n\n    if (kwWrap && kwUnwrap) {\n      JWA.keyManagementEncrypt.set(jwaAlg, wrapKey.bind(undefined, keylen, sha, concatSalt.bind(undefined, jwaAlg), kwWrap));\n      JWA.keyManagementDecrypt.set(jwaAlg, unwrapKey.bind(undefined, keylen, sha, concatSalt.bind(undefined, jwaAlg), kwUnwrap));\n\n      JWK.oct.deriveKey[jwaAlg] = key => key.use === 'enc' || key.use === undefined;\n    }\n  });\n};","map":{"version":3,"sources":["/home/invidam/hamburger_calender/client/node_modules/jose/lib/jwa/pbes2.js"],"names":["pbkdf2Sync","pbkdf2","randomBytes","require","KEYOBJECT","base64url","SALT_LENGTH","NULL_BUFFER","Buffer","alloc","concatSalt","alg","p2s","concat","from","wrapKey","keylen","sha","wrap","keyObject","payload","p2c","Math","floor","random","salt","derivedKey","export","result","header","Object","assign","encodeBuffer","unwrapKey","unwrap","module","exports","JWA","JWK","forEach","jwaAlg","kw","substr","kwWrap","keyManagementEncrypt","get","kwUnwrap","keyManagementDecrypt","parseInt","set","bind","undefined","oct","deriveKey","key","use"],"mappings":"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","sourcesContent":["const { pbkdf2Sync: pbkdf2, randomBytes } = require('crypto')\n\nconst { KEYOBJECT } = require('../help/consts')\nconst base64url = require('../help/base64url')\n\nconst SALT_LENGTH = 16\nconst NULL_BUFFER = Buffer.alloc(1, 0)\n\nconst concatSalt = (alg, p2s) => {\n  return Buffer.concat([\n    Buffer.from(alg, 'utf8'),\n    NULL_BUFFER,\n    p2s\n  ])\n}\n\nconst wrapKey = (keylen, sha, concat, wrap, { [KEYOBJECT]: keyObject }, payload) => {\n  // Note that if password-based encryption is used for multiple\n  // recipients, it is expected that each recipient use different values\n  // for the PBES2 parameters \"p2s\" and \"p2c\".\n  // here we generate p2c between 2048 and 4096 and random p2s\n  const p2c = Math.floor((Math.random() * 2049) + 2048)\n  const p2s = randomBytes(SALT_LENGTH)\n  const salt = concat(p2s)\n\n  const derivedKey = pbkdf2(keyObject.export(), salt, p2c, keylen, sha)\n\n  const result = wrap({ [KEYOBJECT]: derivedKey }, payload)\n  result.header = result.header || {}\n  Object.assign(result.header, { p2c, p2s: base64url.encodeBuffer(p2s) })\n\n  return result\n}\n\nconst unwrapKey = (keylen, sha, concat, unwrap, { [KEYOBJECT]: keyObject }, payload, header) => {\n  const { p2s, p2c } = header\n  const salt = concat(p2s)\n  const derivedKey = pbkdf2(keyObject.export(), salt, p2c, keylen, sha)\n  return unwrap({ [KEYOBJECT]: derivedKey }, payload, header)\n}\n\nmodule.exports = (JWA, JWK) => {\n  ['PBES2-HS256+A128KW', 'PBES2-HS384+A192KW', 'PBES2-HS512+A256KW'].forEach((jwaAlg) => {\n    const kw = jwaAlg.substr(-6)\n    const kwWrap = JWA.keyManagementEncrypt.get(kw)\n    const kwUnwrap = JWA.keyManagementDecrypt.get(kw)\n    const keylen = parseInt(jwaAlg.substr(13, 3), 10) / 8\n    const sha = `sha${jwaAlg.substr(8, 3)}`\n\n    if (kwWrap && kwUnwrap) {\n      JWA.keyManagementEncrypt.set(jwaAlg, wrapKey.bind(undefined, keylen, sha, concatSalt.bind(undefined, jwaAlg), kwWrap))\n      JWA.keyManagementDecrypt.set(jwaAlg, unwrapKey.bind(undefined, keylen, sha, concatSalt.bind(undefined, jwaAlg), kwUnwrap))\n      JWK.oct.deriveKey[jwaAlg] = key => key.use === 'enc' || key.use === undefined\n    }\n  })\n}\n"]},"metadata":{},"sourceType":"script"}