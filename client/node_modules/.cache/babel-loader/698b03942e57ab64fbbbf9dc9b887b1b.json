{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2021 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst document_1 = require(\"./document\");\n\nconst util_1 = require(\"./util\");\n\nconst logger_1 = require(\"./logger\");\n/**\n * A wrapper around BatchGetDocumentsRequest that retries request upon stream\n * failure and returns ordered results.\n *\n * @private\n * @internal\n */\n\n\nclass DocumentReader {\n  /**\n   * Creates a new DocumentReader that fetches the provided documents (via\n   * `get()`).\n   *\n   * @param firestore The Firestore instance to use.\n   * @param allDocuments The documents to get.\n   */\n  constructor(firestore, allDocuments) {\n    this.firestore = firestore;\n    this.allDocuments = allDocuments;\n    this.outstandingDocuments = new Set();\n    this.retrievedDocuments = new Map();\n\n    for (const docRef of this.allDocuments) {\n      this.outstandingDocuments.add(docRef.formattedName);\n    }\n  }\n  /**\n   * Invokes the BatchGetDocuments RPC and returns the results.\n   *\n   * @param requestTag A unique client-assigned identifier for this request.\n   */\n\n\n  async get(requestTag) {\n    await this.fetchDocuments(requestTag); // BatchGetDocuments doesn't preserve document order. We use the request\n    // order to sort the resulting documents.\n\n    const orderedDocuments = [];\n\n    for (const docRef of this.allDocuments) {\n      const document = this.retrievedDocuments.get(docRef.formattedName);\n\n      if (document !== undefined) {\n        // Recreate the DocumentSnapshot with the DocumentReference\n        // containing the original converter.\n        const finalDoc = new document_1.DocumentSnapshotBuilder(docRef);\n        finalDoc.fieldsProto = document._fieldsProto;\n        finalDoc.readTime = document.readTime;\n        finalDoc.createTime = document.createTime;\n        finalDoc.updateTime = document.updateTime;\n        orderedDocuments.push(finalDoc.build());\n      } else {\n        throw new Error(`Did not receive document for \"${docRef.path}\".`);\n      }\n    }\n\n    return orderedDocuments;\n  }\n\n  async fetchDocuments(requestTag) {\n    if (!this.outstandingDocuments.size) {\n      return;\n    }\n\n    const request = {\n      database: this.firestore.formattedName,\n      transaction: this.transactionId,\n      documents: Array.from(this.outstandingDocuments)\n    };\n\n    if (this.fieldMask) {\n      const fieldPaths = this.fieldMask.map(fieldPath => fieldPath.formattedName);\n      request.mask = {\n        fieldPaths\n      };\n    }\n\n    let resultCount = 0;\n\n    try {\n      const stream = await this.firestore.requestStream('batchGetDocuments', request, requestTag);\n      stream.resume();\n\n      for await (const response of stream) {\n        let snapshot;\n\n        if (response.found) {\n          logger_1.logger('DocumentReader.fetchDocuments', requestTag, 'Received document: %s', response.found.name);\n          snapshot = this.firestore.snapshot_(response.found, response.readTime);\n        } else {\n          logger_1.logger('DocumentReader.fetchDocuments', requestTag, 'Document missing: %s', response.missing);\n          snapshot = this.firestore.snapshot_(response.missing, response.readTime);\n        }\n\n        const path = snapshot.ref.formattedName;\n        this.outstandingDocuments.delete(path);\n        this.retrievedDocuments.set(path, snapshot);\n        ++resultCount;\n      }\n    } catch (error) {\n      const shouldRetry = // Transactional reads are retried via the transaction runner.\n      !this.transactionId && // Only retry if we made progress.\n      resultCount > 0 && // Don't retry permanent errors.\n      error.code !== undefined && !util_1.isPermanentRpcError(error, 'batchGetDocuments');\n      logger_1.logger('DocumentReader.fetchDocuments', requestTag, 'BatchGetDocuments failed with error: %s. Retrying: %s', error, shouldRetry);\n\n      if (shouldRetry) {\n        return this.fetchDocuments(requestTag);\n      } else {\n        throw error;\n      }\n    } finally {\n      logger_1.logger('DocumentReader.fetchDocuments', requestTag, 'Received %d results', resultCount);\n    }\n  }\n\n}\n\nexports.DocumentReader = DocumentReader;","map":{"version":3,"sources":["/home/invidam/hamburger_calender/client/node_modules/@google-cloud/firestore/build/src/document-reader.js"],"names":["Object","defineProperty","exports","value","document_1","require","util_1","logger_1","DocumentReader","constructor","firestore","allDocuments","outstandingDocuments","Set","retrievedDocuments","Map","docRef","add","formattedName","get","requestTag","fetchDocuments","orderedDocuments","document","undefined","finalDoc","DocumentSnapshotBuilder","fieldsProto","_fieldsProto","readTime","createTime","updateTime","push","build","Error","path","size","request","database","transaction","transactionId","documents","Array","from","fieldMask","fieldPaths","map","fieldPath","mask","resultCount","stream","requestStream","resume","response","snapshot","found","logger","name","snapshot_","missing","ref","delete","set","error","shouldRetry","code","isPermanentRpcError"],"mappings":"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","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2021 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst document_1 = require(\"./document\");\nconst util_1 = require(\"./util\");\nconst logger_1 = require(\"./logger\");\n/**\n * A wrapper around BatchGetDocumentsRequest that retries request upon stream\n * failure and returns ordered results.\n *\n * @private\n * @internal\n */\nclass DocumentReader {\n    /**\n     * Creates a new DocumentReader that fetches the provided documents (via\n     * `get()`).\n     *\n     * @param firestore The Firestore instance to use.\n     * @param allDocuments The documents to get.\n     */\n    constructor(firestore, allDocuments) {\n        this.firestore = firestore;\n        this.allDocuments = allDocuments;\n        this.outstandingDocuments = new Set();\n        this.retrievedDocuments = new Map();\n        for (const docRef of this.allDocuments) {\n            this.outstandingDocuments.add(docRef.formattedName);\n        }\n    }\n    /**\n     * Invokes the BatchGetDocuments RPC and returns the results.\n     *\n     * @param requestTag A unique client-assigned identifier for this request.\n     */\n    async get(requestTag) {\n        await this.fetchDocuments(requestTag);\n        // BatchGetDocuments doesn't preserve document order. We use the request\n        // order to sort the resulting documents.\n        const orderedDocuments = [];\n        for (const docRef of this.allDocuments) {\n            const document = this.retrievedDocuments.get(docRef.formattedName);\n            if (document !== undefined) {\n                // Recreate the DocumentSnapshot with the DocumentReference\n                // containing the original converter.\n                const finalDoc = new document_1.DocumentSnapshotBuilder(docRef);\n                finalDoc.fieldsProto = document._fieldsProto;\n                finalDoc.readTime = document.readTime;\n                finalDoc.createTime = document.createTime;\n                finalDoc.updateTime = document.updateTime;\n                orderedDocuments.push(finalDoc.build());\n            }\n            else {\n                throw new Error(`Did not receive document for \"${docRef.path}\".`);\n            }\n        }\n        return orderedDocuments;\n    }\n    async fetchDocuments(requestTag) {\n        if (!this.outstandingDocuments.size) {\n            return;\n        }\n        const request = {\n            database: this.firestore.formattedName,\n            transaction: this.transactionId,\n            documents: Array.from(this.outstandingDocuments),\n        };\n        if (this.fieldMask) {\n            const fieldPaths = this.fieldMask.map(fieldPath => fieldPath.formattedName);\n            request.mask = { fieldPaths };\n        }\n        let resultCount = 0;\n        try {\n            const stream = await this.firestore.requestStream('batchGetDocuments', request, requestTag);\n            stream.resume();\n            for await (const response of stream) {\n                let snapshot;\n                if (response.found) {\n                    logger_1.logger('DocumentReader.fetchDocuments', requestTag, 'Received document: %s', response.found.name);\n                    snapshot = this.firestore.snapshot_(response.found, response.readTime);\n                }\n                else {\n                    logger_1.logger('DocumentReader.fetchDocuments', requestTag, 'Document missing: %s', response.missing);\n                    snapshot = this.firestore.snapshot_(response.missing, response.readTime);\n                }\n                const path = snapshot.ref.formattedName;\n                this.outstandingDocuments.delete(path);\n                this.retrievedDocuments.set(path, snapshot);\n                ++resultCount;\n            }\n        }\n        catch (error) {\n            const shouldRetry = \n            // Transactional reads are retried via the transaction runner.\n            !this.transactionId &&\n                // Only retry if we made progress.\n                resultCount > 0 &&\n                // Don't retry permanent errors.\n                error.code !== undefined &&\n                !util_1.isPermanentRpcError(error, 'batchGetDocuments');\n            logger_1.logger('DocumentReader.fetchDocuments', requestTag, 'BatchGetDocuments failed with error: %s. Retrying: %s', error, shouldRetry);\n            if (shouldRetry) {\n                return this.fetchDocuments(requestTag);\n            }\n            else {\n                throw error;\n            }\n        }\n        finally {\n            logger_1.logger('DocumentReader.fetchDocuments', requestTag, 'Received %d results', resultCount);\n        }\n    }\n}\nexports.DocumentReader = DocumentReader;\n//# sourceMappingURL=document-reader.js.map"]},"metadata":{},"sourceType":"script"}